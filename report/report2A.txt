*** File /usr/include/c++/11/bits/ptr_traits.h:
                // Pointer Traits -*- C++ -*-
                
                // Copyright (C) 2011-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/ptr_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _PTR_TRAITS_H
                #define _PTR_TRAITS_H 1
                
                #if __cplusplus >= 201103L
                
                #include <bits/move.h>
                
                #if __cplusplus > 201703L
                #define __cpp_lib_constexpr_memory 201811L
                namespace __gnu_debug { struct _Safe_iterator_base; }
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  class __undefined;
                
                  // Given Template<T, ...> and U return Template<U, ...>, otherwise invalid.
                  template<typename _Tp, typename _Up>
                    struct __replace_first_arg
                    { };
                
                  template<template<typename, typename...> class _Template, typename _Up,
                           typename _Tp, typename... _Types>
                    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
                    { using type = _Template<_Up, _Types...>; };
                
                  template<typename _Tp, typename _Up>
                    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;
                
                  template<typename _Tp>
                    using __make_not_void
                      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;
                
                  template<typename _Ptr>
                    struct __ptr_traits_elem_1
                    { };
                
                  template<template<typename, typename...> class _SomePointer, typename _Tp,
                	   typename... _Args>
                    struct __ptr_traits_elem_1<_SomePointer<_Tp, _Args...>>
                    {
                      using element_type = _Tp;
                      using pointer = _SomePointer<_Tp, _Args...>;
                
                      static pointer
                      pointer_to(__make_not_void<element_type>& __e)
                      { return pointer::pointer_to(__e); }
                    };
                
                  template<typename _Ptr, typename = void>
                    struct __ptr_traits_elem : __ptr_traits_elem_1<_Ptr>
                    { };
                
                  template<typename _Ptr>
                    struct __ptr_traits_elem<_Ptr, __void_t<typename _Ptr::element_type>>
                    {
                      using element_type = typename _Ptr::element_type;
                
                      static _Ptr
                      pointer_to(__make_not_void<element_type>& __e)
                      { return _Ptr::pointer_to(__e); }
                    };
                
                  /**
                   * @brief  Uniform interface to all pointer-like types
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Ptr>
                    struct pointer_traits : __ptr_traits_elem<_Ptr>
                    {
                    private:
                      template<typename _Tp>
                	using __difference_type = typename _Tp::difference_type;
                
                      template<typename _Tp, typename _Up, typename = void>
                	struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                      template<typename _Tp, typename _Up>
                	struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
                	{ using type = typename _Tp::template rebind<_Up>; };
                
                    public:
                      /// The pointer type.
                      using pointer = _Ptr;
                
                      /// The type used to represent the difference between two pointers.
                      using difference_type
                	= __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;
                
                      /// A pointer to a different type.
                      template<typename _Up>
                        using rebind = typename __rebind<_Ptr, _Up>::type;
                    };
                
                  /**
                   * @brief  Partial specialization for built-in pointers.
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Tp>
                    struct pointer_traits<_Tp*>
                    {
                      /// The pointer type
                      typedef _Tp* pointer;
                      /// The type pointed to
                      typedef _Tp  element_type;
                      /// Type used to represent the difference between two pointers
                      typedef ptrdiff_t difference_type;
                
                      template<typename _Up>
                        using rebind = _Up*;
                
                      /**
                       *  @brief  Obtain a pointer to an object
                       *  @param  __r  A reference to an object of type @c element_type
                       *  @return @c addressof(__r)
                      */
                      static _GLIBCXX20_CONSTEXPR pointer
        1593 ->       pointer_to(__make_not_void<element_type>& __r) noexcept
                      { return std::addressof(__r); }
                    };
                
                  /// Convenience alias for rebinding pointers.
                  template<typename _Ptr, typename _Tp>
                    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
                
                  template<typename _Tp>
                    constexpr _Tp*
                    __to_address(_Tp* __ptr) noexcept
                    {
                      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
                      return __ptr;
                    }
                
                #if __cplusplus <= 201703L
                  template<typename _Ptr>
                    constexpr typename std::pointer_traits<_Ptr>::element_type*
                    __to_address(const _Ptr& __ptr)
                    { return std::__to_address(__ptr.operator->()); }
                #else
                
                  template<typename _Ptr>
                    constexpr auto
                    __to_address(const _Ptr& __ptr) noexcept
                    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
                    { return std::pointer_traits<_Ptr>::to_address(__ptr); }
                
                  template<typename _Ptr, typename... _None>
                    constexpr auto
                    __to_address(const _Ptr& __ptr, _None...) noexcept
                    {
                      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
                	return std::__to_address(__ptr.base().operator->());
                      else
                	return std::__to_address(__ptr.operator->());
                    }
                
                #define __cpp_lib_to_address 201711L
                
                  /**
                   * @brief Obtain address referenced by a pointer to an object
                   * @param __ptr A pointer to an object
                   * @return @c __ptr
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Tp>
                    constexpr _Tp*
                    to_address(_Tp* __ptr) noexcept
                    { return std::__to_address(__ptr); }
                
                  /**
                   * @brief Obtain address referenced by a pointer to an object
                   * @param __ptr A pointer to an object
                   * @return @c pointer_traits<_Ptr>::to_address(__ptr) if that expression is
                             well-formed, otherwise @c to_address(__ptr.operator->())
                   * @ingroup pointer_abstractions
                  */
                  template<typename _Ptr>
                    constexpr auto
                    to_address(const _Ptr& __ptr) noexcept
                    { return std::__to_address(__ptr); }
                #endif // C++2a
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      149       1593

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1593   Total number of line executions
  1593.00   Average executions per line


*** File /usr/include/c++/11/new:
                // The -*- C++ -*- dynamic memory management header.
                
                // Copyright (C) 1994-2021 Free Software Foundation, Inc.
                
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                // 
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                // 
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file new
                 *  This is a Standard C++ Library header.
                 *
                 *  The header @c new defines several functions to manage dynamic memory and
                 *  handling memory allocation errors; see
                 *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/dynamic_memory.html
                 *  for more.
                 */
                
                #ifndef _NEW
                #define _NEW
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/exception.h>
                
                #pragma GCC visibility push(default)
                
                extern "C++" {
                
                namespace std 
                {
                  /**
                   *  @brief  Exception possibly thrown by @c new.
                   *  @ingroup exceptions
                   *
                   *  @c bad_alloc (or classes derived from it) is used to report allocation
                   *  errors from the throwing forms of @c new.  */
                  class bad_alloc : public exception
                  {
                  public:
                    bad_alloc() throw() { }
                
                #if __cplusplus >= 201103L
                    bad_alloc(const bad_alloc&) = default;
                    bad_alloc& operator=(const bad_alloc&) = default;
                #endif
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_alloc() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                
                #if __cplusplus >= 201103L
                  class bad_array_new_length : public bad_alloc
                  {
                  public:
                    bad_array_new_length() throw() { }
                
                    // This declaration is not useless:
                    // http://gcc.gnu.org/onlinedocs/gcc-3.0.2/gcc_6.html#SEC118
                    virtual ~bad_array_new_length() throw();
                
                    // See comment in eh_exception.cc.
                    virtual const char* what() const throw();
                  };
                #endif
                
                #if __cpp_aligned_new
                  enum class align_val_t: size_t {};
                #endif
                
                  struct nothrow_t
                  {
                #if __cplusplus >= 201103L
                    explicit nothrow_t() = default;
                #endif
                  };
                
                  extern const nothrow_t nothrow;
                
                  /** If you write your own error handler to be called by @c new, it must
                   *  be of this type.  */
                  typedef void (*new_handler)();
                
                  /// Takes a replacement handler as the argument, returns the
                  /// previous handler.
                  new_handler set_new_handler(new_handler) throw();
                
                #if __cplusplus >= 201103L
                  /// Return the current new handler.
                  new_handler get_new_handler() noexcept;
                #endif
                } // namespace std
                
                //@{
                /** These are replaceable signatures:
                 *  - normal single new and delete (no arguments, throw @c bad_alloc on error)
                 *  - normal array new and delete (same)
                 *  - @c nothrow single new and delete (take a @c nothrow argument, return
                 *    @c NULL on error)
                 *  - @c nothrow array new and delete (same)
                 *
                 *  Placement new and delete signatures (take a memory address argument,
                 *  does nothing) may not be replaced by a user's program.
                */
                _GLIBCXX_NODISCARD void* operator new(std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t) _GLIBCXX_THROW (std::bad_alloc)
                  __attribute__((__externally_visible__));
                void operator delete(void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #endif
                _GLIBCXX_NODISCARD void* operator new(std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT
                  __attribute__((__externally_visible__));
                #if __cpp_aligned_new
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete(void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete(void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t)
                  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                _GLIBCXX_NODISCARD void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
                void operator delete[](void*, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #if __cpp_sized_deallocation
                void operator delete(void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                void operator delete[](void*, std::size_t, std::align_val_t)
                  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
                #endif // __cpp_sized_deallocation
                #endif // __cpp_aligned_new
                
                // Default placement versions of operator new.
                _GLIBCXX_NODISCARD inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
      223317 -> { return __p; }
                _GLIBCXX_NODISCARD inline void* operator new[](std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT
                { return __p; }
                
                // Default placement versions of operator delete.
       ##### -> inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
                //@}
                } // extern "C++"
                
                #if __cplusplus >= 201703L
                #ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
                namespace std
                {
                #define __cpp_lib_launder 201606
                  /// Pointer optimization barrier [ptr.launder]
                  template<typename _Tp>
                    [[nodiscard]] constexpr _Tp*
                    launder(_Tp* __p) noexcept
                    { return __builtin_launder(__p); }
                
                  // The program is ill-formed if T is a function type or
                  // (possibly cv-qualified) void.
                
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args...) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                  template<typename _Ret, typename... _Args _GLIBCXX_NOEXCEPT_PARM>
                    void launder(_Ret (*)(_Args......) _GLIBCXX_NOEXCEPT_QUAL) = delete;
                
                  void launder(void*) = delete;
                  void launder(const void*) = delete;
                  void launder(volatile void*) = delete;
                  void launder(const volatile void*) = delete;
                }
                #endif // _GLIBCXX_HAVE_BUILTIN_LAUNDER
                #endif // C++17
                
                #if __cplusplus > 201703L
                namespace std
                {
                  /// Tag type used to declare a class-specific operator delete that can
                  /// invoke the destructor before deallocating the memory.
                  struct destroying_delete_t
                  {
                    explicit destroying_delete_t() = default;
                  };
                  /// Tag variable of type destroying_delete_t.
                  inline constexpr destroying_delete_t destroying_delete{};
                }
                // Only define the feature test macro if the compiler supports the feature:
                #if __cpp_impl_destroying_delete
                # define __cpp_lib_destroying_delete 201806L
                #endif
                #endif // C++20
                
                #pragma GCC visibility pop
                
                #endif


Top 10 Lines:

     Line      Count

      175     223317

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   223317   Total number of line executions
111658.50   Average executions per line


*** File /usr/include/c++/11/bits/charconv.h:
                // Numeric conversions (to_string, to_chars) -*- C++ -*-
                
                // Copyright (C) 2017-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/charconv.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{charconv}
                 */
                
                #ifndef _GLIBCXX_CHARCONV_H
                #define _GLIBCXX_CHARCONV_H 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201103L
                
                #include <type_traits>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                namespace __detail
                {
                  // Generic implementation for arbitrary bases.
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR unsigned
         956 ->     __to_chars_len(_Tp __value, int __base = 10) noexcept
                    {
                      static_assert(is_integral<_Tp>::value, "implementation bug");
                      static_assert(is_unsigned<_Tp>::value, "implementation bug");
                
                      unsigned __n = 1;
                      const unsigned __b2 = __base  * __base;
                      const unsigned __b3 = __b2 * __base;
                      const unsigned long __b4 = __b3 * __base;
                      for (;;)
                	{
                	  if (__value < (unsigned)__base) return __n;
                	  if (__value < __b2) return __n + 1;
                	  if (__value < __b3) return __n + 2;
                	  if (__value < __b4) return __n + 3;
                	  __value /= __b4;
                	  __n += 4;
                	}
                    }
                
                  // Write an unsigned integer value to the range [first,first+len).
                  // The caller is required to provide a buffer of exactly the right size
                  // (which can be determined by the __to_chars_len function).
                  template<typename _Tp>
                    void
         956 ->     __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
                    {
                      static_assert(is_integral<_Tp>::value, "implementation bug");
                      static_assert(is_unsigned<_Tp>::value, "implementation bug");
                
                      static constexpr char __digits[201] =
                	"0001020304050607080910111213141516171819"
                	"2021222324252627282930313233343536373839"
                	"4041424344454647484950515253545556575859"
                	"6061626364656667686970717273747576777879"
                	"8081828384858687888990919293949596979899";
                      unsigned __pos = __len - 1;
                      while (__val >= 100)
                	{
                	  auto const __num = (__val % 100) * 2;
                	  __val /= 100;
                	  __first[__pos] = __digits[__num + 1];
                	  __first[__pos - 1] = __digits[__num];
                	  __pos -= 2;
                	}
                      if (__val >= 10)
                	{
                	  auto const __num = __val * 2;
                	  __first[1] = __digits[__num + 1];
                	  __first[0] = __digits[__num];
                	}
                      else
                	__first[0] = '0' + __val;
                    }
                
                } // namespace __detail
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                #endif // C++11
                #endif // _GLIBCXX_CHARCONV_H


Top 10 Lines:

     Line      Count

       47        956
       72        956

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

     1912   Total number of line executions
   956.00   Average executions per line


*** File /usr/include/SFML/Window/ContextSettings.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_CONTEXTSETTINGS_HPP
                #define SFML_CONTEXTSETTINGS_HPP
                
                #include <SFML/Config.hpp>
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Structure defining the settings of the OpenGL
                ///        context attached to a window
                ///
                ////////////////////////////////////////////////////////////
                struct ContextSettings
                {
                    ////////////////////////////////////////////////////////////
                    /// \brief Enumeration of the context attribute flags
                    ///
                    ////////////////////////////////////////////////////////////
                    enum Attribute
                    {
                        Default = 0,      ///< Non-debug, compatibility context (this and the core attribute are mutually exclusive)
                        Core    = 1 << 0, ///< Core attribute
                        Debug   = 1 << 2  ///< Debug attribute
                    };
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// \param depth        Depth buffer bits
                    /// \param stencil      Stencil buffer bits
                    /// \param antialiasing Antialiasing level
                    /// \param major        Major number of the context version
                    /// \param minor        Minor number of the context version
                    /// \param attributes   Attribute flags of the context
                    /// \param sRgb         sRGB capable framebuffer
                    ///
                    ////////////////////////////////////////////////////////////
           1 ->     explicit ContextSettings(unsigned int depth = 0, unsigned int stencil = 0, unsigned int antialiasing = 0, unsigned int major = 1, unsigned int minor = 1, unsigned int attributes = Default, bool sRgb = false) :
                    depthBits        (depth),
                    stencilBits      (stencil),
                    antialiasingLevel(antialiasing),
                    majorVersion     (major),
                    minorVersion     (minor),
                    attributeFlags   (attributes),
                    sRgbCapable      (sRgb)
                    {
                    }
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    unsigned int depthBits;         ///< Bits of the depth buffer
                    unsigned int stencilBits;       ///< Bits of the stencil buffer
                    unsigned int antialiasingLevel; ///< Level of antialiasing
                    unsigned int majorVersion;      ///< Major number of the context version to create
                    unsigned int minorVersion;      ///< Minor number of the context version to create
                    Uint32       attributeFlags;    ///< The attribute flags to create the context with
                    bool         sRgbCapable;       ///< Whether the context framebuffer is sRGB capable
                };
                
                } // namespace sf
                
                
                #endif // SFML_CONTEXTSETTINGS_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::ContextSettings
                /// \ingroup window
                ///
                /// ContextSettings allows to define several advanced settings
                /// of the OpenGL context attached to a window. All these
                /// settings with the exception of the compatibility flag
                /// and anti-aliasing level have no impact on the regular
                /// SFML rendering (graphics module), so you may need to use
                /// this structure only if you're using SFML as a windowing
                /// system for custom OpenGL rendering.
                ///
                /// The depthBits and stencilBits members define the number
                /// of bits per pixel requested for the (respectively) depth
                /// and stencil buffers.
                ///
                /// antialiasingLevel represents the requested number of
                /// multisampling levels for anti-aliasing.
                ///
                /// majorVersion and minorVersion define the version of the
                /// OpenGL context that you want. Only versions greater or
                /// equal to 3.0 are relevant; versions lesser than 3.0 are
                /// all handled the same way (i.e. you can use any version
                /// < 3.0 if you don't want an OpenGL 3 context).
                ///
                /// When requesting a context with a version greater or equal
                /// to 3.2, you have the option of specifying whether the
                /// context should follow the core or compatibility profile
                /// of all newer (>= 3.2) OpenGL specifications. For versions
                /// 3.0 and 3.1 there is only the core profile. By default
                /// a compatibility context is created. You only need to specify
                /// the core flag if you want a core profile context to use with
                /// your own OpenGL rendering.
                /// <b>Warning: The graphics module will not function if you
                /// request a core profile context. Make sure the attributes are
                /// set to Default if you want to use the graphics module.</b>
                ///
                /// Setting the debug attribute flag will request a context with
                /// additional debugging features enabled. Depending on the
                /// system, this might be required for advanced OpenGL debugging.
                /// OpenGL debugging is disabled by default.
                ///
                /// <b>Special Note for OS X:</b>
                /// Apple only supports choosing between either a legacy context
                /// (OpenGL 2.1) or a core context (OpenGL version depends on the
                /// operating system version but is at least 3.2). Compatibility
                /// contexts are not supported. Further information is available on the
                /// <a href="https://developer.apple.com/opengl/capabilities/index.html">
                /// OpenGL Capabilities Tables</a> page. OS X also currently does
                /// not support debug contexts.
                ///
                /// Please note that these values are only a hint.
                /// No failure will be reported if one or more of these values
                /// are not supported by the system; instead, SFML will try to
                /// find the closest valid match. You can then retrieve the
                /// settings that the window actually used to create its context,
                /// with Window::getSettings().
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       62          1

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     1.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_iterator_base_types.h:
                // Types used in iterator implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_types.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility types,
                 *  such as iterator_traits and struct iterator.
                 */
                
                #ifndef _STL_ITERATOR_BASE_TYPES_H
                #define _STL_ITERATOR_BASE_TYPES_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>  // For __void_t, is_convertible
                #endif
                
                #if __cplusplus > 201703L && __cpp_concepts >= 201907L
                # include <bits/iterator_concepts.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @defgroup iterators Iterators
                   *  Abstractions for uniform iterating through various underlying types.
                  */
                  ///@{
                
                  /**
                   *  @defgroup iterator_tags Iterator Tags
                   *  These are empty types, used to distinguish different iterators.  The
                   *  distinction is not made by what they contain, but simply by what they
                   *  are.  Different underlying algorithms can then be used based on the
                   *  different operations supported by different iterator types.
                  */
                  ///@{
                  ///  Marking input iterators.
                  struct input_iterator_tag { };
                
                  ///  Marking output iterators.
                  struct output_iterator_tag { };
                
                  /// Forward iterators support a superset of input iterator operations.
                  struct forward_iterator_tag : public input_iterator_tag { };
                
                  /// Bidirectional iterators support a superset of forward iterator
                  /// operations.
                  struct bidirectional_iterator_tag : public forward_iterator_tag { };
                
                  /// Random-access iterators support a superset of bidirectional
                  /// iterator operations.
                  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
                
                #if __cplusplus > 201703L
                  /// Contiguous iterators point to objects stored contiguously in memory.
                  struct contiguous_iterator_tag : public random_access_iterator_tag { };
                #endif
                  ///@}
                
                  /**
                   *  @brief  Common %iterator class.
                   *
                   *  This class does nothing but define nested typedefs.  %Iterator classes
                   *  can inherit from this class to save some work.  The typedefs are then
                   *  used in specializations and overloading.
                   *
                   *  In particular, there are no default implementations of requirements
                   *  such as @c operator++ and the like.  (How could there be?)
                  */
                  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
                           typename _Pointer = _Tp*, typename _Reference = _Tp&>
                    struct iterator
                    {
                      /// One of the @link iterator_tags tag types@endlink.
                      typedef _Category  iterator_category;
                      /// The type "pointed to" by the iterator.
                      typedef _Tp        value_type;
                      /// Distance between iterators is represented as this type.
                      typedef _Distance  difference_type;
                      /// This type represents a pointer-to-value_type.
                      typedef _Pointer   pointer;
                      /// This type represents a reference-to-value_type.
                      typedef _Reference reference;
                    };
                
                  /**
                   *  @brief  Traits class for iterators.
                   *
                   *  This class does nothing but define nested typedefs.  The general
                   *  version simply @a forwards the nested typedefs from the Iterator
                   *  argument.  Specialized versions for pointers and pointers-to-const
                   *  provide tighter, more correct semantics.
                  */
                  template<typename _Iterator>
                    struct iterator_traits;
                
                #if __cplusplus >= 201103L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2408. SFINAE-friendly common_type/iterator_traits is missing in C++14
                  template<typename _Iterator, typename = __void_t<>>
                    struct __iterator_traits { };
                
                #if ! __cpp_lib_concepts
                
                  template<typename _Iterator>
                    struct __iterator_traits<_Iterator,
                			     __void_t<typename _Iterator::iterator_category,
                				      typename _Iterator::value_type,
                				      typename _Iterator::difference_type,
                				      typename _Iterator::pointer,
                				      typename _Iterator::reference>>
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif // ! concepts
                
                  template<typename _Iterator>
                    struct iterator_traits
                    : public __iterator_traits<_Iterator> { };
                
                #else // ! C++11
                  template<typename _Iterator>
                    struct iterator_traits
                    {
                      typedef typename _Iterator::iterator_category iterator_category;
                      typedef typename _Iterator::value_type        value_type;
                      typedef typename _Iterator::difference_type   difference_type;
                      typedef typename _Iterator::pointer           pointer;
                      typedef typename _Iterator::reference         reference;
                    };
                #endif // C++11
                
                #if __cplusplus > 201703L
                  /// Partial specialization for object pointer types.
                  template<typename _Tp>
                #if __cpp_concepts >= 201907L
                    requires is_object_v<_Tp>
                #endif
                    struct iterator_traits<_Tp*>
                    {
                      using iterator_concept  = contiguous_iterator_tag;
                      using iterator_category = random_access_iterator_tag;
                      using value_type	      = remove_cv_t<_Tp>;
                      using difference_type   = ptrdiff_t;
                      using pointer	      = _Tp*;
                      using reference	      = _Tp&;
                    };
                #else
                  /// Partial specialization for pointer types.
                  template<typename _Tp>
                    struct iterator_traits<_Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef _Tp*                        pointer;
                      typedef _Tp&                        reference;
                    };
                
                  /// Partial specialization for const pointer types.
                  template<typename _Tp>
                    struct iterator_traits<const _Tp*>
                    {
                      typedef random_access_iterator_tag iterator_category;
                      typedef _Tp                         value_type;
                      typedef ptrdiff_t                   difference_type;
                      typedef const _Tp*                  pointer;
                      typedef const _Tp&                  reference;
                    };
                #endif
                
                  /**
                   *  This function is not a part of the C++ standard but is syntactic
                   *  sugar for internal library use only.
                  */
                  template<typename _Iter>
                    inline _GLIBCXX_CONSTEXPR
                    typename iterator_traits<_Iter>::iterator_category
        5314 ->     __iterator_category(const _Iter&)
                    { return typename iterator_traits<_Iter>::iterator_category(); }
                
                  ///@}
                
                #if __cplusplus >= 201103L
                  template<typename _Iter>
                    using __iterator_category_t
                      = typename iterator_traits<_Iter>::iterator_category;
                
                  template<typename _InIter>
                    using _RequireInputIter =
                      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
                				   input_iterator_tag>::value>;
                
                  template<typename _It,
                	   typename _Cat = __iterator_category_t<_It>>
                    struct __is_random_access_iter
                      : is_base_of<random_access_iterator_tag, _Cat>
                    {
                      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
                      enum { __value = _Base::value };
                    };
                #else
                  template<typename _It, typename _Traits = iterator_traits<_It>,
                	   typename _Cat = typename _Traits::iterator_category>
                    struct __is_random_access_iter
                    { enum { __value = __is_base_of(random_access_iterator_tag, _Cat) }; };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_TYPES_H */


Top 10 Lines:

     Line      Count

      238       5314

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     5314   Total number of line executions
  5314.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_algo.h:
                // Algorithm implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algo.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGO_H
                #define _STL_ALGO_H 1
                
                #include <cstdlib>	     // for rand
                #include <bits/algorithmfwd.h>
                #include <bits/stl_heap.h>
                #include <bits/stl_tempbuf.h>  // for _Temporary_buffer
                #include <bits/predefined_ops.h>
                
                #if __cplusplus >= 201103L
                #include <bits/uniform_int_dist.h>
                #endif
                
                // See concept_check.h for the __glibcxx_*_requires macros.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
                  template<typename _Iterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
                			   _Iterator __c, _Compare __comp)
                    {
                      if (__comp(__a, __b))
                	{
                	  if (__comp(__b, __c))
                	    std::iter_swap(__result, __b);
                	  else if (__comp(__a, __c))
                	    std::iter_swap(__result, __c);
                	  else
                	    std::iter_swap(__result, __a);
                	}
                      else if (__comp(__a, __c))
                	std::iter_swap(__result, __a);
                      else if (__comp(__b, __c))
                	std::iter_swap(__result, __c);
                      else
                	std::iter_swap(__result, __b);
                    }
                
                  /// Provided for stable_partition to use.
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    __find_if_not(_InputIterator __first, _InputIterator __last,
                		  _Predicate __pred)
                    {
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__negate(__pred),
                			    std::__iterator_category(__first));
                    }
                
                  /// Like find_if_not(), but uses and updates a count of the
                  /// remaining range length instead of comparing against an end
                  /// iterator.
                  template<typename _InputIterator, typename _Predicate, typename _Distance>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
                    {
                      for (; __len; --__len,  (void) ++__first)
                	if (!__pred(__first))
                	  break;
                      return __first;
                    }
                
                  // set_difference
                  // set_intersection
                  // set_symmetric_difference
                  // set_union
                  // for_each
                  // find
                  // find_if
                  // find_first_of
                  // adjacent_find
                  // count
                  // count_if
                  // search
                
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator1
                    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate  __predicate)
                    {
                      // Test for empty ranges
                      if (__first1 == __last1 || __first2 == __last2)
                	return __first1;
                
                      // Test for a pattern of length 1.
                      _ForwardIterator2 __p1(__first2);
                      if (++__p1 == __last2)
                	return std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                      // General case.
                      _ForwardIterator1 __current = __first1;
                
                      for (;;)
                	{
                	  __first1 =
                	    std::__find_if(__first1, __last1,
                		__gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));
                
                	  if (__first1 == __last1)
                	    return __last1;
                
                	  _ForwardIterator2 __p = __p1;
                	  __current = __first1;
                	  if (++__current == __last1)
                	    return __last1;
                
                	  while (__predicate(__current, __p))
                	    {
                	      if (++__p == __last2)
                		return __first1;
                	      if (++__current == __last1)
                		return __last1;
                	    }
                	  ++__first1;
                	}
                      return __first1;
                    }
                
                  // search_n
                
                  /**
                   *  This is an helper function for search_n overloaded for forward iterators.
                  */
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::forward_iterator_tag)
                    {
                      __first = std::__find_if(__first, __last, __unary_pred);
                      while (__first != __last)
                	{
                	  typename iterator_traits<_ForwardIterator>::difference_type
                	    __n = __count;
                	  _ForwardIterator __i = __first;
                	  ++__i;
                	  while (__i != __last && __n != 1 && __unary_pred(__i))
                	    {
                	      ++__i;
                	      --__n;
                	    }
                	  if (__n == 1)
                	    return __first;
                	  if (__i == __last)
                	    return __last;
                	  __first = std::__find_if(++__i, __last, __unary_pred);
                	}
                      return __last;
                    }
                
                  /**
                   *  This is an helper function for search_n overloaded for random access
                   *  iterators.
                  */
                  template<typename _RandomAccessIter, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIter
                    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
                		   _Integer __count, _UnaryPredicate __unary_pred,
                		   std::random_access_iterator_tag)
                    {
                      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
                	_DistanceType;
                
                      _DistanceType __tailSize = __last - __first;
                      _DistanceType __remainder = __count;
                
                      while (__remainder <= __tailSize) // the main loop...
                	{
                	  __first += __remainder;
                	  __tailSize -= __remainder;
                	  // __first here is always pointing to one past the last element of
                	  // next possible match.
                	  _RandomAccessIter __backTrack = __first; 
                	  while (__unary_pred(--__backTrack))
                	    {
                	      if (--__remainder == 0)
                		return (__first - __count); // Success
                	    }
                	  __remainder = __count + 1 - (__first - __backTrack);
                	}
                      return __last; // Failure
                    }
                
                  template<typename _ForwardIterator, typename _Integer,
                	   typename _UnaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __search_n(_ForwardIterator __first, _ForwardIterator __last,
                	       _Integer __count,
                	       _UnaryPredicate __unary_pred)
                    {
                      if (__count <= 0)
                	return __first;
                
                      if (__count == 1)
                	return std::__find_if(__first, __last, __unary_pred);
                
                      return std::__search_n_aux(__first, __last, __count, __unary_pred,
                				 std::__iterator_category(__first));
                    }
                
                  // find_end for forward iterators.
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator1
                    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	       forward_iterator_tag, forward_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      if (__first2 == __last2)
                	return __last1;
                
                      _ForwardIterator1 __result = __last1;
                      while (1)
                	{
                	  _ForwardIterator1 __new_result
                	    = std::__search(__first1, __last1, __first2, __last2, __comp);
                	  if (__new_result == __last1)
                	    return __result;
                	  else
                	    {
                	      __result = __new_result;
                	      __first1 = __new_result;
                	      ++__first1;
                	    }
                	}
                    }
                
                  // find_end for bidirectional iterators (much faster).
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator1
                    __find_end(_BidirectionalIterator1 __first1,
                	       _BidirectionalIterator1 __last1,
                	       _BidirectionalIterator2 __first2,
                	       _BidirectionalIterator2 __last2,
                	       bidirectional_iterator_tag, bidirectional_iterator_tag,
                	       _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator1>)
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator2>)
                
                      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
                      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
                
                      _RevIterator1 __rlast1(__first1);
                      _RevIterator2 __rlast2(__first2);
                      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
                					      _RevIterator2(__last2), __rlast2,
                					      __comp);
                
                      if (__rresult == __rlast1)
                	return __last1;
                      else
                	{
                	  _BidirectionalIterator1 __result = __rresult.base();
                	  std::advance(__result, -std::distance(__first2, __last2));
                	  return __result;
                	}
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @return   The last iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
                   *  @p *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the __first
                   *  element of the sub-sequence, or @p __last1 if the sub-sequence
                   *  is not found.  The sub-sequence will be the last such
                   *  subsequence contained in [__first1,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Find last matching subsequence in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of sequence to match.
                   *  @param  __last2   End of sequence to match.
                   *  @param  __comp    The predicate to use.
                   *  @return The last iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c
                   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
                   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
                   *  exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) using comp as a predicate and returns an
                   *  iterator to the first element of the sub-sequence, or @p __last1
                   *  if the sub-sequence is not found.  The sub-sequence will be the
                   *  last such subsequence contained in [__first,__last1).
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.  This means that the returned
                   *  iterator @c i will be in the range @p
                   *  [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	     _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__find_end(__first1, __last1, __first2, __last2,
                			     std::__iterator_category(__first1),
                			     std::__iterator_category(__first2),
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Checks that a predicate is true for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is true for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == std::find_if_not(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is false for all the elements
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if @p __pred is false for each element in the range
                   *  @p [__first,__last), and false otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
                
                  /**
                   *  @brief  Checks that a predicate is true for at least one element
                   *          of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __pred    A predicate.
                   *  @return  True if the check is true, false otherwise.
                   *
                   *  Returns true if an element exists in the range @p
                   *  [__first,__last) such that @p __pred is true, and false
                   *  otherwise.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    { return !std::none_of(__first, __last, __pred); }
                
                  /**
                   *  @brief  Find the first element in a sequence for which a
                   *          predicate is false.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find_if_not(_InputIterator __first, _InputIterator __last,
                		_Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if_not(__first, __last,
                				__gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Checks whether the sequence is partitioned.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
                   *  i.e. if all elements that satisfy @p __pred appear before those that
                   *  do not.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_partitioned(_InputIterator __first, _InputIterator __last,
                		   _Predicate __pred)
                    {
                      __first = std::find_if_not(__first, __last, __pred);
                      if (__first == __last)
                	return true;
                      ++__first;
                      return std::none_of(__first, __last, __pred);
                    }
                
                  /**
                   *  @brief  Find the partition point of a partitioned range.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __pred    A predicate.
                   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
                   *           and @p none_of(mid, __last, __pred) are both true.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    partition_point(_ForwardIterator __first, _ForwardIterator __last,
                		    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_ForwardIterator>::value_type>)
                
                      // A specific debug-mode test will be necessary...
                      __glibcxx_requires_valid_range(__first, __last);
                
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__pred(*__middle))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                #endif
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __remove_copy_if(_InputIterator __first, _InputIterator __last,
                		     _OutputIterator __result, _Predicate __pred)
                    {
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements of a given value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __value   The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) not equal
                   *  to @p __value to the range beginning at @p __result.
                   *  remove_copy() is stable, so the relative order of elements that
                   *  are copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    remove_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                	__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing elements for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns false to the range beginning at @p __result.
                   *
                   *  remove_copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    remove_copy_if(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_copy_if(__first, __last, __result,
                				   __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Copy the elements of a sequence for which a predicate is true.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p __result.
                   *
                   *  copy_if() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    copy_if(_InputIterator __first, _InputIterator __last,
                	    _OutputIterator __result, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__result = *__first;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __copy_n(_InputIterator __first, _Size __n,
                	     _OutputIterator __result, input_iterator_tag)
                    {
                      return std::__niter_wrap(__result,
                			       __copy_n_a(__first, __n,
                					  std::__niter_base(__result), true));
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __copy_n(_RandomAccessIterator __first, _Size __n,
                	     _OutputIterator __result, random_access_iterator_tag)
                    { return std::copy(__first, __first + __n, __result); }
                
                  /**
                   *  @brief Copies the range [first,first+n) into [result,result+n).
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  result+n.
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                  */
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                
                      const auto __n2 = std::__size_to_integer(__n);
                      if (__n2 <= 0)
                	return __result;
                
                      __glibcxx_requires_can_increment(__first, __n2);
                      __glibcxx_requires_can_increment(__result, __n2);
                
                      return std::__copy_n(__first, __n2, __result,
                			   std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy the elements of a sequence to separate output sequences
                   *         depending on the truth value of a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __out_true   An output iterator.
                   *  @param  __out_false  An output iterator.
                   *  @param  __pred    A predicate.
                   *  @return   A pair designating the ends of the resulting sequences.
                   *
                   *  Copies each element in the range @p [__first,__last) for which
                   *  @p __pred returns true to the range beginning at @p out_true
                   *  and each element for which @p __pred returns false to @p __out_false.
                  */
                  template<typename _InputIterator, typename _OutputIterator1,
                	   typename _OutputIterator2, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_OutputIterator1, _OutputIterator2>
                    partition_copy(_InputIterator __first, _InputIterator __last,
                		   _OutputIterator1 __out_true, _OutputIterator2 __out_false,
                		   _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  {
                	    *__out_true = *__first;
                	    ++__out_true;
                	  }
                	else
                	  {
                	    *__out_false = *__first;
                	    ++__out_false;
                	  }
                
                      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
                    }
                #endif // C++11
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
         750 ->     __remove_if(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred)
                    {
                      __first = std::__find_if(__first, __last, __pred);
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      ++__first;
                      for (; __first != __last; ++__first)
                	if (!__pred(__first))
                	  {
                	    *__result = _GLIBCXX_MOVE(*__first);
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Remove elements from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be removed.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements equal to @p __value are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
         750 ->     remove(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                		__gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Remove elements from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __pred   A predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  All elements for which @p __pred returns true are removed from the range
                   *  @p [__first,__last).
                   *
                   *  remove_if() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    remove_if(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__remove_if(__first, __last,
                			      __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		    _BinaryPredicate __binary_pred)
                    {
                      if (__first == __last)
                	return __last;
                      _ForwardIterator __next = __first;
                      while (++__next != __last)
                	{
                	  if (__binary_pred(__first, __next))
                	    return __first;
                	  __first = __next;
                	}
                      return __last;
                    }
                
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __unique(_ForwardIterator __first, _ForwardIterator __last,
                	     _BinaryPredicate __binary_pred)
                    {
                      // Skip the beginning, if already unique.
                      __first = std::__adjacent_find(__first, __last, __binary_pred);
                      if (__first == __last)
                	return __last;
                
                      // Do the real copy work.
                      _ForwardIterator __dest = __first;
                      ++__first;
                      while (++__first != __last)
                	if (!__binary_pred(__dest, __first))
                	  *++__dest = _GLIBCXX_MOVE(*__first);
                      return ++__dest;
                    }
                
                  /**
                   *  @brief Remove consecutive duplicate values from a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values that compare equal.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                		     typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Remove consecutive values from a sequence using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Removes all but the first element from each group of consecutive
                   *  values for which @p __binary_pred returns true.
                   *  unique() is stable, so the relative order of elements that are
                   *  not removed is unchanged.
                   *  Elements between the end of the resulting sequence and @p __last
                   *  are still present, but their value is unspecified.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    unique(_ForwardIterator __first, _ForwardIterator __last,
                	   _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                		typename iterator_traits<_ForwardIterator>::value_type,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__unique(__first, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for forward iterators and output iterator as result.
                  */
                  template<typename _ForwardIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  forward_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_ForwardIterator>::value_type>)
                
                      _ForwardIterator __next = __first;
                      *__result = *__first;
                      while (++__next != __last)
                	if (!__binary_pred(__first, __next))
                	  {
                	    __first = __next;
                	    *++__result = *__first;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and output iterator as result.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _OutputIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, output_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_InputIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                
                      typename iterator_traits<_InputIterator>::value_type __value = *__first;
                      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
                	__rebound_pred
                	= __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
                      *__result = __value;
                      while (++__first != __last)
                	if (!__rebound_pred(__first, __value))
                	  {
                	    __value = *__first;
                	    *++__result = __value;
                	  }
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified
                   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
                   *              _BinaryPredicate)
                   *  overloaded for input iterators and forward iterator as result.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __unique_copy(_InputIterator __first, _InputIterator __last,
                		  _ForwardIterator __result, _BinaryPredicate __binary_pred,
                		  input_iterator_tag, forward_iterator_tag)
                    {
                      // concept requirements -- iterators already checked
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	  typename iterator_traits<_ForwardIterator>::value_type,
                	  typename iterator_traits<_InputIterator>::value_type>)
                      *__result = *__first;
                      while (++__first != __last)
                	if (!__binary_pred(__result, __first))
                	  *++__result = *__first;
                      return ++__result;
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for bidirectional iterators.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      while (true)
                	if (__first == __last || __first == --__last)
                	  return;
                	else
                	  {
                	    std::iter_swap(__first, __last);
                	    ++__first;
                	  }
                    }
                
                  /**
                   *  This is an uglified reverse(_BidirectionalIterator,
                   *                              _BidirectionalIterator)
                   *  overloaded for random access iterators.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    void
       ##### ->     __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      random_access_iterator_tag)
                    {
                      if (__first == __last)
                	return;
                      --__last;
                      while (__first < __last)
                	{
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	  --__last;
                	}
                    }
                
                  /**
                   *  @brief Reverse a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @return   reverse() returns no value.
                   *
                   *  Reverses the order of the elements in the range @p [__first,__last),
                   *  so that the first element becomes the last etc.
                   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
                   *  swaps @p *(__first+i) and @p *(__last-(i+1))
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
       ##### ->     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      std::__reverse(__first, __last, std::__iterator_category(__first));
                    }
                
                  /**
                   *  @brief Copy a sequence, reversing its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A bidirectional iterator.
                   *  @param  __last    A bidirectional iterator.
                   *  @param  __result  An output iterator.
                   *  @return  An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements in the range @p [__first,__last) to the
                   *  range @p [__result,__result+(__last-__first)) such that the
                   *  order of the elements is reversed.  For every @c i such that @p
                   *  0<=i<=(__last-__first), @p reverse_copy() performs the
                   *  assignment @p *(__result+(__last-__first)-1-i) = *(__first+i).
                   *  The ranges @p [__first,__last) and @p
                   *  [__result,__result+(__last-__first)) must not overlap.
                  */
                  template<typename _BidirectionalIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		 _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      while (__first != __last)
                	{
                	  --__last;
                	  *__result = *__last;
                	  ++__result;
                	}
                      return __result;
                    }
                
                  /**
                   *  This is a helper function for the rotate algorithm specialized on RAIs.
                   *  It returns the greatest common divisor of two integer values.
                  */
                  template<typename _EuclideanRingElement>
                    _GLIBCXX20_CONSTEXPR
                    _EuclideanRingElement
                    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
                    {
                      while (__n != 0)
                	{
                	  _EuclideanRingElement __t = __m % __n;
                	  __m = __n;
                	  __n = __t;
                	}
                      return __m;
                    }
                
                  inline namespace _V2
                  {
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __rotate(_ForwardIterator __first,
                	     _ForwardIterator __middle,
                	     _ForwardIterator __last,
                	     forward_iterator_tag)
                    {
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      _ForwardIterator __first2 = __middle;
                      do
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	}
                      while (__first2 != __last);
                
                      _ForwardIterator __ret = __first;
                
                      __first2 = __middle;
                
                      while (__first2 != __last)
                	{
                	  std::iter_swap(__first, __first2);
                	  ++__first;
                	  ++__first2;
                	  if (__first == __middle)
                	    __middle = __first2;
                	  else if (__first2 == __last)
                	    __first2 = __middle;
                	}
                      return __ret;
                    }
                
                   /// This is a helper function for the rotate algorithm.
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator
                    __rotate(_BidirectionalIterator __first,
                	     _BidirectionalIterator __middle,
                	     _BidirectionalIterator __last,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                      std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                
                      while (__first != __middle && __middle != __last)
                	{
                	  std::iter_swap(__first, --__last);
                	  ++__first;
                	}
                
                      if (__first == __middle)
                	{
                	  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
                	  return __last;
                	}
                      else
                	{
                	  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
                	  return __first;
                	}
                    }
                
                  /// This is a helper function for the rotate algorithm.
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __rotate(_RandomAccessIterator __first,
                	     _RandomAccessIterator __middle,
                	     _RandomAccessIterator __last,
                	     random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                
                      if (__first == __middle)
                	return __last;
                      else if (__last == __middle)
                	return __first;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                
                      _Distance __n = __last   - __first;
                      _Distance __k = __middle - __first;
                
                      if (__k == __n - __k)
                	{
                	  std::swap_ranges(__first, __middle, __middle);
                	  return __middle;
                	}
                
                      _RandomAccessIterator __p = __first;
                      _RandomAccessIterator __ret = __first + (__last - __middle);
                
                      for (;;)
                	{
                	  if (__k < __n - __k)
                	    {
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*__p);
                		  _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
                		  *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  std::iter_swap(__p, __q);
                		  ++__p;
                		  ++__q;
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	      __k = __n - __k;
                	    }
                	  else
                	    {
                	      __k = __n - __k;
                	      if (__is_pod(_ValueType) && __k == 1)
                		{
                		  _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
                		  _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
                		  *__p = _GLIBCXX_MOVE(__t);
                		  return __ret;
                		}
                	      _RandomAccessIterator __q = __p + __n;
                	      __p = __q - __k;
                	      for (_Distance __i = 0; __i < __n - __k; ++ __i)
                		{
                		  --__p;
                		  --__q;
                		  std::iter_swap(__p, __q);
                		}
                	      __n %= __k;
                	      if (__n == 0)
                		return __ret;
                	      std::swap(__n, __k);
                	    }
                	}
                    }
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 488. rotate throws away useful information
                  /**
                   *  @brief Rotate the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  first + (last - middle).
                   *
                   *  Rotates the elements of the range @p [__first,__last) by 
                   *  @p (__middle - __first) positions so that the element at @p __middle
                   *  is moved to @p __first, the element at @p __middle+1 is moved to
                   *  @p __first+1 and so on for each element in the range
                   *  @p [__first,__last).
                   *
                   *  This effectively swaps the ranges @p [__first,__middle) and
                   *  @p [__middle,__last).
                   *
                   *  Performs
                   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    rotate(_ForwardIterator __first, _ForwardIterator __middle,
                	   _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::__rotate(__first, __middle, __last,
                			   std::__iterator_category(__first));
                    }
                
                  } // namespace _V2
                
                  /**
                   *  @brief Copy a sequence, rotating its elements.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __middle  A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies the elements of the range @p [__first,__last) to the
                   *  range beginning at @result, rotating the copied elements by 
                   *  @p (__middle-__first) positions so that the element at @p __middle
                   *  is moved to @p __result, the element at @p __middle+1 is moved
                   *  to @p __result+1 and so on for each element in the range @p
                   *  [__first,__last).
                   *
                   *  Performs 
                   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
                   *  for each @p n in the range @p [0,__last-__first).
                  */
                  template<typename _ForwardIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                		_ForwardIterator __last, _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                		typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                
                      return std::copy(__first, __middle,
                		       std::copy(__middle, __last, __result));
                    }
                
                  /// This is a helper function...
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __partition(_ForwardIterator __first, _ForwardIterator __last,
                		_Predicate __pred, forward_iterator_tag)
                    {
                      if (__first == __last)
                	return __first;
                
                      while (__pred(*__first))
                	if (++__first == __last)
                	  return __first;
                
                      _ForwardIterator __next = __first;
                
                      while (++__next != __last)
                	if (__pred(*__next))
                	  {
                	    std::iter_swap(__first, __next);
                	    ++__first;
                	  }
                
                      return __first;
                    }
                
                  /// This is a helper function...
                  template<typename _BidirectionalIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _BidirectionalIterator
                    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
                		_Predicate __pred, bidirectional_iterator_tag)
                    {
                      while (true)
                	{
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (__pred(*__first))
                	      ++__first;
                	    else
                	      break;
                	  --__last;
                	  while (true)
                	    if (__first == __last)
                	      return __first;
                	    else if (!bool(__pred(*__last)))
                	      --__last;
                	    else
                	      break;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  // partition
                
                  /// This is a helper function...
                  /// Requires __first != __last and !__pred(__first)
                  /// and __len == distance(__first, __last).
                  ///
                  /// !__pred(__first) allows us to guarantee that we don't
                  /// move-assign an element onto itself.
                  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
                	   typename _Distance>
                    _ForwardIterator
                    __stable_partition_adaptive(_ForwardIterator __first,
                				_ForwardIterator __last,
                				_Predicate __pred, _Distance __len,
                				_Pointer __buffer,
                				_Distance __buffer_size)
                    {
                      if (__len == 1)
                	return __first;
                
                      if (__len <= __buffer_size)
                	{
                	  _ForwardIterator __result1 = __first;
                	  _Pointer __result2 = __buffer;
                
                	  // The precondition guarantees that !__pred(__first), so
                	  // move that element to the buffer before starting the loop.
                	  // This ensures that we only call __pred once per element.
                	  *__result2 = _GLIBCXX_MOVE(*__first);
                	  ++__result2;
                	  ++__first;
                	  for (; __first != __last; ++__first)
                	    if (__pred(__first))
                	      {
                		*__result1 = _GLIBCXX_MOVE(*__first);
                		++__result1;
                	      }
                	    else
                	      {
                		*__result2 = _GLIBCXX_MOVE(*__first);
                		++__result2;
                	      }
                
                	  _GLIBCXX_MOVE3(__buffer, __result2, __result1);
                	  return __result1;
                	}
                
                      _ForwardIterator __middle = __first;
                      std::advance(__middle, __len / 2);
                      _ForwardIterator __left_split =
                	std::__stable_partition_adaptive(__first, __middle, __pred,
                					 __len / 2, __buffer,
                					 __buffer_size);
                
                      // Advance past true-predicate values to satisfy this
                      // function's preconditions.
                      _Distance __right_len = __len - __len / 2;
                      _ForwardIterator __right_split =
                	std::__find_if_not_n(__middle, __right_len, __pred);
                
                      if (__right_len)
                	__right_split =
                	  std::__stable_partition_adaptive(__right_split, __last, __pred,
                					   __right_len,
                					   __buffer, __buffer_size);
                
                      return std::rotate(__left_split, __middle, __right_split);
                    }
                
                  template<typename _ForwardIterator, typename _Predicate>
                    _ForwardIterator
                    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		       _Predicate __pred)
                    {
                      __first = std::__find_if_not(__first, __last, __pred);
                
                      if (__first == __last)
                	return __first;
                
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _Temporary_buffer<_ForwardIterator, _ValueType>
                	__buf(__first, std::distance(__first, __last));
                      return
                	std::__stable_partition_adaptive(__first, __last, __pred,
                					 _DistanceType(__buf.requested_size()),
                					 __buf.begin(),
                					 _DistanceType(__buf.size()));
                    }
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence, preserving relative ordering.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [first,middle) and false for each @p i
                   *  in the range @p [middle,last).
                   *
                   *  Performs the same function as @p partition() with the additional
                   *  guarantee that the relative ordering of elements in each group is
                   *  preserved, so any two elements @p x and @p y in the range
                   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
                   *  relative ordering after calling @p stable_partition().
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    inline _ForwardIterator
                    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                		     _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__stable_partition(__first, __last,
                				     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /// This is a helper function for the sort routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __heap_select(_RandomAccessIterator __first,
                		  _RandomAccessIterator __middle,
                		  _RandomAccessIterator __last, _Compare __comp)
                    {
                      std::__make_heap(__first, __middle, __comp);
                      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
                	if (__comp(__i, __first))
                	  std::__pop_heap(__first, __middle, __i, __comp);
                    }
                
                  // partial_sort
                
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
                			_RandomAccessIterator __result_first,
                			_RandomAccessIterator __result_last,
                			_Compare __comp)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
                      typedef typename _RItTraits::difference_type _DistanceType;
                
                      if (__result_first == __result_last)
                	return __result_last;
                      _RandomAccessIterator __result_real_last = __result_first;
                      while (__first != __last && __result_real_last != __result_last)
                	{
                	  *__result_real_last = *__first;
                	  ++__result_real_last;
                	  ++__first;
                	}
                      
                      std::__make_heap(__result_first, __result_real_last, __comp);
                      while (__first != __last)
                	{
                	  if (__comp(__first, __result_first))
                	    std::__adjust_heap(__result_first, _DistanceType(0),
                			       _DistanceType(__result_real_last
                					     - __result_first),
                			       _InputValueType(*__first), __comp);
                	  ++__first;
                	}
                      std::__sort_heap(__result_first, __result_real_last, __comp);
                      return __result_real_last;
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p __result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  *j<*i is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_LessThanOpConcept<_InputValueType,
                						     _OutputValueType>)
                      __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				      __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Copy the smallest elements of a sequence using a predicate for
                   *         comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    Another input iterator.
                   *  @param  __result_first   A random-access iterator.
                   *  @param  __result_last    Another random-access iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return   An iterator indicating the end of the resulting sequence.
                   *
                   *  Copies and sorts the smallest N values from the range @p [__first,__last)
                   *  to the range beginning at @p result_first, where the number of
                   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
                   *  @p (__result_last-__result_first).
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__result_first,__result_first+N) such that i precedes j then
                   *  @p __comp(*j,*i) is false.
                   *  The value returned is @p __result_first+N.
                  */
                  template<typename _InputIterator, typename _RandomAccessIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
                    partial_sort_copy(_InputIterator __first, _InputIterator __last,
                		      _RandomAccessIterator __result_first,
                		      _RandomAccessIterator __result_last,
                		      _Compare __comp)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_InputValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_OutputValueType;
                #endif
                
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_InputValueType,
                				  _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _InputValueType, _OutputValueType>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                				  _OutputValueType, _OutputValueType>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                      __glibcxx_requires_valid_range(__result_first, __result_last);
                
                      return std::__partial_sort_copy(__first, __last,
                				      __result_first, __result_last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __unguarded_linear_insert(_RandomAccessIterator __last,
                			      _Compare __comp)
                    {
                      typename iterator_traits<_RandomAccessIterator>::value_type
                	__val = _GLIBCXX_MOVE(*__last);
                      _RandomAccessIterator __next = __last;
                      --__next;
                      while (__comp(__val, __next))
                	{
                	  *__last = _GLIBCXX_MOVE(*__next);
                	  __last = __next;
                	  --__next;
                	}
                      *__last = _GLIBCXX_MOVE(__val);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __insertion_sort(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__first == __last) return;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  if (__comp(__i, __first))
                	    {
                	      typename iterator_traits<_RandomAccessIterator>::value_type
                		__val = _GLIBCXX_MOVE(*__i);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
                	      *__first = _GLIBCXX_MOVE(__val);
                	    }
                	  else
                	    std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                	}
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __unguarded_insertion_sort(_RandomAccessIterator __first,
                			       _RandomAccessIterator __last, _Compare __comp)
                    {
                      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
                	std::__unguarded_linear_insert(__i,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @doctodo
                   *  This controls some aspect of the sort routines.
                  */
                  enum { _S_threshold = 16 };
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __final_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first > int(_S_threshold))
                	{
                	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
                	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
                					  __comp);
                	}
                      else
                	std::__insertion_sort(__first, __last, __comp);
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
                    __unguarded_partition(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last,
                			  _RandomAccessIterator __pivot, _Compare __comp)
                    {
                      while (true)
                	{
                	  while (__comp(__first, __pivot))
                	    ++__first;
                	  --__last;
                	  while (__comp(__pivot, __last))
                	    --__last;
                	  if (!(__first < __last))
                	    return __first;
                	  std::iter_swap(__first, __last);
                	  ++__first;
                	}
                    }
                
                  /// This is a helper function...
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _RandomAccessIterator
                    __unguarded_partition_pivot(_RandomAccessIterator __first,
                				_RandomAccessIterator __last, _Compare __comp)
                    {
                      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
                      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
                				  __comp);
                      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __partial_sort(_RandomAccessIterator __first,
                		   _RandomAccessIterator __middle,
                		   _RandomAccessIterator __last,
                		   _Compare __comp)
                    {
                      std::__heap_select(__first, __middle, __last, __comp);
                      std::__sort_heap(__first, __middle, __comp);
                    }
                
                  /// This is a helper function for the sort routine.
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __introsort_loop(_RandomAccessIterator __first,
                		     _RandomAccessIterator __last,
                		     _Size __depth_limit, _Compare __comp)
                    {
                      while (__last - __first > int(_S_threshold))
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__partial_sort(__first, __last, __last, __comp);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
                	  __last = __cut;
                	}
                    }
                
                  // sort
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	   _Compare __comp)
                    {
                      if (__first != __last)
                	{
                	  std::__introsort_loop(__first, __last,
                				std::__lg(__last - __first) * 2,
                				__comp);
                	  std::__final_insertion_sort(__first, __last, __comp);
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		  _RandomAccessIterator __last, _Size __depth_limit,
                		  _Compare __comp)
                    {
                      while (__last - __first > 3)
                	{
                	  if (__depth_limit == 0)
                	    {
                	      std::__heap_select(__first, __nth + 1, __last, __comp);
                	      // Place the nth largest element in its final position.
                	      std::iter_swap(__first, __nth);
                	      return;
                	    }
                	  --__depth_limit;
                	  _RandomAccessIterator __cut =
                	    std::__unguarded_partition_pivot(__first, __last, __comp);
                	  if (__cut <= __nth)
                	    __first = __cut;
                	  else
                	    __last = __cut;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  // nth_element
                
                  // lower_bound moved to stl_algobase.h
                
                  /**
                   *  @brief Finds the first position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return An iterator pointing to the first element <em>not less
                   *           than</em> @p __val, or end() if every element is less
                   *           than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the last position in which @p __val could be inserted
                   *         without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An iterator pointing to the first element greater than @p __val,
                   *           or end() if no elements are greater than @p __val.
                   *  @ingroup binary_search_algorithms
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__upper_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Tp,
                	   typename _CompareItTp, typename _CompareTpIt>
                    _GLIBCXX20_CONSTEXPR
                    pair<_ForwardIterator, _ForwardIterator>
                    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val,
                		  _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp_it_val(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else if (__comp_val_it(__val, __middle))
                	    __len = __half;
                	  else
                	    {
                	      _ForwardIterator __left
                		= std::__lower_bound(__first, __middle, __val, __comp_it_val);
                	      std::advance(__first, __len);
                	      _ForwardIterator __right
                		= std::__upper_bound(++__middle, __first, __val, __comp_val_it);
                	      return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
                	    }
                	}
                      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val),
                   *                   upper_bound(__first, __last, __val))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val(),
                				__gnu_cxx::__ops::__val_less_iter());
                    }
                
                  /**
                   *  @brief Finds the largest subrange in which @p __val could be inserted
                   *         at any place in it without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  An pair of iterators defining the subrange.
                   *  @ingroup binary_search_algorithms
                   *
                   *  This is equivalent to
                   *  @code
                   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
                   *                   upper_bound(__first, __last, __val, __comp))
                   *  @endcode
                   *  but does not actually call those functions.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    equal_range(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      return std::__equal_range(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_comp_val(__comp),
                				__gnu_cxx::__ops::__val_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return True if @p __val (or its equivalent) is in [@p
                   *  __first,@p __last ].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                      __glibcxx_requires_partitioned_upper(__first, __last, __val);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_less_val());
                      return __i != __last && !(__val < *__i);
                    }
                
                  /**
                   *  @brief Determines whether an element exists in a range.
                   *  @ingroup binary_search_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
                   *
                   *  Note that this does not actually return an iterator to @p __val.  For
                   *  that, use std::find or a container's specialized find member functions.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_partitioned_lower_pred(__first, __last,
                						__val, __comp);
                      __glibcxx_requires_partitioned_upper_pred(__first, __last,
                						__val, __comp);
                
                      _ForwardIterator __i
                	= std::__lower_bound(__first, __last, __val,
                			     __gnu_cxx::__ops::__iter_comp_val(__comp));
                      return __i != __last && !bool(__comp(__val, *__i));
                    }
                
                  // merge
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    void
                    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
                			  _InputIterator2 __first2, _InputIterator2 __last2,
                			  _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      if (__first1 != __last1)
                	_GLIBCXX_MOVE3(__first1, __last1, __result);
                    }
                
                  /// This is a helper function for the __merge_adaptive routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _BidirectionalIterator3, typename _Compare>
                    void
                    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
                				   _BidirectionalIterator1 __last1,
                				   _BidirectionalIterator2 __first2,
                				   _BidirectionalIterator2 __last2,
                				   _BidirectionalIterator3 __result,
                				   _Compare __comp)
                    {
                      if (__first1 == __last1)
                	{
                	  _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
                	  return;
                	}
                      else if (__first2 == __last2)
                	return;
                
                      --__last1;
                      --__last2;
                      while (true)
                	{
                	  if (__comp(__last2, __last1))
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last1);
                	      if (__first1 == __last1)
                		{
                		  _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
                		  return;
                		}
                	      --__last1;
                	    }
                	  else
                	    {
                	      *--__result = _GLIBCXX_MOVE(*__last2);
                	      if (__first2 == __last2)
                		return;
                	      --__last2;
                	    }
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
                	   typename _Distance>
                    _BidirectionalIterator1
                    __rotate_adaptive(_BidirectionalIterator1 __first,
                		      _BidirectionalIterator1 __middle,
                		      _BidirectionalIterator1 __last,
                		      _Distance __len1, _Distance __len2,
                		      _BidirectionalIterator2 __buffer,
                		      _Distance __buffer_size)
                    {
                      _BidirectionalIterator2 __buffer_end;
                      if (__len1 > __len2 && __len2 <= __buffer_size)
                	{
                	  if (__len2)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	      _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
                	      return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
                	    }
                	  else
                	    return __first;
                	}
                      else if (__len1 <= __buffer_size)
                	{
                	  if (__len1)
                	    {
                	      __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	      _GLIBCXX_MOVE3(__middle, __last, __first);
                	      return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
                	    }
                	  else
                	    return __last;
                	}
                      else
                	return std::rotate(__first, __middle, __last);
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance, 
                	   typename _Pointer, typename _Compare>
                    void
                    __merge_adaptive(_BidirectionalIterator __first,
                		     _BidirectionalIterator __middle,
                		     _BidirectionalIterator __last,
                		     _Distance __len1, _Distance __len2,
                		     _Pointer __buffer, _Distance __buffer_size,
                		     _Compare __comp)
                    {
                      if (__len1 <= __len2 && __len1 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
                	  std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
                				     __first, __comp);
                	}
                      else if (__len2 <= __buffer_size)
                	{
                	  _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
                	  std::__move_merge_adaptive_backward(__first, __middle, __buffer,
                					      __buffer_end, __last, __comp);
                	}
                      else
                	{
                	  _BidirectionalIterator __first_cut = __first;
                	  _BidirectionalIterator __second_cut = __middle;
                	  _Distance __len11 = 0;
                	  _Distance __len22 = 0;
                	  if (__len1 > __len2)
                	    {
                	      __len11 = __len1 / 2;
                	      std::advance(__first_cut, __len11);
                	      __second_cut
                		= std::__lower_bound(__middle, __last, *__first_cut,
                				     __gnu_cxx::__ops::__iter_comp_val(__comp));
                	      __len22 = std::distance(__middle, __second_cut);
                	    }
                	  else
                	    {
                	      __len22 = __len2 / 2;
                	      std::advance(__second_cut, __len22);
                	      __first_cut
                		= std::__upper_bound(__first, __middle, *__second_cut,
                				     __gnu_cxx::__ops::__val_comp_iter(__comp));
                	      __len11 = std::distance(__first, __first_cut);
                	    }
                
                	  _BidirectionalIterator __new_middle
                	    = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
                				     __len1 - __len11, __len22, __buffer,
                				     __buffer_size);
                	  std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
                				__len22, __buffer, __buffer_size, __comp);
                	  std::__merge_adaptive(__new_middle, __second_cut, __last,
                				__len1 - __len11,
                				__len2 - __len22, __buffer,
                				__buffer_size, __comp);
                	}
                    }
                
                  /// This is a helper function for the merge routines.
                  template<typename _BidirectionalIterator, typename _Distance,
                	   typename _Compare>
                    void
                    __merge_without_buffer(_BidirectionalIterator __first,
                			   _BidirectionalIterator __middle,
                			   _BidirectionalIterator __last,
                			   _Distance __len1, _Distance __len2,
                			   _Compare __comp)
                    {
                      if (__len1 == 0 || __len2 == 0)
                	return;
                
                      if (__len1 + __len2 == 2)
                	{
                	  if (__comp(__middle, __first))
                	    std::iter_swap(__first, __middle);
                	  return;
                	}
                
                      _BidirectionalIterator __first_cut = __first;
                      _BidirectionalIterator __second_cut = __middle;
                      _Distance __len11 = 0;
                      _Distance __len22 = 0;
                      if (__len1 > __len2)
                	{
                	  __len11 = __len1 / 2;
                	  std::advance(__first_cut, __len11);
                	  __second_cut
                	    = std::__lower_bound(__middle, __last, *__first_cut,
                				 __gnu_cxx::__ops::__iter_comp_val(__comp));
                	  __len22 = std::distance(__middle, __second_cut);
                	}
                      else
                	{
                	  __len22 = __len2 / 2;
                	  std::advance(__second_cut, __len22);
                	  __first_cut
                	    = std::__upper_bound(__first, __middle, *__second_cut,
                				 __gnu_cxx::__ops::__val_comp_iter(__comp));
                	  __len11 = std::distance(__first, __first_cut);
                	}
                
                      _BidirectionalIterator __new_middle
                	= std::rotate(__first_cut, __middle, __second_cut);
                      std::__merge_without_buffer(__first, __first_cut, __new_middle,
                				  __len11, __len22, __comp);
                      std::__merge_without_buffer(__new_middle, __second_cut, __last,
                				  __len1 - __len11, __len2 - __len22, __comp);
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    void
                    __inplace_merge(_BidirectionalIterator __first,
                		    _BidirectionalIterator __middle,
                		    _BidirectionalIterator __last,
                		    _Compare __comp)
                    {
                      typedef typename iterator_traits<_BidirectionalIterator>::value_type
                	  _ValueType;
                      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
                	  _DistanceType;
                      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
                
                      if (__first == __middle || __middle == __last)
                	return;
                
                      const _DistanceType __len1 = std::distance(__first, __middle);
                      const _DistanceType __len2 = std::distance(__middle, __last);
                
                      // __merge_adaptive will use a buffer for the smaller of
                      // [first,middle) and [middle,last).
                      _TmpBuf __buf(__first, std::min(__len1, __len2));
                
                      if (__buf.begin() == 0)
                	std::__merge_without_buffer
                	  (__first, __middle, __last, __len1, __len2, __comp);
                      else
                	std::__merge_adaptive
                	  (__first, __middle, __last, __len1, __len2, __buf.begin(),
                	   _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [__middle,__last), and puts the result in [__first,__last).  The
                   *  output will be sorted.  The sort is @e stable, that is, for
                   *  equivalent elements in the two ranges, elements from the first
                   *  range will always come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                  */
                  template<typename _BidirectionalIterator>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted(__first, __middle);
                      __glibcxx_requires_sorted(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges in place.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return  Nothing.
                   *
                   *  Merges two sorted and consecutive ranges, [__first,__middle) and
                   *  [middle,last), and puts the result in [__first,__last).  The output will
                   *  be sorted.  The sort is @e stable, that is, for equivalent
                   *  elements in the two ranges, elements from the first range will always
                   *  come before elements from the second.
                   *
                   *  If enough additional memory is available, this takes (__last-__first)-1
                   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
                   *  distance(__first,__last).
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    inline void
                    inplace_merge(_BidirectionalIterator __first,
                		  _BidirectionalIterator __middle,
                		  _BidirectionalIterator __last,
                		  _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
                	    _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_sorted_pred(__first, __middle, __comp);
                      __glibcxx_requires_sorted_pred(__middle, __last, __comp);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__inplace_merge(__first, __middle, __last,
                			   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                
                  /// This is a helper function for the __merge_sort_loop routines.
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Compare>
                    _OutputIterator
                    __move_merge(_InputIterator __first1, _InputIterator __last1,
                		 _InputIterator __first2, _InputIterator __last2,
                		 _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first2);
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = _GLIBCXX_MOVE(*__first1);
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return _GLIBCXX_MOVE3(__first2, __last2,
                			    _GLIBCXX_MOVE3(__first1, __last1,
                					   __result));
                    }
                
                  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
                	   typename _Distance, typename _Compare>
                    void
                    __merge_sort_loop(_RandomAccessIterator1 __first,
                		      _RandomAccessIterator1 __last,
                		      _RandomAccessIterator2 __result, _Distance __step_size,
                		      _Compare __comp)
                    {
                      const _Distance __two_step = 2 * __step_size;
                
                      while (__last - __first >= __two_step)
                	{
                	  __result = std::__move_merge(__first, __first + __step_size,
                				       __first + __step_size,
                				       __first + __two_step,
                				       __result, __comp);
                	  __first += __two_step;
                	}
                      __step_size = std::min(_Distance(__last - __first), __step_size);
                
                      std::__move_merge(__first, __first + __step_size,
                			__first + __step_size, __last, __result, __comp);
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    void
                    __chunk_insertion_sort(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Distance __chunk_size, _Compare __comp)
                    {
                      while (__last - __first >= __chunk_size)
                	{
                	  std::__insertion_sort(__first, __first + __chunk_size, __comp);
                	  __first += __chunk_size;
                	}
                      std::__insertion_sort(__first, __last, __comp);
                    }
                
                  enum { _S_chunk_size = 7 };
                
                  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
                    void
                    __merge_sort_with_buffer(_RandomAccessIterator __first,
                			     _RandomAccessIterator __last,
                			     _Pointer __buffer, _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_Distance;
                
                      const _Distance __len = __last - __first;
                      const _Pointer __buffer_last = __buffer + __len;
                
                      _Distance __step_size = _S_chunk_size;
                      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
                
                      while (__step_size < __len)
                	{
                	  std::__merge_sort_loop(__first, __last, __buffer,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	  std::__merge_sort_loop(__buffer, __buffer_last, __first,
                				 __step_size, __comp);
                	  __step_size *= 2;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Pointer,
                	   typename _Distance, typename _Compare>
                    void
                    __stable_sort_adaptive(_RandomAccessIterator __first,
                			   _RandomAccessIterator __last,
                			   _Pointer __buffer, _Distance __buffer_size,
                			   _Compare __comp)
                    {
                      const _Distance __len = (__last - __first + 1) / 2;
                      const _RandomAccessIterator __middle = __first + __len;
                      if (__len > __buffer_size)
                	{
                	  std::__stable_sort_adaptive(__first, __middle, __buffer,
                				      __buffer_size, __comp);
                	  std::__stable_sort_adaptive(__middle, __last, __buffer,
                				      __buffer_size, __comp);
                	}
                      else
                	{
                	  std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
                	  std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
                	}
                
                      std::__merge_adaptive(__first, __middle, __last,
                			    _Distance(__middle - __first),
                			    _Distance(__last - __middle),
                			    __buffer, __buffer_size,
                			    __comp);
                    }
                
                  /// This is a helper function for the stable sorting routines.
                  template<typename _RandomAccessIterator, typename _Compare>
                    void
                    __inplace_stable_sort(_RandomAccessIterator __first,
                			  _RandomAccessIterator __last, _Compare __comp)
                    {
                      if (__last - __first < 15)
                	{
                	  std::__insertion_sort(__first, __last, __comp);
                	  return;
                	}
                      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
                      std::__inplace_stable_sort(__first, __middle, __comp);
                      std::__inplace_stable_sort(__middle, __last, __comp);
                      std::__merge_without_buffer(__first, __middle, __last,
                				  __middle - __first,
                				  __last - __middle,
                				  __comp);
                    }
                
                  // stable_sort
                
                  // Set algorithms: includes, set_union, set_intersection, set_difference,
                  // set_symmetric_difference.  All of these algorithms have the precondition
                  // that their input ranges are sorted and the postcondition that their output
                  // ranges are sorted.
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    return false;
                	  if (!__comp(__first1, __first2))
                	    ++__first2;
                	  ++__first1;
                	}
                
                      return __first2 == __last2;
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range.
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @return  True if each element in [__first2,__last2) is contained in order
                   *  within [__first1,__last1).  False otherwise.
                   *  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1).
                   *  The iterators over each range only move forward, so this is a
                   *  linear algorithm.  If an element in [__first2,__last2) is not
                   *  found before the search iterator reaches @p __last2, false is
                   *  returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Determines whether all elements of a sequence exists in a range
                   *  using comparison.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of search range.
                   *  @param  __last1   End of search range.
                   *  @param  __first2  Start of sequence
                   *  @param  __last2   End of sequence.
                   *  @param  __comp    Comparison function to use.
                   *  @return True if each element in [__first2,__last2) is contained
                   *  in order within [__first1,__last1) according to comp.  False
                   *  otherwise.  @ingroup set_algorithms
                   *
                   *  This operation expects both [__first1,__last1) and
                   *  [__first2,__last2) to be sorted.  Searches for the presence of
                   *  each element in [__first2,__last2) within [__first1,__last1),
                   *  using comp to decide.  The iterators over each range only move
                   *  forward, so this is a linear algorithm.  If an element in
                   *  [__first2,__last2) is not found before the search iterator
                   *  reaches @p __last2, false is returned.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    includes(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return std::__includes(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // nth_element
                  // merge
                  // set_difference
                  // set_intersection
                  // set_union
                  // stable_sort
                  // set_symmetric_difference
                  // min_element
                  // max_element
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __next_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__i, __ii))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(__i, --__j))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the next one of this set.
                   *  Returns true if there are more sequences to generate.  If the sequence
                   *  is the largest of the set, the smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the next @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to first permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the next one of this set.  Returns true if there are more
                   *  sequences to generate.  If the sequence is the largest of the set, the
                   *  smallest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    next_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__next_permutation
                	(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __prev_permutation(_BidirectionalIterator __first,
                		       _BidirectionalIterator __last, _Compare __comp)
                    {
                      if (__first == __last)
                	return false;
                      _BidirectionalIterator __i = __first;
                      ++__i;
                      if (__i == __last)
                	return false;
                      __i = __last;
                      --__i;
                
                      for(;;)
                	{
                	  _BidirectionalIterator __ii = __i;
                	  --__i;
                	  if (__comp(__ii, __i))
                	    {
                	      _BidirectionalIterator __j = __last;
                	      while (!__comp(--__j, __i))
                		{}
                	      std::iter_swap(__i, __j);
                	      std::__reverse(__ii, __last,
                			     std::__iterator_category(__first));
                	      return true;
                	    }
                	  if (__i == __first)
                	    {
                	      std::__reverse(__first, __last,
                			     std::__iterator_category(__first));
                	      return false;
                	    }
                	}
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range as a set of @e dictionary sorted
                   *  sequences.  Permutes the current sequence into the previous one of this
                   *  set.  Returns true if there are more sequences to generate.  If the
                   *  sequence is the smallest of the set, the largest is generated and false
                   *  returned.
                  */
                  template<typename _BidirectionalIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__prev_permutation(__first, __last,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Permute range into the previous @e dictionary ordering using
                   *          comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   A comparison functor.
                   *  @return  False if wrapped to last permutation, true otherwise.
                   *
                   *  Treats all permutations of the range [__first,__last) as a set of
                   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
                   *  sequence into the previous one of this set.  Returns true if there are
                   *  more sequences to generate.  If the sequence is the smallest of the set,
                   *  the largest is generated and false returned.
                  */
                  template<typename _BidirectionalIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    prev_permutation(_BidirectionalIterator __first,
                		     _BidirectionalIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_BidirectionalIterator>::value_type,
                	    typename iterator_traits<_BidirectionalIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__prev_permutation(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // replace
                  // replace_if
                
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __replace_copy_if(_InputIterator __first, _InputIterator __last,
                		      _OutputIterator __result,
                		      _Predicate __pred, const _Tp& __new_value)
                    {
                      for (; __first != __last; ++__first, (void)++__result)
                	if (__pred(__first))
                	  *__result = __new_value;
                	else
                	  *__result = *__first;
                      return __result;
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each element of one value with another
                   *         value.
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p result+(last-first).
                   *
                   *  Copies each element in the input range @p [__first,__last) to the
                   *  output range @p [__result,__result+(__last-__first)) replacing elements
                   *  equal to @p __old_value with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    replace_copy(_InputIterator __first, _InputIterator __last,
                		 _OutputIterator __result,
                		 const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_equals_val(__old_value),
                					      __new_value);
                    }
                
                  /**
                   *  @brief Copy a sequence, replacing each value for which a predicate
                   *         returns true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      An input iterator.
                   *  @param  __last       An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   The end of the output sequence, @p __result+(__last-__first).
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  @p [__result,__result+(__last-__first)) replacing elements for which
                   *  @p __pred returns true with @p __new_value.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    replace_copy_if(_InputIterator __first, _InputIterator __last,
                		    _OutputIterator __result,
                		    _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__replace_copy_if(__first, __last, __result,
                				__gnu_cxx::__ops::__pred_iter(__pred),
                					      __new_value);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
                    { return std::is_sorted_until(__first, __last) == __last; }
                
                  /**
                   *  @brief  Determines whether the elements of a sequence are sorted
                   *          according to a comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  True if the elements are sorted, false otherwise.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
                	      _Compare __comp)
                    { return std::is_sorted_until(__first, __last, __comp) == __last; }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		      _Compare __comp)
                    {
                      if (__first == __last)
                	return __last;
                
                      _ForwardIterator __next = __first;
                      for (++__next; __next != __last; __first = __next, (void)++__next)
                	if (__comp(__next, __first))
                	  return __next;
                      return __next;
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Determines the end of a sorted sequence using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  An iterator pointing to the last iterator i in [__first, __last)
                   *           for which the range [__first, i) is sorted.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
                		    _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__is_sorted_until(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                
                      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                		       : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  /**
                   *  @brief  Determines min and max at once as an ordered pair.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
                   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
                   *  __b) otherwise.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<const _Tp&, const _Tp&>
                    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                			      : pair<const _Tp&, const _Tp&>(__a, __b);
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    pair<_ForwardIterator, _ForwardIterator>
                    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		     _Compare __comp)
                    {
                      _ForwardIterator __next = __first;
                      if (__first == __last
                	  || ++__next == __last)
                	return std::make_pair(__first, __first);
                
                      _ForwardIterator __min{}, __max{};
                      if (__comp(__next, __first))
                	{
                	  __min = __next;
                	  __max = __first;
                	}
                      else
                	{
                	  __min = __first;
                	  __max = __next;
                	}
                
                      __first = __next;
                      ++__first;
                
                      while (__first != __last)
                	{
                	  __next = __first;
                	  if (++__next == __last)
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      else if (!__comp(__first, __max))
                		__max = __first;
                	      break;
                	    }
                
                	  if (__comp(__next, __first))
                	    {
                	      if (__comp(__next, __min))
                		__min = __next;
                	      if (!__comp(__first, __max))
                		__max = __first;
                	    }
                	  else
                	    {
                	      if (__comp(__first, __min))
                		__min = __first;
                	      if (!__comp(__next, __max))
                		__max = __next;
                	    }
                
                	  __first = __next;
                	  ++__first;
                	}
                
                      return std::make_pair(__min, __max);
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return a pair of iterators pointing to the minimum and maximum
                   *          elements in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  make_pair(m, M), where m is the first iterator i in 
                   *           [__first, __last) such that no other element in the range is
                   *           smaller, and where M is the last iterator i in [__first, __last)
                   *           such that no other element in the range is larger.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_ForwardIterator, _ForwardIterator>
                    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
                		   _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return std::__minmax_element(__first, __last,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  // N2722 + DR 915.
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l)
                    { return *std::min_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    min(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::min_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l)
                    { return *std::max_element(__l.begin(), __l.end()); }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Tp
                    max(initializer_list<_Tp> __l, _Compare __comp)
                    { return *std::max_element(__l.begin(), __l.end(), __comp); }
                
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end());
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline pair<_Tp, _Tp>
                    minmax(initializer_list<_Tp> __l, _Compare __comp)
                    {
                      pair<const _Tp*, const _Tp*> __p =
                	std::minmax_element(__l.begin(), __l.end(), __comp);
                      return std::make_pair(*__p.first, *__p.second);
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in
                   *          the range [__first2, __first2 + (__last1 - __first1)),
                   *          beginning with ForwardIterator2 begin, such that
                   *          equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201103L
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		     _BinaryPredicate __pred)
                    {
                      using _Cat1
                	= typename iterator_traits<_ForwardIterator1>::iterator_category;
                      using _Cat2
                	= typename iterator_traits<_ForwardIterator2>::iterator_category;
                      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
                      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
                      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
                      if (__ra_iters)
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__ra_iters)
                	{
                	  if (__first1 == __last1)
                	    return true;
                	}
                      else
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 == 0 && __d2 == 0)
                	    return true;
                	  if (__d1 != __d2)
                	    return false;
                	}
                
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                
                	  auto __matches = std::__count_if(__first2, __last2,
                		__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches
                	      || std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutaion of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, begin) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return
                	std::__is_permutation(__first1, __last1, __first2, __last2,
                			      __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of first range.
                   *  @param  __pred    A binary predicate.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __last2), beginning with ForwardIterator2 begin,
                   *          such that equal(__first1, __last1, __begin, __pred) returns true;
                   *          otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                		   _BinaryPredicate __pred)
                    {
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__is_permutation(__first1, __last1, __first2, __last2,
                				   __gnu_cxx::__ops::__iter_comp_iter(__pred));
                    }
                
                #if __cplusplus > 201402L
                
                #define __cpp_lib_clamp 201603
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val  A value of arbitrary type.
                   *  @param  __lo   A lower limit of arbitrary type.
                   *  @param  __hi   An upper limit of arbitrary type.
                   *  @return max(__val, __lo) if __val < __hi or min(__val, __hi) otherwise.
                   */
                  template<typename _Tp>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi)
                    {
                      __glibcxx_assert(!(__hi < __lo));
                      return (__val < __lo) ? __lo : (__hi < __val) ? __hi : __val;
                    }
                
                  /**
                   *  @brief  Returns the value clamped between lo and hi.
                   *  @ingroup sorting_algorithms
                   *  @param  __val   A value of arbitrary type.
                   *  @param  __lo    A lower limit of arbitrary type.
                   *  @param  __hi    An upper limit of arbitrary type.
                   *  @param  __comp  A comparison functor.
                   *  @return max(__val, __lo, __comp) if __comp(__val, __hi)
                   *	      or min(__val, __hi, __comp) otherwise.
                   */
                  template<typename _Tp, typename _Compare>
                    constexpr const _Tp&
                    clamp(const _Tp& __val, const _Tp& __lo, const _Tp& __hi, _Compare __comp)
                    {
                      __glibcxx_assert(!__comp(__hi, __lo));
                      return __comp(__val, __lo) ? __lo : __comp(__hi, __val) ? __hi : __val;
                    }
                #endif // C++17
                #endif // C++14
                
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                  /**
                   *  @brief Generate two uniformly distributed integers using a
                   *         single distribution invocation.
                   *  @param  __b0    The upper bound for the first integer.
                   *  @param  __b1    The upper bound for the second integer.
                   *  @param  __g     A UniformRandomBitGenerator.
                   *  @return  A pair (i, j) with i and j uniformly distributed
                   *           over [0, __b0) and [0, __b1), respectively.
                   *
                   *  Requires: __b0 * __b1 <= __g.max() - __g.min().
                   *
                   *  Using uniform_int_distribution with a range that is very
                   *  small relative to the range of the generator ends up wasting
                   *  potentially expensively generated randomness, since
                   *  uniform_int_distribution does not store leftover randomness
                   *  between invocations.
                   *
                   *  If we know we want two integers in ranges that are sufficiently
                   *  small, we can compose the ranges, use a single distribution
                   *  invocation, and significantly reduce the waste.
                  */
                  template<typename _IntType, typename _UniformRandomBitGenerator>
                    pair<_IntType, _IntType>
                    __gen_two_uniform_ints(_IntType __b0, _IntType __b1,
                			   _UniformRandomBitGenerator&& __g)
                    {
                      _IntType __x
                	= uniform_int_distribution<_IntType>{0, (__b0 * __b1) - 1}(__g);
                      return std::make_pair(__x / __b1, __x % __b1);
                    }
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a uniform random
                   *         number generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __g to
                   *  provide random numbers.
                  */
                  template<typename _RandomAccessIterator,
                	   typename _UniformRandomNumberGenerator>
                    void
                    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	    _UniformRandomNumberGenerator&& __g)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                
                      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
                      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
                      typedef typename __distr_type::param_type __p_type;
                
                      typedef typename remove_reference<_UniformRandomNumberGenerator>::type
                	_Gen;
                      typedef typename common_type<typename _Gen::result_type, __ud_type>::type
                	__uc_type;
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      const __uc_type __urange = __uc_type(__last - __first);
                
                      if (__urngrange / __urange >= __urange)
                        // I.e. (__urngrange >= __urange * __urange) but without wrap issues.
                      {
                	_RandomAccessIterator __i = __first + 1;
                
                	// Since we know the range isn't empty, an even number of elements
                	// means an uneven number of elements /to swap/, in which case we
                	// do the first one up front:
                
                	if ((__urange % 2) == 0)
                	{
                	  __distr_type __d{0, 1};
                	  std::iter_swap(__i++, __first + __d(__g));
                	}
                
                	// Now we know that __last - __i is even, so we do the rest in pairs,
                	// using a single distribution invocation to produce swap positions
                	// for two successive elements at a time:
                
                	while (__i != __last)
                	{
                	  const __uc_type __swap_range = __uc_type(__i - __first) + 1;
                
                	  const pair<__uc_type, __uc_type> __pospos =
                	    __gen_two_uniform_ints(__swap_range, __swap_range + 1, __g);
                
                	  std::iter_swap(__i++, __first + __pospos.first);
                	  std::iter_swap(__i++, __first + __pospos.second);
                	}
                
                	return;
                      }
                
                      __distr_type __d;
                
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
                    }
                #endif
                
                #endif // C++11
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __f      A unary function object.
                   *  @return   @p __f
                   *
                   *  Applies the function object @p __f to each element in the range
                   *  @p [first,last).  @p __f must not modify the order of the sequence.
                   *  If @p __f has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Function>
                    _GLIBCXX20_CONSTEXPR
                    _Function
                    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                      for (; __first != __last; ++__first)
                	__f(*__first);
                      return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
                    }
                
                #if __cplusplus >= 201703L
                  /**
                   *  @brief Apply a function to every element of a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __n      A value convertible to an integer.
                   *  @param  __f      A unary function object.
                   *  @return   `__first+__n`
                   *
                   *  Applies the function object `__f` to each element in the range
                   *  `[first, first+n)`.  `__f` must not modify the order of the sequence.
                   *  If `__f` has a return value it is ignored.
                  */
                  template<typename _InputIterator, typename _Size, typename _Function>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    for_each_n(_InputIterator __first, _Size __n, _Function __f)
                    {
                      auto __n2 = std::__size_to_integer(__n);
                      using _Cat = typename iterator_traits<_InputIterator>::iterator_category;
                      if constexpr (is_base_of_v<random_access_iterator_tag, _Cat>)
                	{
                	  if (__n2 <= 0)
                	    return __first;
                	  auto __last = __first + __n2;
                	  std::for_each(__first, __last, std::move(__f));
                	  return __last;
                	}
                      else
                	{
                	  while (__n2-->0)
                	    {
                	      __f(*__first);
                	      ++__first;
                	    }
                	  return __first;
                	}
                    }
                #endif // C++17
                
                  /**
                   *  @brief Find the first occurrence of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __val    The value to find.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find(_InputIterator __first, _InputIterator __last,
                	 const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                  /**
                   *  @brief Find the first element in a sequence for which a
                   *         predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The first iterator @c i in the range @p [__first,__last)
                   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    find_if(_InputIterator __first, _InputIterator __last,
                	    _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	      typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__find_if(__first, __last,
                			    __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
                   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (*__first1 == *__iter)
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief  Find element from a set in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of range to search.
                   *  @param  __last1   End of range to search.
                   *  @param  __first2  Start of match candidates.
                   *  @param  __last2   End of match candidates.
                   *  @param  __comp    Predicate to use.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
                   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
                   *  such iterator exists.
                   *
                
                   *  Searches the range @p [__first1,__last1) for an element that is
                   *  equal to some element in the range [__first2,__last2).  If
                   *  found, returns an iterator in the range [__first1,__last1),
                   *  otherwise returns @p __last1.
                  */
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    _InputIterator
                    find_first_of(_InputIterator __first1, _InputIterator __last1,
                		  _ForwardIterator __first2, _ForwardIterator __last2,
                		  _BinaryPredicate __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_InputIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      for (; __first1 != __last1; ++__first1)
                	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
                	  if (__comp(*__first1, *__iter))
                	    return __first1;
                      return __last1;
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence that are equal.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
                   *  or @p __last if no such iterator exists.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                				  __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Find two adjacent values in a sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first         A forward iterator.
                   *  @param  __last          A forward iterator.
                   *  @param  __binary_pred   A binary predicate.
                   *  @return   The first iterator @c i such that @c i and @c i+1 are both
                   *  valid iterators in @p [__first,__last) and such that
                   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
                   *  exists.
                  */
                  template<typename _ForwardIterator, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
                		  _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__adjacent_find(__first, __last,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                  /**
                   *  @brief Count the number of copies of a value in a sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __value  The value to be counted.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @c *i == @p __value
                  */
                  template<typename _InputIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__iter_equals_val(__value));
                    }
                
                  /**
                   *  @brief Count the elements of a sequence for which a predicate is true.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __pred   A predicate.
                   *  @return   The number of iterators @c i in the range @p [__first,__last)
                   *  for which @p __pred(*i) is true.
                  */
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline typename iterator_traits<_InputIterator>::difference_type
                    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__count_if(__first, __last,
                			     __gnu_cxx::__ops::__pred_iter(__pred));
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @param  __last2   A forward iterator.
                   *  @return The first iterator @c i in the range @p
                   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
                   *  *(__first2+N) for each @c N in the range @p
                   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2) and returns an iterator to the first element
                   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
                   *  found.
                   *
                   *  Because the sub-sequence must lie completely within the range @p
                   *  [__first1,__last1) it must start at a position less than @p
                   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
                   *  length of the sub-sequence.
                   *
                   *  This means that the returned iterator @c i will be in the range
                   *  @p [__first1,__last1-(__last2-__first2))
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Search a sequence for a matching sub-sequence using a predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1     A forward iterator.
                   *  @param  __last1      A forward iterator.
                   *  @param  __first2     A forward iterator.
                   *  @param  __last2      A forward iterator.
                   *  @param  __predicate  A binary predicate.
                   *  @return   The first iterator @c i in the range
                   *  @p [__first1,__last1-(__last2-__first2)) such that
                   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
                   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
                   *
                   *  Searches the range @p [__first1,__last1) for a sub-sequence that
                   *  compares equal value-by-value with the sequence given by @p
                   *  [__first2,__last2), using @p __predicate to determine equality,
                   *  and returns an iterator to the first element of the
                   *  sub-sequence, or @p __last1 if no such iterator exists.
                   *
                   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator1
                    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                	   _BinaryPredicate  __predicate)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator1>::value_type,
                	    typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__search(__first1, __last1, __first2, __last2,
                			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
                    }
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __count  The number of consecutive values.
                   *  @param  __val    The value to find.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
                   *  each @c N in the range @p [0,__count), or @p __last if no such
                   *  iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p count consecutive elements
                   *  equal to @p __val.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                			     __gnu_cxx::__ops::__iter_equals_val(__val));
                    }
                
                
                  /**
                   *  @brief Search a sequence for a number of consecutive values using a
                   *         predicate.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __count        The number of consecutive values.
                   *  @param  __val          The value to find.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return The first iterator @c i in the range @p
                   *  [__first,__last-__count) such that @p
                   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
                   *  @p [0,__count), or @p __last if no such iterator exists.
                   *
                   *  Searches the range @p [__first,__last) for @p __count
                   *  consecutive elements for which the predicate returns true.
                  */
                  template<typename _ForwardIterator, typename _Integer, typename _Tp,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search_n(_ForwardIterator __first, _ForwardIterator __last,
                	     _Integer __count, const _Tp& __val,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__search_n(__first, __last, __count,
                		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
                    }
                
                #if __cplusplus >= 201703L
                  /** @brief Search a sequence using a Searcher object.
                   *
                   *  @param  __first        A forward iterator.
                   *  @param  __last         A forward iterator.
                   *  @param  __searcher     A callable object.
                   *  @return @p __searcher(__first,__last).first
                  */
                  template<typename _ForwardIterator, typename _Searcher>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    search(_ForwardIterator __first, _ForwardIterator __last,
                	   const _Searcher& __searcher)
                    { return __searcher(__first, __last).first; }
                #endif
                
                  /**
                   *  @brief Perform an operation on a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first     An input iterator.
                   *  @param  __last      An input iterator.
                   *  @param  __result    An output iterator.
                   *  @param  __unary_op  A unary operator.
                   *  @return   An output iterator equal to @p __result+(__last-__first).
                   *
                   *  Applies the operator to each element in the input range and assigns
                   *  the results to successive elements of the output sequence.
                   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
                   *  range @p [0,__last-__first).
                   *
                   *  @p unary_op must not alter its argument.
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _UnaryOperation>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    transform(_InputIterator __first, _InputIterator __last,
                	      _OutputIterator __result, _UnaryOperation __unary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _UnaryOperation"
                	    __typeof__(__unary_op(*__first))>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first, (void)++__result)
                	*__result = __unary_op(*__first);
                      return __result;
                    }
                
                  /**
                   *  @brief Perform an operation on corresponding elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1     An input iterator.
                   *  @param  __last1      An input iterator.
                   *  @param  __first2     An input iterator.
                   *  @param  __result     An output iterator.
                   *  @param  __binary_op  A binary operator.
                   *  @return   An output iterator equal to @p result+(last-first).
                   *
                   *  Applies the operator to the corresponding elements in the two
                   *  input ranges and assigns the results to successive elements of the
                   *  output sequence.
                   *  Evaluates @p
                   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
                   *  @c N in the range @p [0,__last1-__first1).
                   *
                   *  @p binary_op must not alter either of its arguments.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _BinaryOperation>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    transform(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _OutputIterator __result,
                	      _BinaryOperation __binary_op)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _BinaryOperation"
                	    __typeof__(__binary_op(*__first1,*__first2))>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
                	*__result = __binary_op(*__first1, *__first2);
                      return __result;
                    }
                
                  /**
                   *  @brief Replace each occurrence of one value in a sequence with another
                   *         value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __old_value  The value to be replaced.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
                   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    void
                    replace(_ForwardIterator __first, _ForwardIterator __last,
                	    const _Tp& __old_value, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (*__first == __old_value)
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Replace each value in a sequence for which a predicate returns
                   *         true with another value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first      A forward iterator.
                   *  @param  __last       A forward iterator.
                   *  @param  __pred       A predicate.
                   *  @param  __new_value  The replacement value.
                   *  @return   replace_if() returns no value.
                   *
                   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
                   *  is true then the assignment @c *i = @p __new_value is performed.
                  */
                  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    void
                    replace_if(_ForwardIterator __first, _ForwardIterator __last,
                	       _Predicate __pred, const _Tp& __new_value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	if (__pred(*__first))
                	  *__first = __new_value;
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   generate() returns no value.
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__last).
                  */
                  template<typename _ForwardIterator, typename _Generator>
                    _GLIBCXX20_CONSTEXPR
                    void
                    generate(_ForwardIterator __first, _ForwardIterator __last,
                	     _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_GeneratorConcept<_Generator,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      for (; __first != __last; ++__first)
                	*__first = __gen();
                    }
                
                  /**
                   *  @brief Assign the result of a function object to each value in a
                   *         sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __n      The length of the sequence.
                   *  @param  __gen    A function object taking no arguments and returning
                   *                 std::iterator_traits<_ForwardIterator>::value_type
                   *  @return   The end of the sequence, @p __first+__n
                   *
                   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
                   *  @p [__first,__first+__n).
                   *
                   * If @p __n is negative, the function does nothing and returns @p __first.
                  */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 865. More algorithms that throw away information
                  // DR 426. search_n(), fill_n(), and generate_n() with negative n
                  template<typename _OutputIterator, typename _Size, typename _Generator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    // "the type returned by a _Generator"
                	    __typeof__(__gen())>)
                
                      typedef __decltype(std::__size_to_integer(__n)) _IntSize;
                      for (_IntSize __niter = std::__size_to_integer(__n);
                	   __niter > 0; --__niter, (void) ++__first)
                	*__first = __gen();
                      return __first;
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive duplicate values.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   An input iterator.
                   *  @param  __last    An input iterator.
                   *  @param  __result  An output iterator.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements that compare equal.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                   *  
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
                   *  Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_function_requires(_EqualityComparableConcept<
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                				__gnu_cxx::__ops::__iter_equal_to_iter(),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                  /**
                   *  @brief Copy a sequence, removing consecutive values using a predicate.
                   *  @ingroup mutating_algorithms
                   *  @param  __first        An input iterator.
                   *  @param  __last         An input iterator.
                   *  @param  __result       An output iterator.
                   *  @param  __binary_pred  A binary predicate.
                   *  @return   An iterator designating the end of the resulting sequence.
                   *
                   *  Copies each element in the range @p [__first,__last) to the range
                   *  beginning at @p __result, except that only the first element is copied
                   *  from groups of consecutive elements for which @p __binary_pred returns
                   *  true.
                   *  unique_copy() is stable, so the relative order of elements that are
                   *  copied is unchanged.
                   *
                   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
                   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
                  */
                  template<typename _InputIterator, typename _OutputIterator,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    unique_copy(_InputIterator __first, _InputIterator __last,
                		_OutputIterator __result,
                		_BinaryPredicate __binary_pred)
                    {
                      // concept requirements -- predicates checked later
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return __result;
                      return std::__unique_copy(__first, __last, __result,
                			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
                				std::__iterator_category(__first),
                				std::__iterator_category(__result));
                    }
                
                #if _GLIBCXX_HOSTED
                  /**
                   *  @brief Randomly shuffle the elements of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @return  Nothing.
                   *
                   *  Reorder the elements in the range @p [__first,__last) using a random
                   *  distribution, so that every possible ordering of the sequence is
                   *  equally likely.
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first != __last)
                	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	  {
                	    // XXX rand() % N is not uniformly distributed
                	    _RandomAccessIterator __j = __first
                					+ std::rand() % ((__i - __first) + 1);
                	    if (__i != __j)
                	      std::iter_swap(__i, __j);
                	  }
                    }
                #endif
                
                  /**
                   *  @brief Shuffle the elements of a sequence using a random number
                   *         generator.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __rand    The RNG functor or function.
                   *  @return  Nothing.
                   *
                   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
                   *  provide a random distribution. Calling @p __rand(N) for a positive
                   *  integer @p N should return a randomly chosen integer from the
                   *  range [0,N).
                  */
                  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
                    void
                    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
                #if __cplusplus >= 201103L
                		   _RandomNumberGenerator&& __rand)
                #else
                		   _RandomNumberGenerator& __rand)
                #endif
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      if (__first == __last)
                	return;
                      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
                	{
                	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
                	  if (__i != __j)
                	    std::iter_swap(__i, __j);
                	}
                    }
                
                
                  /**
                   *  @brief Move elements for which a predicate is true to the beginning
                   *         of a sequence.
                   *  @ingroup mutating_algorithms
                   *  @param  __first   A forward iterator.
                   *  @param  __last    A forward iterator.
                   *  @param  __pred    A predicate functor.
                   *  @return  An iterator @p middle such that @p __pred(i) is true for each
                   *  iterator @p i in the range @p [__first,middle) and false for each @p i
                   *  in the range @p [middle,__last).
                   *
                   *  @p __pred must not modify its operand. @p partition() does not preserve
                   *  the relative ordering of elements in each group, use
                   *  @p stable_partition() if this is needed.
                  */
                  template<typename _ForwardIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    partition(_ForwardIterator __first, _ForwardIterator __last,
                	      _Predicate   __pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      return std::__partition(__first, __last, __pred,
                			      std::__iterator_category(__first));
                    }
                
                
                  /**
                   *  @brief Sort the smallest elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [first,last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the smallest elements of a sequence using a predicate
                   *         for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __middle  Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the smallest @p (__middle-__first) elements in the range
                   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
                   *  order of the remaining elements in the range @p [__middle,__last) is
                   *  undefined.
                   *  After the sort if @e i and @e j are iterators in the range
                   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
                   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
                   *  are both false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    partial_sort(_RandomAccessIterator __first,
                		 _RandomAccessIterator __middle,
                		 _RandomAccessIterator __last,
                		 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __middle);
                      __glibcxx_requires_valid_range(__middle, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__partial_sort(__first, __middle, __last,
                			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that *j < *i is false.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort a sequence just enough to find a particular position
                   *         using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __nth     Another iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
                   *  is the same element that would have been in that position had the
                   *  whole sequence been sorted. The elements either side of @p *__nth are
                   *  not completely sorted, but for any iterator @e i in the range
                   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
                   *  holds that @p __comp(*j,*i) is false.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                		_RandomAccessIterator __last, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __nth);
                      __glibcxx_requires_valid_range(__nth, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      if (__first == __last || __nth == __last)
                	return;
                
                      std::__introselect(__first, __nth, __last,
                			 std::__lg(__last - __first) * 2,
                			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @e i in the range @p [__first,__last-1),  
                   *  *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
                   *  range @p [__first,__last-1).
                   *
                   *  The relative ordering of equivalent elements is not preserved, use
                   *  @p stable_sort() if this is needed.
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	 _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	    _InputIterator2 __first2, _InputIterator2 __last2,
                	    _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
                   *            + (__last2 - __first2).
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Merges two sorted ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An iterator.
                   *  @param  __first2  Another iterator.
                   *  @param  __last1   Another iterator.
                   *  @param  __last2   Another iterator.
                   *  @param  __result  An iterator pointing to the end of the merged range.
                   *  @param  __comp    A functor to use for comparisons.
                   *  @return   An output iterator equal to @p __result + (__last1 - __first1)
                   *            + (__last2 - __first2).
                   *
                   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
                   *  the sorted range @p [__result, __result + (__last1-__first1) +
                   *  (__last2-__first2)).  Both input ranges must be sorted, and the
                   *  output range must not overlap with either of the input ranges.
                   *  The sort is @e stable, that is, for equivalent elements in the
                   *  two ranges, elements from the first range will always come
                   *  before elements from the second.
                   *
                   *  The comparison function should have the same effects on ordering as
                   *  the function used for the initial sort.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    merge(_InputIterator1 __first1, _InputIterator1 __last1,
                	  _InputIterator2 __first2, _InputIterator2 __last2,
                	  _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__merge(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		  _Compare __comp)
                    {
                      typedef typename iterator_traits<_RandomAccessIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
                	_DistanceType;
                      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
                
                      if (__first == __last)
                	return;
                
                      // __stable_sort_adaptive sorts the range in two halves,
                      // so the buffer only needs to fit half the range at once.
                      _TmpBuf __buf(__first, (__last - __first + 1) / 2);
                
                      if (__buf.begin() == 0)
                	std::__inplace_stable_sort(__first, __last, __comp);
                      else
                	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
                				    _DistanceType(__buf.size()), __comp);
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence, preserving the relative order
                   *         of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p *(i+1)<*i is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p x<y is false and @p y<x is false will have the same relative
                   *  ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Sort the elements of a sequence using a predicate for comparison,
                   *         preserving the relative order of equivalent elements.
                   *  @ingroup sorting_algorithms
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __comp    A comparison functor.
                   *  @return  Nothing.
                   *
                   *  Sorts the elements in the range @p [__first,__last) in ascending order,
                   *  such that for each iterator @p i in the range @p [__first,__last-1),
                   *  @p __comp(*(i+1),*i) is false.
                   *
                   *  The relative ordering of equivalent elements is preserved, so any two
                   *  elements @p x and @p y in the range @p [__first,__last) such that
                   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
                   *  relative ordering after calling @p stable_sort().
                  */
                  template<typename _RandomAccessIterator, typename _Compare>
                    inline void
                    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
                	    _RandomAccessIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_RandomAccessIterator>::value_type,
                	    typename iterator_traits<_RandomAccessIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      _GLIBCXX_STD_A::__stable_sort(__first, __last,
                				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                		_InputIterator2 __first2, _InputIterator2 __last2,
                		_OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	{
                	  if (__comp(__first1, __first2))
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	    }
                	  else if (__comp(__first2, __first1))
                	    {
                	      *__result = *__first2;
                	      ++__first2;
                	    }
                	  else
                	    {
                	      *__result = *__first1;
                	      ++__first1;
                	      ++__first2;
                	    }
                	  ++__result;
                	}
                      return std::copy(__first2, __last2,
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that element is copied and the iterator advanced.  If an element is
                   *  contained in both ranges, the element from the first range is copied and
                   *  both ranges advance.  The output range may not overlap either input
                   *  range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the union of two sorted ranges using a comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  each range in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that element is copied and the iterator advanced.
                   *  If an equivalent element according to @p __comp is contained in both
                   *  ranges, the element from the first range is copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                	      _InputIterator2 __first2, _InputIterator2 __last2,
                	      _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		       _InputIterator2 __first2, _InputIterator2 __last2,
                		       _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  ++__first1;
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__first2;
                	    ++__result;
                	  }
                      return __result;
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other,
                   *  that iterator advances.  If an element is contained in both ranges, the
                   *  element from the first range is copied and both ranges advance.  The
                   *  output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				     __first2, __last2, __result,
                				     __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief Return the intersection of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  both ranges in order to the output range.  Iterators increment for each
                   *  range.  When the current element of one range is less than the other
                   *  according to @p __comp, that iterator advances.  If an element is
                   *  contained in both ranges according to @p __comp, the element from the
                   *  first range is copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		     _InputIterator2 __first2, _InputIterator2 __last2,
                		     _OutputIterator __result, _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  ++__first2;
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first1, __last1, __result);
                    }
                
                  /**
                   *  @brief Return the difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second, that element is copied and the
                   *  iterator advances.  If the current element of the second range is less,
                   *  the iterator advances, but no element is copied.  If an element is
                   *  contained in both ranges, no elements are copied and both ranges
                   *  advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the difference of two sorted ranges using comparison
                   *  functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  the first range but not the second in order to the output range.
                   *  Iterators increment for each range.  When the current element of the
                   *  first range is less than the second according to @p __comp, that element
                   *  is copied and the iterator advances.  If the current element of the
                   *  second range is less, no element is copied and the iterator advances.
                   *  If an element is contained in both ranges according to @p __comp, no
                   *  elements are copied and both ranges advance.  The output range may not
                   *  overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                		   _InputIterator2 __first2, _InputIterator2 __last2,
                		   _OutputIterator __result, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
                				   __first2, __last2, __result,
                				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator,
                	   typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __set_symmetric_difference(_InputIterator1 __first1,
                			       _InputIterator1 __last1,
                			       _InputIterator2 __first2,
                			       _InputIterator2 __last2,
                			       _OutputIterator __result,
                			       _Compare __comp)
                    {
                      while (__first1 != __last1 && __first2 != __last2)
                	if (__comp(__first1, __first2))
                	  {
                	    *__result = *__first1;
                	    ++__first1;
                	    ++__result;
                	  }
                	else if (__comp(__first2, __first1))
                	  {
                	    *__result = *__first2;
                	    ++__first2;
                	    ++__result;
                	  }
                	else
                	  {
                	    ++__first1;
                	    ++__first2;
                	  }
                      return std::copy(__first2, __last2, 
                		       std::copy(__first1, __last1, __result));
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other, that element is copied and the iterator advances.  If an
                   *  element is contained in both ranges, no elements are copied and both
                   *  ranges advance.  The output range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)	
                      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
                      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
                      __glibcxx_requires_irreflexive2(__first1, __last1);
                      __glibcxx_requires_irreflexive2(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                					__first2, __last2, __result,
                					__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the symmetric difference of two sorted ranges using
                   *  comparison functor.
                   *  @ingroup set_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @param  __last2   End of second range.
                   *  @param  __result  Start of output range.
                   *  @param  __comp    The comparison functor.
                   *  @return  End of the output range.
                   *  @ingroup set_algorithms
                   *
                   *  This operation iterates over both ranges, copying elements present in
                   *  one range but not the other in order to the output range.  Iterators
                   *  increment for each range.  When the current element of one range is less
                   *  than the other according to @p comp, that element is copied and the
                   *  iterator advances.  If an element is contained in both ranges according
                   *  to @p __comp, no elements are copied and both ranges advance.  The output
                   *  range may not overlap either input range.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _OutputIterator, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                			     _InputIterator2 __first2, _InputIterator2 __last2,
                			     _OutputIterator __result,
                			     _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_InputIterator2>::value_type,
                	    typename iterator_traits<_InputIterator1>::value_type>)
                      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
                      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
                      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
                
                      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
                				__first2, __last2, __result,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __min_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last)
                	return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__first, __result))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the smallest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the minimum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the smallest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    min_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__min_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    _ForwardIterator
                    __max_element(_ForwardIterator __first, _ForwardIterator __last,
                		  _Compare __comp)
                    {
                      if (__first == __last) return __first;
                      _ForwardIterator __result = __first;
                      while (++__first != __last)
                	if (__comp(__result, __first))
                	  __result = __first;
                      return __result;
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @return  Iterator referencing the first instance of the largest value.
                  */
                  template<typename _ForwardIterator>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanComparableConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive(__first, __last);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_less_iter());
                    }
                
                  /**
                   *  @brief  Return the maximum element in a range using comparison functor.
                   *  @ingroup sorting_algorithms
                   *  @param  __first  Start of range.
                   *  @param  __last   End of range.
                   *  @param  __comp   Comparison functor.
                   *  @return  Iterator referencing the first instance of the largest value
                   *  according to __comp.
                  */
                  template<typename _ForwardIterator, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _ForwardIterator
                    max_element(_ForwardIterator __first, _ForwardIterator __last,
                		_Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
                	    typename iterator_traits<_ForwardIterator>::value_type,
                	    typename iterator_traits<_ForwardIterator>::value_type>)
                      __glibcxx_requires_valid_range(__first, __last);
                      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
                
                      return _GLIBCXX_STD_A::__max_element(__first, __last,
                				__gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cplusplus >= 201402L
                  /// Reservoir sampling algorithm.
                  template<typename _InputIterator, typename _RandomAccessIterator,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _RandomAccessIterator
                    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
                	     _RandomAccessIterator __out, random_access_iterator_tag,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      __distrib_type __d{};
                      _Size __sample_sz = 0;
                      while (__first != __last && __sample_sz != __n)
                	{
                	  __out[__sample_sz++] = *__first;
                	  ++__first;
                	}
                      for (auto __pop_sz = __sample_sz; __first != __last;
                	  ++__first, (void) ++__pop_sz)
                	{
                	  const auto __k = __d(__g, __param_type{0, __pop_sz});
                	  if (__k < __n)
                	    __out[__k] = *__first;
                	}
                      return __out + __sample_sz;
                    }
                
                  /// Selection sampling algorithm.
                  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
                           typename _Size, typename _UniformRandomBitGenerator>
                    _OutputIterator
                    __sample(_ForwardIterator __first, _ForwardIterator __last,
                	     forward_iterator_tag,
                	     _OutputIterator __out, _Cat,
                	     _Size __n, _UniformRandomBitGenerator&& __g)
                    {
                      using __distrib_type = uniform_int_distribution<_Size>;
                      using __param_type = typename __distrib_type::param_type;
                      using _USize = make_unsigned_t<_Size>;
                      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
                      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
                
                      if (__first == __last)
                	return __out;
                
                      __distrib_type __d{};
                      _Size __unsampled_sz = std::distance(__first, __last);
                      __n = std::min(__n, __unsampled_sz);
                
                      // If possible, we use __gen_two_uniform_ints to efficiently produce
                      // two random numbers using a single distribution invocation:
                
                      const __uc_type __urngrange = __g.max() - __g.min();
                      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))
                        // I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without
                	// wrapping issues.
                        {
                	  while (__n != 0 && __unsampled_sz >= 2)
                	    {
                	      const pair<_Size, _Size> __p =
                		__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);
                
                	      --__unsampled_sz;
                	      if (__p.first < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                
                	      if (__n == 0) break;
                
                	      --__unsampled_sz;
                	      if (__p.second < __n)
                		{
                		  *__out++ = *__first;
                		  --__n;
                		}
                
                	      ++__first;
                	    }
                        }
                
                      // The loop above is otherwise equivalent to this one-at-a-time version:
                
                      for (; __n != 0; ++__first)
                	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
                	  {
                	    *__out++ = *__first;
                	    --__n;
                	  }
                      return __out;
                    }
                
                #if __cplusplus > 201402L
                #define __cpp_lib_sample 201603
                  /// Take a random sample from a population.
                  template<typename _PopulationIterator, typename _SampleIterator,
                           typename _Distance, typename _UniformRandomBitGenerator>
                    _SampleIterator
                    sample(_PopulationIterator __first, _PopulationIterator __last,
                	   _SampleIterator __out, _Distance __n,
                	   _UniformRandomBitGenerator&& __g)
                    {
                      using __pop_cat = typename
                	std::iterator_traits<_PopulationIterator>::iterator_category;
                      using __samp_cat = typename
                	std::iterator_traits<_SampleIterator>::iterator_category;
                
                      static_assert(
                	  __or_<is_convertible<__pop_cat, forward_iterator_tag>,
                		is_convertible<__samp_cat, random_access_iterator_tag>>::value,
                	  "output range must use a RandomAccessIterator when input range"
                	  " does not meet the ForwardIterator requirements");
                
                      static_assert(is_integral<_Distance>::value,
                		    "sample size must be an integer type");
                
                      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
                      return _GLIBCXX_STD_A::
                	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
                		 std::forward<_UniformRandomBitGenerator>(__g));
                    }
                #endif // C++17
                #endif // C++14
                
                _GLIBCXX_END_NAMESPACE_ALGO
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_ALGO_H */


Top 10 Lines:

     Line      Count

      813        750
      850        750

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

     1500   Total number of line executions
   375.00   Average executions per line


*** File /usr/include/SFML/Graphics/Transformable.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_TRANSFORMABLE_HPP
                #define SFML_TRANSFORMABLE_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/Transform.hpp>
                
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Decomposed transform defined by a position, a rotation and a scale
                ///
                ////////////////////////////////////////////////////////////
       44171 -> class SFML_GRAPHICS_API Transformable
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    ////////////////////////////////////////////////////////////
                    Transformable();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Virtual destructor
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual ~Transformable();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the position of the object
                    ///
                    /// This function completely overwrites the previous position.
                    /// See the move function to apply an offset based on the previous position instead.
                    /// The default position of a transformable object is (0, 0).
                    ///
                    /// \param x X coordinate of the new position
                    /// \param y Y coordinate of the new position
                    ///
                    /// \see move, getPosition
                    ///
                    ////////////////////////////////////////////////////////////
                    void setPosition(float x, float y);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the position of the object
                    ///
                    /// This function completely overwrites the previous position.
                    /// See the move function to apply an offset based on the previous position instead.
                    /// The default position of a transformable object is (0, 0).
                    ///
                    /// \param position New position
                    ///
                    /// \see move, getPosition
                    ///
                    ////////////////////////////////////////////////////////////
                    void setPosition(const Vector2f& position);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the orientation of the object
                    ///
                    /// This function completely overwrites the previous rotation.
                    /// See the rotate function to add an angle based on the previous rotation instead.
                    /// The default rotation of a transformable object is 0.
                    ///
                    /// \param angle New rotation, in degrees
                    ///
                    /// \see rotate, getRotation
                    ///
                    ////////////////////////////////////////////////////////////
                    void setRotation(float angle);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the scale factors of the object
                    ///
                    /// This function completely overwrites the previous scale.
                    /// See the scale function to add a factor based on the previous scale instead.
                    /// The default scale of a transformable object is (1, 1).
                    ///
                    /// \param factorX New horizontal scale factor
                    /// \param factorY New vertical scale factor
                    ///
                    /// \see scale, getScale
                    ///
                    ////////////////////////////////////////////////////////////
                    void setScale(float factorX, float factorY);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the scale factors of the object
                    ///
                    /// This function completely overwrites the previous scale.
                    /// See the scale function to add a factor based on the previous scale instead.
                    /// The default scale of a transformable object is (1, 1).
                    ///
                    /// \param factors New scale factors
                    ///
                    /// \see scale, getScale
                    ///
                    ////////////////////////////////////////////////////////////
                    void setScale(const Vector2f& factors);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the local origin of the object
                    ///
                    /// The origin of an object defines the center point for
                    /// all transformations (position, scale, rotation).
                    /// The coordinates of this point must be relative to the
                    /// top-left corner of the object, and ignore all
                    /// transformations (position, scale, rotation).
                    /// The default origin of a transformable object is (0, 0).
                    ///
                    /// \param x X coordinate of the new origin
                    /// \param y Y coordinate of the new origin
                    ///
                    /// \see getOrigin
                    ///
                    ////////////////////////////////////////////////////////////
                    void setOrigin(float x, float y);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief set the local origin of the object
                    ///
                    /// The origin of an object defines the center point for
                    /// all transformations (position, scale, rotation).
                    /// The coordinates of this point must be relative to the
                    /// top-left corner of the object, and ignore all
                    /// transformations (position, scale, rotation).
                    /// The default origin of a transformable object is (0, 0).
                    ///
                    /// \param origin New origin
                    ///
                    /// \see getOrigin
                    ///
                    ////////////////////////////////////////////////////////////
                    void setOrigin(const Vector2f& origin);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the position of the object
                    ///
                    /// \return Current position
                    ///
                    /// \see setPosition
                    ///
                    ////////////////////////////////////////////////////////////
                    const Vector2f& getPosition() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the orientation of the object
                    ///
                    /// The rotation is always in the range [0, 360].
                    ///
                    /// \return Current rotation, in degrees
                    ///
                    /// \see setRotation
                    ///
                    ////////////////////////////////////////////////////////////
                    float getRotation() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the current scale of the object
                    ///
                    /// \return Current scale factors
                    ///
                    /// \see setScale
                    ///
                    ////////////////////////////////////////////////////////////
                    const Vector2f& getScale() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the local origin of the object
                    ///
                    /// \return Current origin
                    ///
                    /// \see setOrigin
                    ///
                    ////////////////////////////////////////////////////////////
                    const Vector2f& getOrigin() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Move the object by a given offset
                    ///
                    /// This function adds to the current position of the object,
                    /// unlike setPosition which overwrites it.
                    /// Thus, it is equivalent to the following code:
                    /// \code
                    /// sf::Vector2f pos = object.getPosition();
                    /// object.setPosition(pos.x + offsetX, pos.y + offsetY);
                    /// \endcode
                    ///
                    /// \param offsetX X offset
                    /// \param offsetY Y offset
                    ///
                    /// \see setPosition
                    ///
                    ////////////////////////////////////////////////////////////
                    void move(float offsetX, float offsetY);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Move the object by a given offset
                    ///
                    /// This function adds to the current position of the object,
                    /// unlike setPosition which overwrites it.
                    /// Thus, it is equivalent to the following code:
                    /// \code
                    /// object.setPosition(object.getPosition() + offset);
                    /// \endcode
                    ///
                    /// \param offset Offset
                    ///
                    /// \see setPosition
                    ///
                    ////////////////////////////////////////////////////////////
                    void move(const Vector2f& offset);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Rotate the object
                    ///
                    /// This function adds to the current rotation of the object,
                    /// unlike setRotation which overwrites it.
                    /// Thus, it is equivalent to the following code:
                    /// \code
                    /// object.setRotation(object.getRotation() + angle);
                    /// \endcode
                    ///
                    /// \param angle Angle of rotation, in degrees
                    ///
                    ////////////////////////////////////////////////////////////
                    void rotate(float angle);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Scale the object
                    ///
                    /// This function multiplies the current scale of the object,
                    /// unlike setScale which overwrites it.
                    /// Thus, it is equivalent to the following code:
                    /// \code
                    /// sf::Vector2f scale = object.getScale();
                    /// object.setScale(scale.x * factorX, scale.y * factorY);
                    /// \endcode
                    ///
                    /// \param factorX Horizontal scale factor
                    /// \param factorY Vertical scale factor
                    ///
                    /// \see setScale
                    ///
                    ////////////////////////////////////////////////////////////
                    void scale(float factorX, float factorY);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Scale the object
                    ///
                    /// This function multiplies the current scale of the object,
                    /// unlike setScale which overwrites it.
                    /// Thus, it is equivalent to the following code:
                    /// \code
                    /// sf::Vector2f scale = object.getScale();
                    /// object.setScale(scale.x * factor.x, scale.y * factor.y);
                    /// \endcode
                    ///
                    /// \param factor Scale factors
                    ///
                    /// \see setScale
                    ///
                    ////////////////////////////////////////////////////////////
                    void scale(const Vector2f& factor);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the combined transform of the object
                    ///
                    /// \return Transform combining the position/rotation/scale/origin of the object
                    ///
                    /// \see getInverseTransform
                    ///
                    ////////////////////////////////////////////////////////////
                    const Transform& getTransform() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief get the inverse of the combined transform of the object
                    ///
                    /// \return Inverse of the combined transformations applied to the object
                    ///
                    /// \see getTransform
                    ///
                    ////////////////////////////////////////////////////////////
                    const Transform& getInverseTransform() const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    Vector2f          m_origin;                     ///< Origin of translation/rotation/scaling of the object
                    Vector2f          m_position;                   ///< Position of the object in the 2D world
                    float             m_rotation;                   ///< Orientation of the object, in degrees
                    Vector2f          m_scale;                      ///< Scale of the object
                    mutable Transform m_transform;                  ///< Combined transformation of the object
                    mutable bool      m_transformNeedUpdate;        ///< Does the transform need to be recomputed?
                    mutable Transform m_inverseTransform;           ///< Combined transformation of the object
                    mutable bool      m_inverseTransformNeedUpdate; ///< Does the transform need to be recomputed?
                };
                
                } // namespace sf
                
                
                #endif // SFML_TRANSFORMABLE_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::Transformable
                /// \ingroup graphics
                ///
                /// This class is provided for convenience, on top of sf::Transform.
                ///
                /// sf::Transform, as a low-level class, offers a great level of
                /// flexibility but it is not always convenient to manage. Indeed,
                /// one can easily combine any kind of operation, such as a translation
                /// followed by a rotation followed by a scaling, but once the result
                /// transform is built, there's no way to go backward and, let's say,
                /// change only the rotation without modifying the translation and scaling.
                /// The entire transform must be recomputed, which means that you
                /// need to retrieve the initial translation and scale factors as
                /// well, and combine them the same way you did before updating the
                /// rotation. This is a tedious operation, and it requires to store
                /// all the individual components of the final transform.
                ///
                /// That's exactly what sf::Transformable was written for: it hides
                /// these variables and the composed transform behind an easy to use
                /// interface. You can set or get any of the individual components
                /// without worrying about the others. It also provides the composed
                /// transform (as a sf::Transform), and keeps it up-to-date.
                ///
                /// In addition to the position, rotation and scale, sf::Transformable
                /// provides an "origin" component, which represents the local origin
                /// of the three other components. Let's take an example with a 10x10
                /// pixels sprite. By default, the sprite is positioned/rotated/scaled
                /// relatively to its top-left corner, because it is the local point
                /// (0, 0). But if we change the origin to be (5, 5), the sprite will
                /// be positioned/rotated/scaled around its center instead. And if
                /// we set the origin to (10, 10), it will be transformed around its
                /// bottom-right corner.
                ///
                /// To keep the sf::Transformable class simple, there's only one
                /// origin for all the components. You cannot position the sprite
                /// relatively to its top-left corner while rotating it around its
                /// center, for example. To do such things, use sf::Transform directly.
                ///
                /// sf::Transformable can be used as a base class. It is often
                /// combined with sf::Drawable -- that's what SFML's sprites,
                /// texts and shapes do.
                /// \code
                /// class MyEntity : public sf::Transformable, public sf::Drawable
                /// {
                ///     virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const
                ///     {
                ///         states.transform *= getTransform();
                ///         target.draw(..., states);
                ///     }
                /// };
                ///
                /// MyEntity entity;
                /// entity.setPosition(10, 20);
                /// entity.setRotation(45);
                /// window.draw(entity);
                /// \endcode
                ///
                /// It can also be used as a member, if you don't want to use
                /// its API directly (because you don't need all its functions,
                /// or you have different naming conventions for example).
                /// \code
                /// class MyEntity
                /// {
                /// public:
                ///     void SetPosition(const MyVector& v)
                ///     {
                ///         myTransform.setPosition(v.x(), v.y());
                ///     }
                ///
                ///     void Draw(sf::RenderTarget& target) const
                ///     {
                ///         target.draw(..., myTransform.getTransform());
                ///     }
                ///
                /// private:
                ///     sf::Transformable myTransform;
                /// };
                /// \endcode
                ///
                /// A note on coordinates and undistorted rendering: \n
                /// By default, SFML (or more exactly, OpenGL) may interpolate drawable objects
                /// such as sprites or texts when rendering. While this allows transitions
                /// like slow movements or rotations to appear smoothly, it can lead to
                /// unwanted results in some cases, for example blurred or distorted objects.
                /// In order to render a sf::Drawable object pixel-perfectly, make sure
                /// the involved coordinates allow a 1:1 mapping of pixels in the window
                /// to texels (pixels in the texture). More specifically, this means:
                /// * The object's position, origin and scale have no fractional part
                /// * The object's and the view's rotation are a multiple of 90 degrees
                /// * The view's center and size have no fractional part
                ///
                /// \see sf::Transform
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       41      44171

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    44171   Total number of line executions
 44171.00   Average executions per line


*** File /usr/include/SFML/System/Vector2.inl:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T>::Vector2() :
                x(0),
                y(0)
                {
                
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
         199 -> inline Vector2<T>::Vector2(T X, T Y) :
                x(X),
                y(Y)
                {
                
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                template <typename U>
                inline Vector2<T>::Vector2(const Vector2<U>& vector) :
                x(static_cast<T>(vector.x)),
                y(static_cast<T>(vector.y))
                {
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator -(const Vector2<T>& right)
                {
                    return Vector2<T>(-right.x, -right.y);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T>& operator +=(Vector2<T>& left, const Vector2<T>& right)
                {
                    left.x += right.x;
                    left.y += right.y;
                
                    return left;
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T>& operator -=(Vector2<T>& left, const Vector2<T>& right)
                {
                    left.x -= right.x;
                    left.y -= right.y;
                
                    return left;
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator +(const Vector2<T>& left, const Vector2<T>& right)
                {
                    return Vector2<T>(left.x + right.x, left.y + right.y);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator -(const Vector2<T>& left, const Vector2<T>& right)
                {
                    return Vector2<T>(left.x - right.x, left.y - right.y);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator *(const Vector2<T>& left, T right)
                {
                    return Vector2<T>(left.x * right, left.y * right);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator *(T left, const Vector2<T>& right)
                {
                    return Vector2<T>(right.x * left, right.y * left);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T>& operator *=(Vector2<T>& left, T right)
                {
                    left.x *= right;
                    left.y *= right;
                
                    return left;
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T> operator /(const Vector2<T>& left, T right)
                {
                    return Vector2<T>(left.x / right, left.y / right);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline Vector2<T>& operator /=(Vector2<T>& left, T right)
                {
                    left.x /= right;
                    left.y /= right;
                
                    return left;
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline bool operator ==(const Vector2<T>& left, const Vector2<T>& right)
                {
                    return (left.x == right.x) && (left.y == right.y);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline bool operator !=(const Vector2<T>& left, const Vector2<T>& right)
                {
                    return (left.x != right.x) || (left.y != right.y);
                }


Top 10 Lines:

     Line      Count

       38        199

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      199   Total number of line executions
   199.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Node.h:
                #include "GameState.h"
                
                #ifndef NODE_H
                #define NODE_H
                
                class Node {
                public:
                    GameState state;
                    Action actionTaken;
                    bool AIturn;
                    Node* parent;
                    std::vector<Node*> children;
                    int wins;
                    int visits;
                
         834 ->     Node(GameState state, Action actionTaken, Node* parent, bool AIturn)
                        : state(state), actionTaken(actionTaken), parent(parent), wins(0), visits(0), AIturn(AIturn) {}
                };
                
                #endif

Top 10 Lines:

     Line      Count

       16        834

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      834   Total number of line executions
   834.00   Average executions per line


*** File /usr/include/c++/11/ext/type_traits.h:
                // -*- C++ -*-
                
                // Copyright (C) 2005-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the terms
                // of the GNU General Public License as published by the Free Software
                // Foundation; either version 3, or (at your option) any later
                // version.
                
                // This library is distributed in the hope that it will be useful, but
                // WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
                // General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/type_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_TYPE_TRAITS
                #define _EXT_TYPE_TRAITS 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                #include <bits/cpp_type_traits.h>
                
                extern "C++" {
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Define a nested type if some predicate holds.
                  template<bool, typename>
                    struct __enable_if 
                    { };
                
                  template<typename _Tp>
                    struct __enable_if<true, _Tp>
                    { typedef _Tp __type; };
                
                
                  // Conditional expression for types. If true, first, if false, second.
                  template<bool _Cond, typename _Iftrue, typename _Iffalse>
                    struct __conditional_type
                    { typedef _Iftrue __type; };
                
                  template<typename _Iftrue, typename _Iffalse>
                    struct __conditional_type<false, _Iftrue, _Iffalse>
                    { typedef _Iffalse __type; };
                
                
                  // Given an integral builtin type, return the corresponding unsigned type.
                  template<typename _Tp>
                    struct __add_unsigned
                    { 
                    private:
                      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
                      
                    public:
                      typedef typename __if_type::__type __type; 
                    };
                
                  template<>
                    struct __add_unsigned<char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __add_unsigned<signed char>
                    { typedef unsigned char __type; };
                
                  template<>
                    struct __add_unsigned<short>
                    { typedef unsigned short __type; };
                
                  template<>
                    struct __add_unsigned<int>
                    { typedef unsigned int __type; };
                
                  template<>
                    struct __add_unsigned<long>
                    { typedef unsigned long __type; };
                
                  template<>
                    struct __add_unsigned<long long>
                    { typedef unsigned long long __type; };
                
                  // Declare but don't define.
                  template<>
                    struct __add_unsigned<bool>;
                
                  template<>
                    struct __add_unsigned<wchar_t>;
                
                
                  // Given an integral builtin type, return the corresponding signed type.
                  template<typename _Tp>
                    struct __remove_unsigned
                    { 
                    private:
                      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
                      
                    public:
                      typedef typename __if_type::__type __type; 
                    };
                
                  template<>
                    struct __remove_unsigned<char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned char>
                    { typedef signed char __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned short>
                    { typedef short __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned int>
                    { typedef int __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned long>
                    { typedef long __type; };
                
                  template<>
                    struct __remove_unsigned<unsigned long long>
                    { typedef long long __type; };
                
                  // Declare but don't define.
                  template<>
                    struct __remove_unsigned<bool>;
                
                  template<>
                    struct __remove_unsigned<wchar_t>;
                
                
                  // For use in string and vstring.
                  template<typename _Type>
                    inline bool
        4563 ->     __is_null_pointer(_Type* __ptr)
                    { return __ptr == 0; }
                
                  template<typename _Type>
                    inline bool
                    __is_null_pointer(_Type)
                    { return false; }
                
                #if __cplusplus >= 201103L
                  inline bool
                  __is_null_pointer(std::nullptr_t)
                  { return true; }
                #endif
                
                  // For arithmetic promotions in <complex> and <cmath>
                
                  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
                    struct __promote
                    { typedef double __type; };
                
                  // No nested __type member for non-integer non-floating point types,
                  // allows this type to be used for SFINAE to constrain overloads in
                  // <cmath> and <complex> to only the intended types.
                  template<typename _Tp>
                    struct __promote<_Tp, false>
                    { };
                
                  template<>
                    struct __promote<long double>
                    { typedef long double __type; };
                
                  template<>
                    struct __promote<double>
                    { typedef double __type; };
                
                  template<>
                    struct __promote<float>
                    { typedef float __type; };
                
                #if __cpp_fold_expressions
                  template<typename... _Tp>
                    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));
                #endif
                
                  template<typename _Tp, typename _Up,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type>
                    struct __promote_2
                    {
                      typedef __typeof__(_Tp2() + _Up2()) __type;
                    };
                
                  template<typename _Tp, typename _Up, typename _Vp,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type,
                           typename _Vp2 = typename __promote<_Vp>::__type>
                    struct __promote_3
                    {
                      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
                    };
                
                  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
                           typename _Tp2 = typename __promote<_Tp>::__type,
                           typename _Up2 = typename __promote<_Up>::__type,
                           typename _Vp2 = typename __promote<_Vp>::__type,
                           typename _Wp2 = typename __promote<_Wp>::__type>
                    struct __promote_4
                    {
                      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                } // extern "C++"
                
                #endif 


Top 10 Lines:

     Line      Count

      152       4563

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     4563   Total number of line executions
  4563.00   Average executions per line


*** File /usr/include/c++/11/bits/char_traits.h:
                // Character Traits for use by standard string and iostream -*- C++ -*-
                
                // Copyright (C) 1997-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/char_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                #ifndef _CHAR_TRAITS_H
                #define _CHAR_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <bits/stl_algobase.h>  // std::copy, std::fill_n
                #include <bits/postypes.h>      // For streampos
                #include <cwchar>               // For WEOF, wmemmove, wmemset, etc.
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                #ifndef _GLIBCXX_ALWAYS_INLINE
                # define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief  Mapping from character type to associated types.
                   *
                   *  @note This is an implementation class for the generic version
                   *  of char_traits.  It defines int_type, off_type, pos_type, and
                   *  state_type.  By default these are unsigned long, streamoff,
                   *  streampos, and mbstate_t.  Users who need a different set of
                   *  types, but who don't need to change the definitions of any function
                   *  defined in char_traits, can specialize __gnu_cxx::_Char_types
                   *  while leaving __gnu_cxx::char_traits alone. */
                  template<typename _CharT>
                    struct _Char_types
                    {
                      typedef unsigned long   int_type;
                      typedef std::streampos  pos_type;
                      typedef std::streamoff  off_type;
                      typedef std::mbstate_t  state_type;
                    };
                
                
                  /**
                   *  @brief  Base class used to implement std::char_traits.
                   *
                   *  @note For any given actual character type, this definition is
                   *  probably wrong.  (Most of the member functions are likely to be
                   *  right, but the int_type and state_type typedefs, and the eof()
                   *  member function, are likely to be wrong.)  The reason this class
                   *  exists is so users can specialize it.  Classes in namespace std
                   *  may not be specialized for fundamental types, but classes in
                   *  namespace __gnu_cxx may be.
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
                   *  for advice on how to make use of this class for @a unusual character
                   *  types. Also, check out include/ext/pod_char_traits.h.  
                   */
                  template<typename _CharT>
                    struct char_traits
                    {
                      typedef _CharT                                    char_type;
                      typedef typename _Char_types<_CharT>::int_type    int_type;
                      typedef typename _Char_types<_CharT>::pos_type    pos_type;
                      typedef typename _Char_types<_CharT>::off_type    off_type;
                      typedef typename _Char_types<_CharT>::state_type  state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = std::strong_ordering;
                #endif
                
                      static _GLIBCXX14_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2)
                      { __c1 = __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
       ##### ->       eq(const char_type& __c1, const char_type& __c2)
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      lt(const char_type& __c1, const char_type& __c2)
                      { return __c1 < __c2; }
                
                      static _GLIBCXX14_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static _GLIBCXX14_CONSTEXPR std::size_t
                      length(const char_type* __s);
                
                      static _GLIBCXX14_CONSTEXPR const char_type*
                      find(const char_type* __s, std::size_t __n, const char_type& __a);
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, std::size_t __n, char_type __a);
                
                      static _GLIBCXX_CONSTEXPR char_type
                      to_char_type(const int_type& __c)
                      { return static_cast<char_type>(__c); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      to_int_type(const char_type& __c)
                      { return static_cast<int_type>(__c); }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq_int_type(const int_type& __c1, const int_type& __c2)
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      eof()
                      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      not_eof(const int_type& __c)
                      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
                    };
                
                  template<typename _CharT>
                    _GLIBCXX14_CONSTEXPR int
                    char_traits<_CharT>::
                    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      for (std::size_t __i = 0; __i < __n; ++__i)
                	if (lt(__s1[__i], __s2[__i]))
                	  return -1;
                	else if (lt(__s2[__i], __s1[__i]))
                	  return 1;
                      return 0;
                    }
                
                  template<typename _CharT>
                    _GLIBCXX14_CONSTEXPR std::size_t
       ##### ->     char_traits<_CharT>::
                    length(const char_type* __p)
                    {
                      std::size_t __i = 0;
                      while (!eq(__p[__i], char_type()))
                        ++__i;
                      return __i;
                    }
                
                  template<typename _CharT>
                    _GLIBCXX14_CONSTEXPR const typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    find(const char_type* __s, std::size_t __n, const char_type& __a)
                    {
                      for (std::size_t __i = 0; __i < __n; ++__i)
                        if (eq(__s[__i], __a))
                          return __s + __i;
                      return 0;
                    }
                
                  template<typename _CharT>
                    _GLIBCXX20_CONSTEXPR
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    move(char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      if (__n == 0)
                	return __s1;
                #if __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	{
                	  if (__s1 == __s2) // unlikely, but saves a lot of work
                	    return __s1;
                #if __cpp_constexpr_dynamic_alloc
                	  // The overlap detection below fails due to PR c++/89074,
                	  // so use a temporary buffer instead.
                	  char_type* __tmp = new char_type[__n];
                	  copy(__tmp, __s2, __n);
                	  copy(__s1, __tmp, __n);
                	  delete[] __tmp;
                #else
                	  const auto __end = __s2 + __n - 1;
                	  bool __overlap = false;
                	  for (std::size_t __i = 0; __i < __n - 1; ++__i)
                	    {
                	      if (__s1 + __i == __end)
                		{
                		  __overlap = true;
                		  break;
                		}
                	    }
                	  if (__overlap)
                	    {
                	      do
                		{
                		  --__n;
                		  assign(__s1[__n], __s2[__n]);
                		}
                	      while (__n > 0);
                	    }
                	  else
                	    copy(__s1, __s2, __n);
                #endif
                	  return __s1;
                	}
                #endif
                      __builtin_memmove(__s1, __s2, __n * sizeof(char_type));
                      return __s1;
                    }
                
                  template<typename _CharT>
                    _GLIBCXX20_CONSTEXPR
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
                    {
                      // NB: Inline std::copy so no recursive dependencies.
                      std::copy(__s2, __s2 + __n, __s1);
                      return __s1;
                    }
                
                  template<typename _CharT>
                    _GLIBCXX20_CONSTEXPR
                    typename char_traits<_CharT>::char_type*
                    char_traits<_CharT>::
                    assign(char_type* __s, std::size_t __n, char_type __a)
                    {
                      // NB: Inline std::fill_n so no recursive dependencies.
                      std::fill_n(__s, __n, __a);
                      return __s;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201703L
                
                #ifdef __cpp_lib_is_constant_evaluated
                // Unofficial macro indicating P1032R1 support in C++20
                # define __cpp_lib_constexpr_char_traits 201811L
                #else
                // Unofficial macro indicating P0426R1 support in C++17
                # define __cpp_lib_constexpr_char_traits 201611L
                #endif
                
                  /**
                   *  @brief Determine whether the characters of a NULL-terminated
                   *  string are known at compile time.
                   *  @param  __s  The string.
                   *
                   *  Assumes that _CharT is a built-in character type.
                   */
                  template<typename _CharT>
                    _GLIBCXX_ALWAYS_INLINE constexpr bool
                    __constant_string_p(const _CharT* __s)
                    {
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                      (void) __s;
                      // In constexpr contexts all strings should be constant.
                      return __builtin_is_constant_evaluated();
                #else
                      while (__builtin_constant_p(*__s) && *__s)
                	__s++;
                      return __builtin_constant_p(*__s);
                #endif
                    }
                
                  /**
                   *  @brief Determine whether the characters of a character array are
                   *  known at compile time.
                   *  @param  __a  The character array.
                   *  @param  __n  Number of characters.
                   *
                   *  Assumes that _CharT is a built-in character type.
                   */
                  template<typename _CharT>
                    _GLIBCXX_ALWAYS_INLINE constexpr bool
                    __constant_char_array_p(const _CharT* __a, size_t __n)
                    {
                #ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
                      (void) __a;
                      (void) __n;
                      // In constexpr contexts all character arrays should be constant.
                      return __builtin_is_constant_evaluated();
                #else
                      size_t __i = 0;
                      while (__i < __n && __builtin_constant_p(__a[__i]))
                	__i++;
                      return __i == __n;
                #endif
                    }
                #endif
                
                  // 21.1
                  /**
                   *  @brief  Basis for explicit traits specializations.
                   *
                   *  @note  For any given actual character type, this definition is
                   *  probably wrong.  Since this is just a thin wrapper around
                   *  __gnu_cxx::char_traits, it is possible to achieve a more
                   *  appropriate definition by specializing __gnu_cxx::char_traits.
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/strings.html#strings.string.character_types
                   *  for advice on how to make use of this class for @a unusual character
                   *  types. Also, check out include/ext/pod_char_traits.h.
                  */
                  template<class _CharT>
                    struct char_traits : public __gnu_cxx::char_traits<_CharT>
                    { };
                
                
                  /// 21.1.3.1  char_traits specializations
                  template<>
                    struct char_traits<char>
                    {
                      typedef char              char_type;
                      typedef int               int_type;
                      typedef streampos         pos_type;
                      typedef streamoff         off_type;
                      typedef mbstate_t         state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = strong_ordering;
                #endif
                
                      static _GLIBCXX17_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { __c1 = __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      {
                	// LWG 467.
                	return (static_cast<unsigned char>(__c1)
                		< static_cast<unsigned char>(__c2));
                      }
                
                      static _GLIBCXX17_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus >= 201703L
                	if (__builtin_constant_p(__n)
                	    && __constant_char_array_p(__s1, __n)
                	    && __constant_char_array_p(__s2, __n))
                	  {
                	    for (size_t __i = 0; __i < __n; ++__i)
                	      if (lt(__s1[__i], __s2[__i]))
                		return -1;
                	      else if (lt(__s2[__i], __s1[__i]))
                		return 1;
                	    return 0;
                	  }
                #endif
                	return __builtin_memcmp(__s1, __s2, __n);
                      }
                
                      static _GLIBCXX17_CONSTEXPR size_t
        4563 ->       length(const char_type* __s)
                      {
                #if __cplusplus >= 201703L
                	if (__constant_string_p(__s))
                	  return __gnu_cxx::char_traits<char_type>::length(__s);
                #endif
                	return __builtin_strlen(__s);
                      }
                
                      static _GLIBCXX17_CONSTEXPR const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus >= 201703L
                	if (__builtin_constant_p(__n)
                	    && __builtin_constant_p(__a)
                	    && __constant_char_array_p(__s, __n))
                	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
                #endif
                	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
                #endif
                	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
                #endif
                	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      {
                	if (__n == 0)
                	  return __s;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
                #endif
                	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
                      }
                
                      static _GLIBCXX_CONSTEXPR char_type
                      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return static_cast<char_type>(__c); }
                
                      // To keep both the byte 0xff and the eof symbol 0xffffffff
                      // from ending up as 0xffffffff.
                      static _GLIBCXX_CONSTEXPR int_type
                      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
                      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      eof() _GLIBCXX_NOEXCEPT
                      { return static_cast<int_type>(_GLIBCXX_STDIO_EOF); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return (__c == eof()) ? 0 : __c; }
                  };
                
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// 21.1.3.2  char_traits specializations
                  template<>
                    struct char_traits<wchar_t>
                    {
                      typedef wchar_t           char_type;
                      typedef wint_t            int_type;
                      typedef streamoff         off_type;
                      typedef wstreampos        pos_type;
                      typedef mbstate_t         state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = strong_ordering;
                #endif
                
                      static _GLIBCXX17_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { __c1 = __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 < __c2; }
                
                      static _GLIBCXX17_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus >= 201703L
                	if (__builtin_constant_p(__n)
                	    && __constant_char_array_p(__s1, __n)
                	    && __constant_char_array_p(__s2, __n))
                	  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
                #endif
                	return wmemcmp(__s1, __s2, __n);
                      }
                
                      static _GLIBCXX17_CONSTEXPR size_t
                      length(const char_type* __s)
                      {
                #if __cplusplus >= 201703L
                	if (__constant_string_p(__s))
                	  return __gnu_cxx::char_traits<char_type>::length(__s);
                #endif
                	return wcslen(__s);
                      }
                
                      static _GLIBCXX17_CONSTEXPR const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus >= 201703L
                	if (__builtin_constant_p(__n)
                	    && __builtin_constant_p(__a)
                	    && __constant_char_array_p(__s, __n))
                	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
                #endif
                	return wmemchr(__s, __a, __n);
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
                #endif
                	return wmemmove(__s1, __s2, __n);
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
                #endif
                	return wmemcpy(__s1, __s2, __n);
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      {
                	if (__n == 0)
                	  return __s;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
                #endif
                	return wmemset(__s, __a, __n);
                      }
                
                      static _GLIBCXX_CONSTEXPR char_type
                      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return char_type(__c); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
                      { return int_type(__c); }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      eof() _GLIBCXX_NOEXCEPT
                      { return static_cast<int_type>(WEOF); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return eq_int_type(__c, eof()) ? 0 : __c; }
                  };
                #endif //_GLIBCXX_USE_WCHAR_T
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct char_traits<char8_t>
                    {
                      typedef char8_t           char_type;
                      typedef unsigned int      int_type;
                      typedef u8streampos       pos_type;
                      typedef streamoff         off_type;
                      typedef mbstate_t         state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = strong_ordering;
                #endif
                
                      static _GLIBCXX17_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { __c1 = __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR bool
                      lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 < __c2; }
                
                      static _GLIBCXX17_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus > 201402
                	if (__builtin_constant_p(__n)
                	    && __constant_char_array_p(__s1, __n)
                	    && __constant_char_array_p(__s2, __n))
                	  return __gnu_cxx::char_traits<char_type>::compare(__s1, __s2, __n);
                #endif
                	return __builtin_memcmp(__s1, __s2, __n);
                      }
                
                      static _GLIBCXX17_CONSTEXPR size_t
                      length(const char_type* __s)
                      {
                #if __cplusplus > 201402
                	if (__constant_string_p(__s))
                	  return __gnu_cxx::char_traits<char_type>::length(__s);
                #endif
                	size_t __i = 0;
                	while (!eq(__s[__i], char_type()))
                	  ++__i;
                	return __i;
                      }
                
                      static _GLIBCXX17_CONSTEXPR const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      {
                	if (__n == 0)
                	  return 0;
                #if __cplusplus > 201402
                	if (__builtin_constant_p(__n)
                	    && __builtin_constant_p(__a)
                	    && __constant_char_array_p(__s, __n))
                	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
                #endif
                	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
                #endif
                	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
                #endif
                	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      {
                	if (__n == 0)
                	  return __s;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
                #endif
                	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
                      }
                
                      static _GLIBCXX_CONSTEXPR char_type
                      to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return char_type(__c); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      to_int_type(const char_type& __c) _GLIBCXX_NOEXCEPT
                      { return int_type(__c); }
                
                      static _GLIBCXX_CONSTEXPR bool
                      eq_int_type(const int_type& __c1, const int_type& __c2) _GLIBCXX_NOEXCEPT
                      { return __c1 == __c2; }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      eof() _GLIBCXX_NOEXCEPT
                      { return static_cast<int_type>(-1); }
                
                      static _GLIBCXX_CONSTEXPR int_type
                      not_eof(const int_type& __c) _GLIBCXX_NOEXCEPT
                      { return eq_int_type(__c, eof()) ? 0 : __c; }
                    };
                #endif //_GLIBCXX_USE_CHAR8_T
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                
                #include <cstdint>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<>
                    struct char_traits<char16_t>
                    {
                      typedef char16_t          char_type;
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                      typedef uint_least16_t    int_type;
                #elif defined __UINT_LEAST16_TYPE__
                      typedef __UINT_LEAST16_TYPE__	    int_type;
                #else
                      typedef make_unsigned<char16_t>::type int_type;
                #endif
                      typedef streamoff         off_type;
                      typedef u16streampos      pos_type;
                      typedef mbstate_t         state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = strong_ordering;
                #endif
                
                      static _GLIBCXX17_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2) noexcept
                      { __c1 = __c2; }
                
                      static constexpr bool
                      eq(const char_type& __c1, const char_type& __c2) noexcept
                      { return __c1 == __c2; }
                
                      static constexpr bool
                      lt(const char_type& __c1, const char_type& __c2) noexcept
                      { return __c1 < __c2; }
                
                      static _GLIBCXX17_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  if (lt(__s1[__i], __s2[__i]))
                	    return -1;
                	  else if (lt(__s2[__i], __s1[__i]))
                	    return 1;
                	return 0;
                      }
                
                      static _GLIBCXX17_CONSTEXPR size_t
                      length(const char_type* __s)
                      {
                	size_t __i = 0;
                	while (!eq(__s[__i], char_type()))
                	  ++__i;
                	return __i;
                      }
                
                      static _GLIBCXX17_CONSTEXPR const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  if (eq(__s[__i], __a))
                	    return __s + __i;
                	return 0;
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
                #endif
                	return (static_cast<char_type*>
                		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
                #endif
                	return (static_cast<char_type*>
                		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  assign(__s[__i], __a);
                	return __s;
                      }
                
                      static constexpr char_type
                      to_char_type(const int_type& __c) noexcept
                      { return char_type(__c); }
                
                      static constexpr int_type
                      to_int_type(const char_type& __c) noexcept
                      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }
                
                      static constexpr bool
                      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
                      { return __c1 == __c2; }
                
                      static constexpr int_type
                      eof() noexcept
                      { return static_cast<int_type>(-1); }
                
                      static constexpr int_type
                      not_eof(const int_type& __c) noexcept
                      { return eq_int_type(__c, eof()) ? 0 : __c; }
                    };
                
                  template<>
                    struct char_traits<char32_t>
                    {
                      typedef char32_t          char_type;
                #ifdef _GLIBCXX_USE_C99_STDINT_TR1
                      typedef uint_least32_t    int_type;
                #elif defined __UINT_LEAST32_TYPE__
                      typedef __UINT_LEAST32_TYPE__	    int_type;
                #else
                      typedef make_unsigned<char32_t>::type int_type;
                #endif
                      typedef streamoff         off_type;
                      typedef u32streampos      pos_type;
                      typedef mbstate_t         state_type;
                #if __cpp_lib_three_way_comparison
                      using comparison_category = strong_ordering;
                #endif
                
                      static _GLIBCXX17_CONSTEXPR void
                      assign(char_type& __c1, const char_type& __c2) noexcept
                      { __c1 = __c2; }
                
                      static constexpr bool
                      eq(const char_type& __c1, const char_type& __c2) noexcept
                      { return __c1 == __c2; }
                
                      static constexpr bool
                      lt(const char_type& __c1, const char_type& __c2) noexcept
                      { return __c1 < __c2; }
                
                      static _GLIBCXX17_CONSTEXPR int
                      compare(const char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  if (lt(__s1[__i], __s2[__i]))
                	    return -1;
                	  else if (lt(__s2[__i], __s1[__i]))
                	    return 1;
                	return 0;
                      }
                
                      static _GLIBCXX17_CONSTEXPR size_t
                      length(const char_type* __s)
                      {
                	size_t __i = 0;
                	while (!eq(__s[__i], char_type()))
                	  ++__i;
                	return __i;
                      }
                
                      static _GLIBCXX17_CONSTEXPR const char_type*
                      find(const char_type* __s, size_t __n, const char_type& __a)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  if (eq(__s[__i], __a))
                	    return __s + __i;
                	return 0;
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      move(char_type* __s1, const char_type* __s2, size_t __n)
                      {
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
                #endif
                	return (static_cast<char_type*>
                		(__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      copy(char_type* __s1, const char_type* __s2, size_t __n)
                      { 
                	if (__n == 0)
                	  return __s1;
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
                #endif
                	return (static_cast<char_type*>
                		(__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
                      }
                
                      static _GLIBCXX20_CONSTEXPR char_type*
                      assign(char_type* __s, size_t __n, char_type __a)
                      {
                	for (size_t __i = 0; __i < __n; ++__i)
                	  assign(__s[__i], __a);
                	return __s;
                      }
                
                      static constexpr char_type
                      to_char_type(const int_type& __c) noexcept
                      { return char_type(__c); }
                
                      static constexpr int_type
                      to_int_type(const char_type& __c) noexcept
                      { return int_type(__c); }
                
                      static constexpr bool
                      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
                      { return __c1 == __c2; }
                
                      static constexpr int_type
                      eof() noexcept
                      { return static_cast<int_type>(-1); }
                
                      static constexpr int_type
                      not_eof(const int_type& __c) noexcept
                      { return eq_int_type(__c, eof()) ? 0 : __c; }
                    };
                
                #if __cpp_lib_three_way_comparison
                  namespace __detail
                  {
                    template<typename _ChTraits>
                      constexpr auto
                      __char_traits_cmp_cat(int __cmp) noexcept
                      {
                	if constexpr (requires { typename _ChTraits::comparison_category; })
                	  {
                	    using _Cat = typename _ChTraits::comparison_category;
                	    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );
                	    return static_cast<_Cat>(__cmp <=> 0);
                	  }
                	else
                	  return static_cast<weak_ordering>(__cmp <=> 0);
                      }
                  } // namespace __detail
                #endif // C++20
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif  // C++11
                
                #endif // _CHAR_TRAITS_H


Top 10 Lines:

     Line      Count

      393       4563

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     4563   Total number of line executions
  1521.00   Average executions per line


*** File /usr/include/SFML/Graphics/Rect.inl:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
        9396 -> Rect<T>::Rect() :
                left  (0),
                top   (0),
                width (0),
                height(0)
                {
                
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                Rect<T>::Rect(T rectLeft, T rectTop, T rectWidth, T rectHeight) :
                left  (rectLeft),
                top   (rectTop),
                width (rectWidth),
                height(rectHeight)
                {
                
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                Rect<T>::Rect(const Vector2<T>& position, const Vector2<T>& size) :
                left  (position.x),
                top   (position.y),
                width (size.x),
                height(size.y)
                {
                
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                template <typename U>
                Rect<T>::Rect(const Rect<U>& rectangle) :
                left  (static_cast<T>(rectangle.left)),
                top   (static_cast<T>(rectangle.top)),
                width (static_cast<T>(rectangle.width)),
                height(static_cast<T>(rectangle.height))
                {
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                bool Rect<T>::contains(T x, T y) const
                {
                    // Rectangles with negative dimensions are allowed, so we must handle them correctly
                
                    // Compute the real min and max of the rectangle on both axes
                    T minX = std::min(left, static_cast<T>(left + width));
                    T maxX = std::max(left, static_cast<T>(left + width));
                    T minY = std::min(top, static_cast<T>(top + height));
                    T maxY = std::max(top, static_cast<T>(top + height));
                
                    return (x >= minX) && (x < maxX) && (y >= minY) && (y < maxY);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                bool Rect<T>::contains(const Vector2<T>& point) const
                {
                    return contains(point.x, point.y);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                bool Rect<T>::intersects(const Rect<T>& rectangle) const
                {
                    Rect<T> intersection;
                    return intersects(rectangle, intersection);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                bool Rect<T>::intersects(const Rect<T>& rectangle, Rect<T>& intersection) const
                {
                    // Rectangles with negative dimensions are allowed, so we must handle them correctly
                
                    // Compute the min and max of the first rectangle on both axes
                    T r1MinX = std::min(left, static_cast<T>(left + width));
                    T r1MaxX = std::max(left, static_cast<T>(left + width));
                    T r1MinY = std::min(top, static_cast<T>(top + height));
                    T r1MaxY = std::max(top, static_cast<T>(top + height));
                
                    // Compute the min and max of the second rectangle on both axes
                    T r2MinX = std::min(rectangle.left, static_cast<T>(rectangle.left + rectangle.width));
                    T r2MaxX = std::max(rectangle.left, static_cast<T>(rectangle.left + rectangle.width));
                    T r2MinY = std::min(rectangle.top, static_cast<T>(rectangle.top + rectangle.height));
                    T r2MaxY = std::max(rectangle.top, static_cast<T>(rectangle.top + rectangle.height));
                
                    // Compute the intersection boundaries
                    T interLeft   = std::max(r1MinX, r2MinX);
                    T interTop    = std::max(r1MinY, r2MinY);
                    T interRight  = std::min(r1MaxX, r2MaxX);
                    T interBottom = std::min(r1MaxY, r2MaxY);
                
                    // If the intersection is valid (positive non zero area), then there is an intersection
                    if ((interLeft < interRight) && (interTop < interBottom))
                    {
                        intersection = Rect<T>(interLeft, interTop, interRight - interLeft, interBottom - interTop);
                        return true;
                    }
                    else
                    {
                        intersection = Rect<T>(0, 0, 0, 0);
                        return false;
                    }
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline bool operator ==(const Rect<T>& left, const Rect<T>& right)
                {
                    return (left.left == right.left) && (left.width == right.width) &&
                           (left.top == right.top) && (left.height == right.height);
                }
                
                
                ////////////////////////////////////////////////////////////
                template <typename T>
                inline bool operator !=(const Rect<T>& left, const Rect<T>& right)
                {
                    return !(left == right);
                }


Top 10 Lines:

     Line      Count

       28       9396

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     9396   Total number of line executions
  9396.00   Average executions per line


*** File /usr/include/c++/11/bits/predefined_ops.h:
                // Default predicates for internal use -*- C++ -*-
                
                // Copyright (C) 2013-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file predefined_ops.h
                 *  This is an internal header file, included by other library headers.
                 *  You should not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _GLIBCXX_PREDEFINED_OPS_H
                #define _GLIBCXX_PREDEFINED_OPS_H	1
                
                #include <bits/move.h>
                
                namespace __gnu_cxx
                {
                namespace __ops
                {
                  struct _Iter_less_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      _GLIBCXX14_CONSTEXPR
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 < *__it2; }
                  };
                
                  _GLIBCXX14_CONSTEXPR
                  inline _Iter_less_iter
                  __iter_less_iter()
                  { return _Iter_less_iter(); }
                
                  struct _Iter_less_val
                  {
                #if __cplusplus >= 201103L
                    constexpr _Iter_less_val() = default;
                #else
                    _Iter_less_val() { }
                #endif
                
                    _GLIBCXX20_CONSTEXPR
                    explicit
                    _Iter_less_val(_Iter_less_iter) { }
                
                    template<typename _Iterator, typename _Value>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it < __val; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_less_val
                  __iter_less_val()
                  { return _Iter_less_val(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_less_val
                  __iter_comp_val(_Iter_less_iter)
                  { return _Iter_less_val(); }
                
                  struct _Val_less_iter
                  {
                #if __cplusplus >= 201103L
                    constexpr _Val_less_iter() = default;
                #else
                    _Val_less_iter() { }
                #endif
                
                    _GLIBCXX20_CONSTEXPR
                    explicit
                    _Val_less_iter(_Iter_less_iter) { }
                
                    template<typename _Value, typename _Iterator>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Value& __val, _Iterator __it) const
                      { return __val < *__it; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Val_less_iter
                  __val_less_iter()
                  { return _Val_less_iter(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Val_less_iter
                  __val_comp_iter(_Iter_less_iter)
                  { return _Val_less_iter(); }
                
                  struct _Iter_equal_to_iter
                  {
                    template<typename _Iterator1, typename _Iterator2>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator1 __it1, _Iterator2 __it2) const
                      { return *__it1 == *__it2; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_iter
                  __iter_equal_to_iter()
                  { return _Iter_equal_to_iter(); }
                
                  struct _Iter_equal_to_val
                  {
                    template<typename _Iterator, typename _Value>
                      _GLIBCXX20_CONSTEXPR
                      bool
                      operator()(_Iterator __it, _Value& __val) const
                      { return *__it == __val; }
                  };
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_val
                  __iter_equal_to_val()
                  { return _Iter_equal_to_val(); }
                
                  _GLIBCXX20_CONSTEXPR
                  inline _Iter_equal_to_val
                  __iter_comp_val(_Iter_equal_to_iter)
                  { return _Iter_equal_to_val(); }
                
                  template<typename _Compare>
                    struct _Iter_comp_iter
                    {
                      _Compare _M_comp;
                
                      explicit _GLIBCXX14_CONSTEXPR
                      _Iter_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      template<typename _Iterator1, typename _Iterator2>
                        _GLIBCXX14_CONSTEXPR
                        bool
                        operator()(_Iterator1 __it1, _Iterator2 __it2)
                        { return bool(_M_comp(*__it1, *__it2)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline _Iter_comp_iter<_Compare>
                    __iter_comp_iter(_Compare __comp)
                    { return _Iter_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Iter_comp_val
                    {
                      _Compare _M_comp;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_comp_val(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Iterator, typename _Value>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it, _Value& __val)
                	{ return bool(_M_comp(*__it, __val)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Compare __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_val<_Compare>
                    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
                    { return _Iter_comp_val<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    struct _Val_comp_iter
                    {
                      _Compare _M_comp;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Val_comp_iter(_Compare __comp)
                	: _M_comp(_GLIBCXX_MOVE(__comp))
                      { }
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
                	: _M_comp(__comp._M_comp)
                      { }
                
                #if __cplusplus >= 201103L
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
                	: _M_comp(std::move(__comp._M_comp))
                      { }
                #endif
                
                      template<typename _Value, typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Value& __val, _Iterator __it)
                	{ return bool(_M_comp(__val, *__it)); }
                    };
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Val_comp_iter<_Compare>
                    __val_comp_iter(_Compare __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline _Val_comp_iter<_Compare>
                    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
                    { return _Val_comp_iter<_Compare>(_GLIBCXX_MOVE(__comp)); }
                
                  template<typename _Value>
                    struct _Iter_equals_val
                    {
                      _Value& _M_value;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
         750 ->       _Iter_equals_val(_Value& __value)
                	: _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
        2187 -> 	operator()(_Iterator __it)
                	{ return *__it == _M_value; }
                    };
                
                  template<typename _Value>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_equals_val<_Value>
         750 ->     __iter_equals_val(_Value& __val)
                    { return _Iter_equals_val<_Value>(__val); }
                
                  template<typename _Iterator1>
                    struct _Iter_equals_iter
                    {
                      _Iterator1 _M_it1;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_equals_iter(_Iterator1 __it1)
                	: _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator2 __it2)
                	{ return *__it2 == *_M_it1; }
                    };
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_equals_iter<_Iterator>
                    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
                    { return _Iter_equals_iter<_Iterator>(__it); }
                
                  template<typename _Predicate>
                    struct _Iter_pred
                    {
                      _Predicate _M_pred;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_pred(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_pred<_Predicate>
                    __pred_iter(_Predicate __pred)
                    { return _Iter_pred<_Predicate>(_GLIBCXX_MOVE(__pred)); }
                
                  template<typename _Compare, typename _Value>
                    struct _Iter_comp_to_val
                    {
                      _Compare _M_comp;
                      _Value& _M_value;
                
                      _GLIBCXX20_CONSTEXPR
                      _Iter_comp_to_val(_Compare __comp, _Value& __value)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_value(__value)
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return bool(_M_comp(*__it, _M_value)); }
                    };
                
                  template<typename _Compare, typename _Value>
                    _Iter_comp_to_val<_Compare, _Value>
                    _GLIBCXX20_CONSTEXPR
                    __iter_comp_val(_Compare __comp, _Value &__val)
                    {
                      return _Iter_comp_to_val<_Compare, _Value>(_GLIBCXX_MOVE(__comp), __val);
                    }
                
                  template<typename _Compare, typename _Iterator1>
                    struct _Iter_comp_to_iter
                    {
                      _Compare _M_comp;
                      _Iterator1 _M_it1;
                
                      _GLIBCXX20_CONSTEXPR
                      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
                	: _M_comp(_GLIBCXX_MOVE(__comp)), _M_it1(__it1)
                      { }
                
                      template<typename _Iterator2>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator2 __it2)
                	{ return bool(_M_comp(*__it2, *_M_it1)); }
                    };
                
                  template<typename _Compare, typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_comp_to_iter<_Compare, _Iterator>
                    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
                    {
                      return _Iter_comp_to_iter<_Compare, _Iterator>(
                	  _GLIBCXX_MOVE(__comp._M_comp), __it);
                    }
                
                  template<typename _Predicate>
                    struct _Iter_negate
                    {
                      _Predicate _M_pred;
                
                      _GLIBCXX20_CONSTEXPR
                      explicit
                      _Iter_negate(_Predicate __pred)
                	: _M_pred(_GLIBCXX_MOVE(__pred))
                      { }
                
                      template<typename _Iterator>
                	_GLIBCXX20_CONSTEXPR
                	bool
                	operator()(_Iterator __it)
                	{ return !bool(_M_pred(*__it)); }
                    };
                
                  template<typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iter_negate<_Predicate>
                    __negate(_Iter_pred<_Predicate> __pred)
                    { return _Iter_negate<_Predicate>(_GLIBCXX_MOVE(__pred._M_pred)); }
                
                } // namespace __ops
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

      269       2187
      262        750
      276        750

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

     3687   Total number of line executions
  1229.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/fast_log.hpp:
                #pragma once
                
                class fast_log
                {
                public:
                  fast_log(int mantissa_nb_bits = 11);
                  ~fast_log();
                  inline float log(float v) const;
                private:
                  union int_float
                  {
                    int _int;
                    float _float;
                  };
                  float* lookup_table;
                  const int mantissa_shift;
                  const int MAX_MANTISSA_NB_BITS = 23;
                };
                
                float fast_log::log(float val) const
       17745 -> {
                  int_float x;
                  x._float = val;
                  int exponent = ((x._int >> MAX_MANTISSA_NB_BITS) & 255) - 127;
                  x._int &= 0x7FFFFF;
                  x._int >>= mantissa_shift;
                  return (lookup_table[x._int] + float(exponent)) * 0.69314718f;
                }


Top 10 Lines:

     Line      Count

       21      17745

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    17745   Total number of line executions
 17745.00   Average executions per line


*** File /usr/include/SFML/Graphics/VertexArray.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_VERTEXARRAY_HPP
                #define SFML_VERTEXARRAY_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/Vertex.hpp>
                #include <SFML/Graphics/PrimitiveType.hpp>
                #include <SFML/Graphics/Rect.hpp>
                #include <SFML/Graphics/Drawable.hpp>
                #include <vector>
                
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Define a set of one or more 2D primitives
                ///
                ////////////////////////////////////////////////////////////
        1592 -> class SFML_GRAPHICS_API VertexArray : public Drawable
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// Creates an empty vertex array.
                    ///
                    ////////////////////////////////////////////////////////////
                    VertexArray();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct the vertex array with a type and an initial number of vertices
                    ///
                    /// \param type        Type of primitives
                    /// \param vertexCount Initial number of vertices in the array
                    ///
                    ////////////////////////////////////////////////////////////
                    explicit VertexArray(PrimitiveType type, std::size_t vertexCount = 0);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return the vertex count
                    ///
                    /// \return Number of vertices in the array
                    ///
                    ////////////////////////////////////////////////////////////
                    std::size_t getVertexCount() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get a read-write access to a vertex by its index
                    ///
                    /// This function doesn't check \a index, it must be in range
                    /// [0, getVertexCount() - 1]. The behavior is undefined
                    /// otherwise.
                    ///
                    /// \param index Index of the vertex to get
                    ///
                    /// \return Reference to the index-th vertex
                    ///
                    /// \see getVertexCount
                    ///
                    ////////////////////////////////////////////////////////////
                    Vertex& operator [](std::size_t index);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get a read-only access to a vertex by its index
                    ///
                    /// This function doesn't check \a index, it must be in range
                    /// [0, getVertexCount() - 1]. The behavior is undefined
                    /// otherwise.
                    ///
                    /// \param index Index of the vertex to get
                    ///
                    /// \return Const reference to the index-th vertex
                    ///
                    /// \see getVertexCount
                    ///
                    ////////////////////////////////////////////////////////////
                    const Vertex& operator [](std::size_t index) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Clear the vertex array
                    ///
                    /// This function removes all the vertices from the array.
                    /// It doesn't deallocate the corresponding memory, so that
                    /// adding new vertices after clearing doesn't involve
                    /// reallocating all the memory.
                    ///
                    ////////////////////////////////////////////////////////////
                    void clear();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Resize the vertex array
                    ///
                    /// If \a vertexCount is greater than the current size, the previous
                    /// vertices are kept and new (default-constructed) vertices are
                    /// added.
                    /// If \a vertexCount is less than the current size, existing vertices
                    /// are removed from the array.
                    ///
                    /// \param vertexCount New size of the array (number of vertices)
                    ///
                    ////////////////////////////////////////////////////////////
                    void resize(std::size_t vertexCount);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Add a vertex to the array
                    ///
                    /// \param vertex Vertex to add
                    ///
                    ////////////////////////////////////////////////////////////
                    void append(const Vertex& vertex);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the type of primitives to draw
                    ///
                    /// This function defines how the vertices must be interpreted
                    /// when it's time to draw them:
                    /// \li As points
                    /// \li As lines
                    /// \li As triangles
                    /// \li As quads
                    /// The default primitive type is sf::Points.
                    ///
                    /// \param type Type of primitive
                    ///
                    ////////////////////////////////////////////////////////////
                    void setPrimitiveType(PrimitiveType type);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the type of primitives drawn by the vertex array
                    ///
                    /// \return Primitive type
                    ///
                    ////////////////////////////////////////////////////////////
                    PrimitiveType getPrimitiveType() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Compute the bounding rectangle of the vertex array
                    ///
                    /// This function returns the minimal axis-aligned rectangle
                    /// that contains all the vertices of the array.
                    ///
                    /// \return Bounding rectangle of the vertex array
                    ///
                    ////////////////////////////////////////////////////////////
                    FloatRect getBounds() const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Draw the vertex array to a render target
                    ///
                    /// \param target Render target to draw to
                    /// \param states Current render states
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual void draw(RenderTarget& target, RenderStates states) const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    std::vector<Vertex> m_vertices;      ///< Vertices contained in the array
                    PrimitiveType       m_primitiveType; ///< Type of primitives to draw
                };
                
                } // namespace sf
                
                
                #endif // SFML_VERTEXARRAY_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::VertexArray
                /// \ingroup graphics
                ///
                /// sf::VertexArray is a very simple wrapper around a dynamic
                /// array of vertices and a primitives type.
                ///
                /// It inherits sf::Drawable, but unlike other drawables it
                /// is not transformable.
                ///
                /// Example:
                /// \code
                /// sf::VertexArray lines(sf::LineStrip, 4);
                /// lines[0].position = sf::Vector2f(10, 0);
                /// lines[1].position = sf::Vector2f(20, 0);
                /// lines[2].position = sf::Vector2f(30, 5);
                /// lines[3].position = sf::Vector2f(40, 2);
                ///
                /// window.draw(lines);
                /// \endcode
                ///
                /// \see sf::Vertex
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       45       1592

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1592   Total number of line executions
  1592.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Bomb.h:
                #ifndef BOMB_H
                #define BOMB_H
                
                #include <SFML/Graphics.hpp>
                #include "Level.h"
                #include "Player.h"
                #include "Bonus.h"
                #include <optional>
                
                #define DEFAULT_BOMB_TIMER 3
                
       25197 -> class Bomb
                {
                private:
                    int x;
                    int y;
                    int time_left;
                    int strength;
                    sf::Texture texture;
                    sf::Sprite sprite;
                
                    std::optional<int> owner;
                
                    static std::vector<std::string> *bombTextures;
                
                public:
                    Bomb();
                    Bomb(int x, int y, int timer, int strength, std::optional<int> owner);
                    void draw(sf::RenderWindow &window, int zoom);
                    // return a vector of all the positions that require a flame
                    std::vector<std::pair<int, int>> explode(GameState &state);
                    void update();
       21440 ->     int getX() const { return x; }
        5160 ->     int getY() const { return y; }
        5014 ->     int getTimeLeft() const { return time_left; }
       ##### ->     int getStrength() const { return strength; }
        1249 ->     std::optional<int> getOwner() const { return owner; }
                
                    void changeTexture();
                };
                
                #endif // BOMB_H

Top 10 Lines:

     Line      Count

       12      25197
       33      21440
       34       5160
       35       5014
       37       1249

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

    58060   Total number of line executions
  9676.67   Average executions per line


*** File /usr/include/c++/11/bits/basic_string.tcc:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21  Strings library
                //
                
                // Written by Jason Merrill based upon the specification by Takanori Adachi
                // in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.
                // Non-reference-counted implementation written by Paolo Carlini and
                // updated by Jonathan Wakely for ISO-14882-2011.
                
                #ifndef _BASIC_STRING_TCC
                #define _BASIC_STRING_TCC 1
                
                #pragma GCC system_header
                
                #include <bits/cxxabi_forced.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if _GLIBCXX_USE_CXX11_ABI
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s) _GLIBCXX_NOEXCEPT
                    {
                      if (this == &__s)
                	return;
                
                      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());
                
                      if (_M_is_local())
                	if (__s._M_is_local())
                	  {
                	    if (length() && __s.length())
                	      {
                		_CharT __tmp_data[_S_local_capacity + 1];
                		traits_type::copy(__tmp_data, __s._M_local_buf,
                				  _S_local_capacity + 1);
                		traits_type::copy(__s._M_local_buf, _M_local_buf,
                				  _S_local_capacity + 1);
                		traits_type::copy(_M_local_buf, __tmp_data,
                				  _S_local_capacity + 1);
                	      }
                	    else if (__s.length())
                	      {
                		traits_type::copy(_M_local_buf, __s._M_local_buf,
                				  _S_local_capacity + 1);
                		_M_length(__s.length());
                		__s._M_set_length(0);
                		return;
                	      }
                	    else if (length())
                	      {
                		traits_type::copy(__s._M_local_buf, _M_local_buf,
                				  _S_local_capacity + 1);
                		__s._M_length(length());
                		_M_set_length(0);
                		return;
                	      }
                	  }
                	else
                	  {
                	    const size_type __tmp_capacity = __s._M_allocated_capacity;
                	    traits_type::copy(__s._M_local_buf, _M_local_buf,
                			      _S_local_capacity + 1);
                	    _M_data(__s._M_data());
                	    __s._M_data(__s._M_local_buf);
                	    _M_capacity(__tmp_capacity);
                	  }
                      else
                	{
                	  const size_type __tmp_capacity = _M_allocated_capacity;
                	  if (__s._M_is_local())
                	    {
                	      traits_type::copy(_M_local_buf, __s._M_local_buf,
                				_S_local_capacity + 1);
                	      __s._M_data(_M_data());
                	      _M_data(_M_local_buf);
                	    }
                	  else
                	    {
                	      pointer __tmp_ptr = _M_data();
                	      _M_data(__s._M_data());
                	      __s._M_data(__tmp_ptr);
                	      _M_capacity(__s._M_allocated_capacity);
                	    }
                	  __s._M_capacity(__tmp_capacity);
                	}
                
                      const size_type __tmp_length = length();
                      _M_length(__s.length());
                      __s._M_length(__tmp_length);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::pointer
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_create(size_type& __capacity, size_type __old_capacity)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > max_size())
                	std::__throw_length_error(__N("basic_string::_M_create"));
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	{
                	  __capacity = 2 * __old_capacity;
                	  // Never allocate a string bigger than max_size.
                	  if (__capacity > max_size())
                	    __capacity = max_size();
                	}
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element.
                      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
                    }
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      void
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_construct(_InIterator __beg, _InIterator __end,
                		   std::input_iterator_tag)
                      {
                	size_type __len = 0;
                	size_type __capacity = size_type(_S_local_capacity);
                
                	while (__beg != __end && __len < __capacity)
                	  {
                	    _M_data()[__len++] = *__beg;
                	    ++__beg;
                	  }
                
                	__try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __capacity)
                		  {
                		    // Allocate more space.
                		    __capacity = __len + 1;
                		    pointer __another = _M_create(__capacity, __len);
                		    this->_S_copy(__another, _M_data(), __len);
                		    _M_dispose();
                		    _M_data(__another);
                		    _M_capacity(__capacity);
                		  }
                		_M_data()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	__catch(...)
                	  {
                	    _M_dispose();
                	    __throw_exception_again;
                	  }
                
                	_M_set_length(__len);
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      void
        4563 ->       basic_string<_CharT, _Traits, _Alloc>::
                      _M_construct(_InIterator __beg, _InIterator __end,
                		   std::forward_iterator_tag)
                      {
                	// NB: Not required, but considered best practice.
                	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                	  std::__throw_logic_error(__N("basic_string::"
                				       "_M_construct null not valid"));
                
                	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
                
                	if (__dnew > size_type(_S_local_capacity))
                	  {
                	    _M_data(_M_create(__dnew, size_type(0)));
                	    _M_capacity(__dnew);
                	  }
                
                	// Check for out_of_range and length_error exceptions.
                	__try
                	  { this->_S_copy_chars(_M_data(), __beg, __end); }
                	__catch(...)
                	  {
                	    _M_dispose();
                	    __throw_exception_again;
                	  }
                
                	_M_set_length(__dnew);
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_construct(size_type __n, _CharT __c)
                    {
                      if (__n > size_type(_S_local_capacity))
                	{
                	  _M_data(_M_create(__n, size_type(0)));
                	  _M_capacity(__n);
                	}
                
                      if (__n)
                	this->_S_assign(_M_data(), __n, __c);
                
                      _M_set_length(__n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_assign(const basic_string& __str)
                    {
                      if (this != &__str)
                	{
                	  const size_type __rsize = __str.length();
                	  const size_type __capacity = capacity();
                
                	  if (__rsize > __capacity)
                	    {
                	      size_type __new_capacity = __rsize;
                	      pointer __tmp = _M_create(__new_capacity, __capacity);
                	      _M_dispose();
                	      _M_data(__tmp);
                	      _M_capacity(__new_capacity);
                	    }
                
                	  if (__rsize)
                	    this->_S_copy(_M_data(), __str._M_data(), __rsize);
                
                	  _M_set_length(__rsize);
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      const size_type __capacity = capacity();
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2968. Inconsistencies between basic_string reserve and
                      // vector/unordered_map/unordered_set reserve functions
                      // P0966 reserve should not shrink
                      if (__res <= __capacity)
                	return;
                
                      pointer __tmp = _M_create(__res, __capacity);
                      this->_S_copy(__tmp, _M_data(), length() + 1);
                      _M_dispose();
                      _M_data(__tmp);
                      _M_capacity(__res);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                	      size_type __len2)
                    {
                      const size_type __how_much = length() - __pos - __len1;
                
                      size_type __new_capacity = length() + __len2 - __len1;
                      pointer __r = _M_create(__new_capacity, capacity());
                
                      if (__pos)
                	this->_S_copy(__r, _M_data(), __pos);
                      if (__s && __len2)
                	this->_S_copy(__r + __pos, __s, __len2);
                      if (__how_much)
                	this->_S_copy(__r + __pos + __len2,
                		      _M_data() + __pos + __len1, __how_much);
                
                      _M_dispose();
                      _M_data(__r);
                      _M_capacity(__new_capacity);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_erase(size_type __pos, size_type __n)
                    {
                      const size_type __how_much = length() - __pos - __n;
                
                      if (__how_much && __n)
                	this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
                
                      _M_set_length(length() - __n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve()
                    {
                      if (_M_is_local())
                	return;
                
                      const size_type __length = length();
                      const size_type __capacity = _M_allocated_capacity;
                
                      if (__length <= size_type(_S_local_capacity))
                	{
                	  this->_S_copy(_M_local_data(), _M_data(), __length + 1);
                	  _M_destroy(__capacity);
                	  _M_data(_M_local_data());
                	}
                #if __cpp_exceptions
                      else if (__length < __capacity)
                	try
                	  {
                	    pointer __tmp
                	      = _Alloc_traits::allocate(_M_get_allocator(), __length + 1);
                	    this->_S_copy(__tmp, _M_data(), __length + 1);
                	    _M_dispose();
                	    _M_data(__tmp);
                	    _M_capacity(__length);
                	  }
                	catch (const __cxxabiv1::__forced_unwind&)
                	  { throw; }
                	catch (...)
                	  { /* swallow the exception */ }
                #endif
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->_M_set_length(__n);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_append(const _CharT* __s, size_type __n)
                    {
                      const size_type __len = __n + this->size();
                
                      if (__len <= this->capacity())
                	{
                	  if (__n)
                	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
                	}
                      else
                	this->_M_mutate(this->size(), size_type(0), __s, __n);
                
                      this->_M_set_length(__len);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			  _InputIterator __k1, _InputIterator __k2,
                			  std::__false_type)
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2788. unintentionally require a default constructible allocator
                	const basic_string __s(__k1, __k2, this->get_allocator());
                	const size_type __n1 = __i2 - __i1;
                	return _M_replace(__i1 - begin(), __n1, __s._M_data(),
                			  __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __n2 - __n1;
                
                      if (__new_size <= this->capacity())
                	{
                	  pointer __p = this->_M_data() + __pos1;
                
                	  const size_type __how_much = __old_size - __pos1 - __n1;
                	  if (__how_much && __n1 != __n2)
                	    this->_S_move(__p + __n2, __p + __n1, __how_much);
                	}
                      else
                	this->_M_mutate(__pos1, __n1, 0, __n2);
                
                      if (__n2)
                	this->_S_assign(this->_M_data() + __pos1, __n2, __c);
                
                      this->_M_set_length(__new_size);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                	       const size_type __len2)
                    {
                      _M_check_length(__len1, __len2, "basic_string::_M_replace");
                
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                
                      if (__new_size <= this->capacity())
                	{
                	  pointer __p = this->_M_data() + __pos;
                
                	  const size_type __how_much = __old_size - __pos - __len1;
                	  if (_M_disjunct(__s))
                	    {
                	      if (__how_much && __len1 != __len2)
                		this->_S_move(__p + __len2, __p + __len1, __how_much);
                	      if (__len2)
                		this->_S_copy(__p, __s, __len2);
                	    }
                	  else
                	    {
                	      // Work in-place.
                	      if (__len2 && __len2 <= __len1)
                		this->_S_move(__p, __s, __len2);
                	      if (__how_much && __len1 != __len2)
                		this->_S_move(__p + __len2, __p + __len1, __how_much);
                	      if (__len2 > __len1)
                		{
                		  if (__s + __len2 <= __p + __len1)
                		    this->_S_move(__p, __s, __len2);
                		  else if (__s >= __p + __len1)
                		    {
                		      // Hint to middle end that __p and __s overlap
                		      // (PR 98465).
                		      const size_type __poff = (__s - __p) + (__len2 - __len1);
                		      this->_S_copy(__p, __p + __poff, __len2);
                		    }
                		  else
                		    {
                		      const size_type __nleft = (__p + __len1) - __s;
                		      this->_S_move(__p, __s, __nleft);
                		      this->_S_copy(__p + __nleft, __p + __len2,
                				    __len2 - __nleft);
                		    }
                		}
                	    }
                	}
                      else
                	this->_M_mutate(__pos, __len1, __s, __len2);
                
                      this->_M_set_length(__new_size);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_S_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                
                #else  // !_GLIBCXX_USE_CXX11_ABI
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const _CharT
                    basic_string<_CharT, _Traits, _Alloc>::
                    _Rep::_S_terminal = _CharT();
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::npos;
                
                  // Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)
                  // at static init time (before static ctors are run).
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
                    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
                      sizeof(size_type)];
                
                  // NB: This is the special case for Input Iterators, used in
                  // istreambuf_iterators, etc.
                  // Input Iterators have a cost structure very different from
                  // pointers, calling for a different coding style.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   input_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// Avoid reallocation for common case.
                	_CharT __buf[128];
                	size_type __len = 0;
                	while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
                	  {
                	    __buf[__len++] = *__beg;
                	    ++__beg;
                	  }
                	_Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
                	_M_copy(__r->_M_refdata(), __buf, __len);
                	__try
                	  {
                	    while (__beg != __end)
                	      {
                		if (__len == __r->_M_capacity)
                		  {
                		    // Allocate more space.
                		    _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
                		    _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
                		    __r->_M_destroy(__a);
                		    __r = __another;
                		  }
                		__r->_M_refdata()[__len++] = *__beg;
                		++__beg;
                	      }
                	  }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__len);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template <typename _InIterator>
                      _CharT*
                      basic_string<_CharT, _Traits, _Alloc>::
                      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		   forward_iterator_tag)
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	if (__beg == __end && __a == _Alloc())
                	  return _S_empty_rep()._M_refdata();
                #endif
                	// NB: Not required, but considered best practice.
                	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
                	  __throw_logic_error(__N("basic_string::_S_construct null not valid"));
                
                	const size_type __dnew = static_cast<size_type>(std::distance(__beg,
                								      __end));
                	// Check for out_of_range and length_error exceptions.
                	_Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
                	__try
                	  { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
                	__catch(...)
                	  {
                	    __r->_M_destroy(__a);
                	    __throw_exception_again;
                	  }
                	__r->_M_set_length_and_sharable(__dnew);
                	return __r->_M_refdata();
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::
                    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (__n == 0 && __a == _Alloc())
                	return _S_empty_rep()._M_refdata();
                #endif
                      // Check for out_of_range and length_error exceptions.
                      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
                      if (__n)
                	_M_assign(__r->_M_refdata(), __n, __c);
                
                      __r->_M_set_length_and_sharable(__n);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, npos)
                			       + __pos, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos, size_type __n)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, _Alloc()), _Alloc())
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>::
                    basic_string(const basic_string& __str, size_type __pos,
                		 size_type __n, const _Alloc& __a)
                    : _M_dataplus(_S_construct(__str._M_data()
                			       + __str._M_check(__pos,
                						"basic_string::basic_string"),
                			       __str._M_data() + __str._M_limit(__pos, __n)
                			       + __pos, __a), __a)
                    { }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const basic_string& __str)
                    {
                      if (_M_rep() != __str._M_rep())
                	{
                	  // XXX MT
                	  const allocator_type __a = this->get_allocator();
                	  _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__tmp);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    assign(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      _M_check_length(this->size(), __n, "basic_string::assign");
                      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                	return _M_replace_safe(size_type(0), this->size(), __s, __n);
                      else
                	{
                	  // Work in-place.
                	  const size_type __pos = __s - _M_data();
                	  if (__pos >= __n)
                	    _M_copy(_M_data(), __s, __n);
                	  else if (__pos)
                	    _M_move(_M_data(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__n);
                	  return *this;
                	}
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(size_type __n, _CharT __c)
                    {
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");	  
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_assign(_M_data() + this->size(), __n, __c);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const _CharT* __s, size_type __n)
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	{
                	  _M_check_length(size_type(0), __n, "basic_string::append");
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    {
                	      if (_M_disjunct(__s))
                		this->reserve(__len);
                	      else
                		{
                		  const size_type __off = __s - _M_data();
                		  this->reserve(__len);
                		  __s = _M_data() + __off;
                		}
                	    }
                	  _M_copy(_M_data() + this->size(), __s, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str)
                    {
                      const size_type __size = __str.size();
                      if (__size)
                	{
                	  const size_type __len = __size + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data(), __size);
                	  _M_rep()->_M_set_length_and_sharable(__len);
                	}
                      return *this;
                    }    
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    append(const basic_string& __str, size_type __pos, size_type __n)
                    {
                      __str._M_check(__pos, "basic_string::append");
                      __n = __str._M_limit(__pos, __n);
                      if (__n)
                	{
                	  const size_type __len = __n + this->size();
                	  if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	    this->reserve(__len);
                	  _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
                	  _M_rep()->_M_set_length_and_sharable(__len);	  
                	}
                      return *this;
                    }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     insert(size_type __pos, const _CharT* __s, size_type __n)
                     {
                       __glibcxx_requires_string_len(__s, __n);
                       _M_check(__pos, "basic_string::insert");
                       _M_check_length(size_type(0), __n, "basic_string::insert");
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, size_type(0), __s, __n);
                       else
                         {
                           // Work in-place.
                           const size_type __off = __s - _M_data();
                           _M_mutate(__pos, 0, __n);
                           __s = _M_data() + __off;
                           _CharT* __p = _M_data() + __pos;
                           if (__s  + __n <= __p)
                             _M_copy(__p, __s, __n);
                           else if (__s >= __p)
                             _M_copy(__p, __s + __n, __n);
                           else
                             {
                	       const size_type __nleft = __p - __s;
                               _M_copy(__p, __s, __nleft);
                               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
                             }
                           return *this;
                         }
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     typename basic_string<_CharT, _Traits, _Alloc>::iterator
                     basic_string<_CharT, _Traits, _Alloc>::
                     erase(iterator __first, iterator __last)
                     {
                       _GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last
                				&& __last <= _M_iend());
                
                       // NB: This isn't just an optimization (bail out early when
                       // there is nothing to do, really), it's also a correctness
                       // issue vs MT, see libstdc++/40518.
                       const size_type __size = __last - __first;
                       if (__size)
                	 {
                	   const size_type __pos = __first - _M_ibegin();
                	   _M_mutate(__pos, __size, size_type(0));
                	   _M_rep()->_M_set_leaked();
                	   return iterator(_M_data() + __pos);
                	 }
                       else
                	 return __first;
                     }
                
                   template<typename _CharT, typename _Traits, typename _Alloc>
                     basic_string<_CharT, _Traits, _Alloc>&
                     basic_string<_CharT, _Traits, _Alloc>::
                     replace(size_type __pos, size_type __n1, const _CharT* __s,
                	     size_type __n2)
                     {
                       __glibcxx_requires_string_len(__s, __n2);
                       _M_check(__pos, "basic_string::replace");
                       __n1 = _M_limit(__pos, __n1);
                       _M_check_length(__n1, __n2, "basic_string::replace");
                       bool __left;
                       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
                         return _M_replace_safe(__pos, __n1, __s, __n2);
                       else if ((__left = __s + __n2 <= _M_data() + __pos)
                		|| _M_data() + __pos + __n1 <= __s)
                	 {
                	   // Work in-place: non-overlapping case.
                	   size_type __off = __s - _M_data();
                	   __left ? __off : (__off += __n2 - __n1);
                	   _M_mutate(__pos, __n1, __n2);
                	   _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
                	   return *this;
                	 }
                       else
                	 {
                	   // Todo: overlapping case.
                	   const basic_string __tmp(__s, __n2);
                	   return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
                	 }
                     }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_destroy(const _Alloc& __a) throw ()
                    {
                      const size_type __size = sizeof(_Rep_base) +
                	                       (this->_M_capacity + 1) * sizeof(_CharT);
                      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_leak_hard()
                    {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      if (_M_rep() == &_S_empty_rep())
                	return;
                #endif
                      if (_M_rep()->_M_is_shared())
                	_M_mutate(0, 0, 0);
                      _M_rep()->_M_set_leaked();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
                    {
                      const size_type __old_size = this->size();
                      const size_type __new_size = __old_size + __len2 - __len1;
                      const size_type __how_much = __old_size - __pos - __len1;
                
                      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
                	{
                	  // Must reallocate.
                	  const allocator_type __a = get_allocator();
                	  _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
                
                	  if (__pos)
                	    _M_copy(__r->_M_refdata(), _M_data(), __pos);
                	  if (__how_much)
                	    _M_copy(__r->_M_refdata() + __pos + __len2,
                		    _M_data() + __pos + __len1, __how_much);
                
                	  _M_rep()->_M_dispose(__a);
                	  _M_data(__r->_M_refdata());
                	}
                      else if (__how_much && __len1 != __len2)
                	{
                	  // Work in-place.
                	  _M_move(_M_data() + __pos + __len2,
                		  _M_data() + __pos + __len1, __how_much);
                	}
                      _M_rep()->_M_set_length_and_sharable(__new_size);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve(size_type __res)
                    {
                      const size_type __capacity = capacity();
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2968. Inconsistencies between basic_string reserve and
                      // vector/unordered_map/unordered_set reserve functions
                      // P0966 reserve should not shrink
                      if (__res <= __capacity)
                	{
                	  if (!_M_rep()->_M_is_shared())
                	    return;
                
                	  // unshare, but keep same capacity
                	  __res = __capacity;
                	}
                
                      const allocator_type __a = get_allocator();
                      _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
                      _M_rep()->_M_dispose(__a);
                      _M_data(__tmp);
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    swap(basic_string& __s)
                    _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)
                    {
                      if (_M_rep()->_M_is_leaked())
                	_M_rep()->_M_set_sharable();
                      if (__s._M_rep()->_M_is_leaked())
                	__s._M_rep()->_M_set_sharable();
                      if (this->get_allocator() == __s.get_allocator())
                	{
                	  _CharT* __tmp = _M_data();
                	  _M_data(__s._M_data());
                	  __s._M_data(__tmp);
                	}
                      // The code below can usually be optimized away.
                      else
                	{
                	  const basic_string __tmp1(_M_ibegin(), _M_iend(),
                				    __s.get_allocator());
                	  const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
                				    this->get_allocator());
                	  *this = __tmp2;
                	  __s = __tmp1;
                	}
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _S_create(size_type __capacity, size_type __old_capacity,
                	      const _Alloc& __alloc)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 83.  String::npos vs. string::max_size()
                      if (__capacity > _S_max_size)
                	__throw_length_error(__N("basic_string::_S_create"));
                
                      // The standard places no restriction on allocating more memory
                      // than is strictly needed within this layer at the moment or as
                      // requested by an explicit application call to reserve(n).
                
                      // Many malloc implementations perform quite poorly when an
                      // application attempts to allocate memory in a stepwise fashion
                      // growing each allocation size by only 1 char.  Additionally,
                      // it makes little sense to allocate less linear memory than the
                      // natural blocking size of the malloc implementation.
                      // Unfortunately, we would need a somewhat low-level calculation
                      // with tuned parameters to get this perfect for any particular
                      // malloc implementation.  Fortunately, generalizations about
                      // common features seen among implementations seems to suffice.
                
                      // __pagesize need not match the actual VM page size for good
                      // results in practice, thus we pick a common value on the low
                      // side.  __malloc_header_size is an estimate of the amount of
                      // overhead per memory allocation (in practice seen N * sizeof
                      // (void*) where N is 0, 2 or 4).  According to folklore,
                      // picking this value on the high side is better than
                      // low-balling it (especially when this algorithm is used with
                      // malloc implementations that allocate memory blocks rounded up
                      // to a size which is a power of 2).
                      const size_type __pagesize = 4096;
                      const size_type __malloc_header_size = 4 * sizeof(void*);
                
                      // The below implements an exponential growth policy, necessary to
                      // meet amortized linear time requirements of the library: see
                      // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
                      // It's active for allocations requiring an amount of memory above
                      // system pagesize. This is consistent with the requirements of the
                      // standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html
                      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
                	__capacity = 2 * __old_capacity;
                
                      // NB: Need an array of char_type[__capacity], plus a terminating
                      // null char_type() element, plus enough for the _Rep data structure.
                      // Whew. Seemingly so needy, yet so elemental.
                      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                
                      const size_type __adj_size = __size + __malloc_header_size;
                      if (__adj_size > __pagesize && __capacity > __old_capacity)
                	{
                	  const size_type __extra = __pagesize - __adj_size % __pagesize;
                	  __capacity += __extra / sizeof(_CharT);
                	  // Never allocate a string bigger than _S_max_size.
                	  if (__capacity > _S_max_size)
                	    __capacity = _S_max_size;
                	  __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
                	}
                
                      // NB: Might throw, but no worries about a leak, mate: _Rep()
                      // does not throw.
                      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
                      _Rep *__p = new (__place) _Rep;
                      __p->_M_capacity = __capacity;
                      // ABI compatibility - 3.4.x set in _S_create both
                      // _M_refcount and _M_length.  All callers of _S_create
                      // in basic_string.tcc then set just _M_length.
                      // In 4.0.x and later both _M_refcount and _M_length
                      // are initialized in the callers, unfortunately we can
                      // have 3.4.x compiled code with _S_create callers inlined
                      // calling 4.0.x+ _S_create.
                      __p->_M_set_sharable();
                      return __p;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    _CharT*
                    basic_string<_CharT, _Traits, _Alloc>::_Rep::
                    _M_clone(const _Alloc& __alloc, size_type __res)
                    {
                      // Requested capacity of the clone.
                      const size_type __requested_cap = this->_M_length + __res;
                      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
                				  __alloc);
                      if (this->_M_length)
                	_M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
                
                      __r->_M_set_length_and_sharable(this->_M_length);
                      return __r->_M_refdata();
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    resize(size_type __n, _CharT __c)
                    {
                      const size_type __size = this->size();
                      _M_check_length(__size, __n, "basic_string::resize");
                      if (__size < __n)
                	this->append(__n - __size, __c);
                      else if (__n < __size)
                	this->erase(__n);
                      // else nothing (in particular, avoid calling _M_mutate() unnecessarily.)
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    template<typename _InputIterator>
                      basic_string<_CharT, _Traits, _Alloc>&
                      basic_string<_CharT, _Traits, _Alloc>::
                      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			  _InputIterator __k2, __false_type)
                      {
                	const basic_string __s(__k1, __k2);
                	const size_type __n1 = __i2 - __i1;
                	_M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
                	return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
                			       __s.size());
                      }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		   _CharT __c)
                    {
                      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_assign(_M_data() + __pos1, __n2, __c);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>&
                    basic_string<_CharT, _Traits, _Alloc>::
                    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		    size_type __n2)
                    {
                      _M_mutate(__pos1, __n1, __n2);
                      if (__n2)
                	_M_copy(_M_data() + __pos1, __s, __n2);
                      return *this;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    void
                    basic_string<_CharT, _Traits, _Alloc>::
                    reserve()
                    {
                #if __cpp_exceptions
                      if (length() < capacity() || _M_rep()->_M_is_shared())
                	try
                	  {
                	    const allocator_type __a = get_allocator();
                	    _CharT* __tmp = _M_rep()->_M_clone(__a);
                	    _M_rep()->_M_dispose(__a);
                	    _M_data(__tmp);
                	  }
                	catch (const __cxxabiv1::__forced_unwind&)
                	  { throw; }
                	catch (...)
                	  { /* swallow the exception */ }
                #endif
                    }
                
                    template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    copy(_CharT* __s, size_type __n, size_type __pos) const
                    {
                      _M_check(__pos, "basic_string::copy");
                      __n = _M_limit(__pos, __n);
                      __glibcxx_requires_string_len(__s, __n);
                      if (__n)
                	_M_copy(__s, _M_data() + __pos, __n);
                      // 21.3.5.7 par 3: do not append null.  (good.)
                      return __n;
                    }
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                   
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      __glibcxx_requires_string(__lhs);
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                      const __size_type __len = _Traits::length(__lhs);
                      __string_type __str(_Alloc_traits::_S_select_on_copy(
                          __rhs.get_allocator()));
                      __str.reserve(__len + __rhs.size());
                      __str.append(__lhs, __len);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
                      typedef typename __string_type::size_type	  __size_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                      __string_type __str(_Alloc_traits::_S_select_on_copy(
                          __rhs.get_allocator()));
                      const __size_type __len = __rhs.size();
                      __str.reserve(__len + 1);
                      __str.append(__size_type(1), __lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                
                      if (__n == 0)
                	return __pos <= __size ? __pos : npos;
                      if (__pos >= __size)
                	return npos;
                
                      const _CharT __elem0 = __s[0];
                      const _CharT* const __data = data();
                      const _CharT* __first = __data + __pos;
                      const _CharT* const __last = __data + __size;
                      size_type __len = __size - __pos;
                
                      while (__len >= __n)
                	{
                	  // Find the first occurrence of __elem0:
                	  __first = traits_type::find(__first, __len - __n + 1, __elem0);
                	  if (!__first)
                	    return npos;
                	  // Compare the full strings from the first occurrence of __elem0.
                	  // We already know that __first[0] == __s[0] but compare them again
                	  // anyway because __s is probably aligned, which helps memcmp.
                	  if (traits_type::compare(__first, __s, __n) == 0)
                	    return __first - __data;
                	  __len = __last - ++__first;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __ret = npos;
                      const size_type __size = this->size();
                      if (__pos < __size)
                	{
                	  const _CharT* __data = _M_data();
                	  const size_type __n = __size - __pos;
                	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
                	  if (__p)
                	    __ret = __p - __data;
                	}
                      return __ret;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      const size_type __size = this->size();
                      if (__n <= __size)
                	{
                	  __pos = std::min(size_type(__size - __n), __pos);
                	  const _CharT* __data = _M_data();
                	  do
                	    {
                	      if (traits_type::compare(__data + __pos, __s, __n) == 0)
                		return __pos;
                	    }
                	  while (__pos-- > 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    rfind(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  for (++__size; __size-- > 0; )
                	    if (traits_type::eq(_M_data()[__size], __c))
                	      return __size;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __n && __pos < this->size(); ++__pos)
                	{
                	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
                	  if (__p)
                	    return __pos;
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size && __n)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size-- != 0);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::find(__s, __n, _M_data()[__pos]))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_first_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      for (; __pos < this->size(); ++__pos)
                	if (!traits_type::eq(_M_data()[__pos], __c))
                	  return __pos;
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
                    _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string_len(__s, __n);
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::find(__s, __n, _M_data()[__size]))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    typename basic_string<_CharT, _Traits, _Alloc>::size_type
                    basic_string<_CharT, _Traits, _Alloc>::
                    find_last_not_of(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
                    {
                      size_type __size = this->size();
                      if (__size)
                	{
                	  if (--__size > __pos)
                	    __size = __pos;
                	  do
                	    {
                	      if (!traits_type::eq(_M_data()[__size], __c))
                		return __size;
                	    }
                	  while (__size--);
                	}
                      return npos;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n, const basic_string& __str) const
                    {
                      _M_check(__pos, "basic_string::compare");
                      __n = _M_limit(__pos, __n);
                      const size_type __osize = __str.size();
                      const size_type __len = std::min(__n, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
                      if (!__r)
                	__r = _S_compare(__n, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	    size_type __pos2, size_type __n2) const
                    {
                      _M_check(__pos1, "basic_string::compare");
                      __str._M_check(__pos2, "basic_string::compare");
                      __n1 = _M_limit(__pos1, __n1);
                      __n2 = __str._M_limit(__pos2, __n2);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos1,
                				     __str.data() + __pos2, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string<_CharT, _Traits, _Alloc>::
                    compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                    {
                      __glibcxx_requires_string(__s);
                      const size_type __size = this->size();
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__size, __osize);
                      int __r = traits_type::compare(_M_data(), __s, __len);
                      if (!__r)
                	__r = _S_compare(__size, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s) const
                    {
                      __glibcxx_requires_string(__s);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __osize = traits_type::length(__s);
                      const size_type __len = std::min(__n1, __osize);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __osize);
                      return __r;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    int
                    basic_string <_CharT, _Traits, _Alloc>::
                    compare(size_type __pos, size_type __n1, const _CharT* __s,
                	    size_type __n2) const
                    {
                      __glibcxx_requires_string_len(__s, __n2);
                      _M_check(__pos, "basic_string::compare");
                      __n1 = _M_limit(__pos, __n1);
                      const size_type __len = std::min(__n1, __n2);
                      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
                      if (!__r)
                	__r = _S_compare(__n1, __n2);
                      return __r;
                    }
                
                  // 21.3.7.9 basic_string::getline and operators
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __in,
                	       basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                      typedef ctype<_CharT>				__ctype_type;
                      typedef typename __ctype_type::ctype_base         __ctype_base;
                
                      __size_type __extracted = 0;
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, false);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      // Avoid reallocation for common case.
                	      __str.erase();
                	      _CharT __buf[128];
                	      __size_type __len = 0;	      
                	      const streamsize __w = __in.width();
                	      const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                		                              : __str.max_size();
                	      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !__ct.is(__ctype_base::space,
                				 _Traits::to_char_type(__c)))
                		{
                		  if (__len == sizeof(__buf) / sizeof(_CharT))
                		    {
                		      __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
                		      __len = 0;
                		    }
                		  __buf[__len++] = _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                	      __str.append(__buf, __len);
                
                	      if (__extracted < __n && _Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      __in.width(0);
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      // 211.  operator>>(istream&, string&) doesn't set failbit
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __in,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    {
                      typedef basic_istream<_CharT, _Traits>		__istream_type;
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __istream_type::ios_base         __ios_base;
                      typedef typename __istream_type::int_type		__int_type;
                      typedef typename __string_type::size_type		__size_type;
                
                      __size_type __extracted = 0;
                      const __size_type __n = __str.max_size();
                      typename __ios_base::iostate __err = __ios_base::goodbit;
                      typename __istream_type::sentry __cerb(__in, true);
                      if (__cerb)
                	{
                	  __try
                	    {
                	      __str.erase();
                	      const __int_type __idelim = _Traits::to_int_type(__delim);
                	      const __int_type __eof = _Traits::eof();
                	      __int_type __c = __in.rdbuf()->sgetc();
                
                	      while (__extracted < __n
                		     && !_Traits::eq_int_type(__c, __eof)
                		     && !_Traits::eq_int_type(__c, __idelim))
                		{
                		  __str += _Traits::to_char_type(__c);
                		  ++__extracted;
                		  __c = __in.rdbuf()->snextc();
                		}
                
                	      if (_Traits::eq_int_type(__c, __eof))
                		__err |= __ios_base::eofbit;
                	      else if (_Traits::eq_int_type(__c, __idelim))
                		{
                		  ++__extracted;		  
                		  __in.rdbuf()->sbumpc();
                		}
                	      else
                		__err |= __ios_base::failbit;
                	    }
                	  __catch(__cxxabiv1::__forced_unwind&)
                	    {
                	      __in._M_setstate(__ios_base::badbit);
                	      __throw_exception_again;
                	    }
                	  __catch(...)
                	    {
                	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	      // 91. Description of operator>> and getline() for string<>
                	      // might cause endless loop
                	      __in._M_setstate(__ios_base::badbit);
                	    }
                	}
                      if (!__extracted)
                	__err |= __ios_base::failbit;
                      if (__err)
                	__in.setstate(__err);
                      return __in;
                    }
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  // The explicit instantiation definitions in src/c++11/string-inst.cc and
                  // src/c++17/string-inst.cc only instantiate the members required for C++17
                  // and earlier standards (so not C++20's starts_with and ends_with).
                  // Suppress the explicit instantiation declarations for C++20, so C++20
                  // code will implicitly instantiate std::string and std::wstring as needed.
                # if __cplusplus <= 201703L && _GLIBCXX_EXTERN_TEMPLATE > 0
                  extern template class basic_string<char>;
                # elif ! _GLIBCXX_USE_CXX11_ABI
                  // Still need to prevent implicit instantiation of the COW empty rep,
                  // to ensure the definition in libstdc++.so is unique (PR 86138).
                  extern template basic_string<char>::size_type
                    basic_string<char>::_Rep::_S_empty_rep_storage[];
                # endif
                
                  extern template
                    basic_istream<char>&
                    operator>>(basic_istream<char>&, string&);
                  extern template
                    basic_ostream<char>&
                    operator<<(basic_ostream<char>&, const string&);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&, char);
                  extern template
                    basic_istream<char>&
                    getline(basic_istream<char>&, string&);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                # if __cplusplus <= 201703L && _GLIBCXX_EXTERN_TEMPLATE > 0
                  extern template class basic_string<wchar_t>;
                # elif ! _GLIBCXX_USE_CXX11_ABI
                  extern template basic_string<wchar_t>::size_type
                    basic_string<wchar_t>::_Rep::_S_empty_rep_storage[];
                # endif
                
                  extern template
                    basic_istream<wchar_t>&
                    operator>>(basic_istream<wchar_t>&, wstring&);
                  extern template
                    basic_ostream<wchar_t>&
                    operator<<(basic_ostream<wchar_t>&, const wstring&);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
                  extern template
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>&, wstring&);
                #endif // _GLIBCXX_USE_WCHAR_T
                #endif // _GLIBCXX_EXTERN_TEMPLATE
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      206       4563

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     4563   Total number of line executions
  4563.00   Average executions per line


*** File /usr/include/SFML/System/String.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_STRING_HPP
                #define SFML_STRING_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/System/Export.hpp>
                #include <SFML/System/Utf.hpp>
                #include <iterator>
                #include <locale>
                #include <string>
                
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Utility string class that automatically handles
                ///        conversions between types and encodings
                ///
                ////////////////////////////////////////////////////////////
        1593 -> class SFML_SYSTEM_API String
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    // Types
                    ////////////////////////////////////////////////////////////
                    typedef std::basic_string<Uint32>::iterator       Iterator;      ///< Iterator type
                    typedef std::basic_string<Uint32>::const_iterator ConstIterator; ///< Read-only iterator type
                
                    ////////////////////////////////////////////////////////////
                    // Static member data
                    ////////////////////////////////////////////////////////////
                    static const std::size_t InvalidPos; ///< Represents an invalid position in the string
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// This constructor creates an empty string.
                    ///
                    ////////////////////////////////////////////////////////////
                    String();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from a single ANSI character and a locale
                    ///
                    /// The source character is converted to UTF-32 according
                    /// to the given locale.
                    ///
                    /// \param ansiChar ANSI character to convert
                    /// \param locale   Locale to use for conversion
                    ///
                    ////////////////////////////////////////////////////////////
                    String(char ansiChar, const std::locale& locale = std::locale());
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from single wide character
                    ///
                    /// \param wideChar Wide character to convert
                    ///
                    ////////////////////////////////////////////////////////////
                    String(wchar_t wideChar);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from single UTF-32 character
                    ///
                    /// \param utf32Char UTF-32 character to convert
                    ///
                    ////////////////////////////////////////////////////////////
                    String(Uint32 utf32Char);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from a null-terminated C-style ANSI string and a locale
                    ///
                    /// The source string is converted to UTF-32 according
                    /// to the given locale.
                    ///
                    /// \param ansiString ANSI string to convert
                    /// \param locale     Locale to use for conversion
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const char* ansiString, const std::locale& locale = std::locale());
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from an ANSI string and a locale
                    ///
                    /// The source string is converted to UTF-32 according
                    /// to the given locale.
                    ///
                    /// \param ansiString ANSI string to convert
                    /// \param locale     Locale to use for conversion
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const std::string& ansiString, const std::locale& locale = std::locale());
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from null-terminated C-style wide string
                    ///
                    /// \param wideString Wide string to convert
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const wchar_t* wideString);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from a wide string
                    ///
                    /// \param wideString Wide string to convert
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const std::wstring& wideString);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from a null-terminated C-style UTF-32 string
                    ///
                    /// \param utf32String UTF-32 string to assign
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const Uint32* utf32String);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct from an UTF-32 string
                    ///
                    /// \param utf32String UTF-32 string to assign
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const std::basic_string<Uint32>& utf32String);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Copy constructor
                    ///
                    /// \param copy Instance to copy
                    ///
                    ////////////////////////////////////////////////////////////
                    String(const String& copy);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Create a new sf::String from a UTF-8 encoded string
                    ///
                    /// \param begin Forward iterator to the beginning of the UTF-8 sequence
                    /// \param end   Forward iterator to the end of the UTF-8 sequence
                    ///
                    /// \return A sf::String containing the source string
                    ///
                    /// \see fromUtf16, fromUtf32
                    ///
                    ////////////////////////////////////////////////////////////
                    template <typename T>
                    static String fromUtf8(T begin, T end);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Create a new sf::String from a UTF-16 encoded string
                    ///
                    /// \param begin Forward iterator to the beginning of the UTF-16 sequence
                    /// \param end   Forward iterator to the end of the UTF-16 sequence
                    ///
                    /// \return A sf::String containing the source string
                    ///
                    /// \see fromUtf8, fromUtf32
                    ///
                    ////////////////////////////////////////////////////////////
                    template <typename T>
                    static String fromUtf16(T begin, T end);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Create a new sf::String from a UTF-32 encoded string
                    ///
                    /// This function is provided for consistency, it is equivalent to
                    /// using the constructors that takes a const sf::Uint32* or
                    /// a std::basic_string<sf::Uint32>.
                    ///
                    /// \param begin Forward iterator to the beginning of the UTF-32 sequence
                    /// \param end   Forward iterator to the end of the UTF-32 sequence
                    ///
                    /// \return A sf::String containing the source string
                    ///
                    /// \see fromUtf8, fromUtf16
                    ///
                    ////////////////////////////////////////////////////////////
                    template <typename T>
                    static String fromUtf32(T begin, T end);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Implicit conversion operator to std::string (ANSI string)
                    ///
                    /// The current global locale is used for conversion. If you
                    /// want to explicitly specify a locale, see toAnsiString.
                    /// Characters that do not fit in the target encoding are
                    /// discarded from the returned string.
                    /// This operator is defined for convenience, and is equivalent
                    /// to calling toAnsiString().
                    ///
                    /// \return Converted ANSI string
                    ///
                    /// \see toAnsiString, operator std::wstring
                    ///
                    ////////////////////////////////////////////////////////////
                    operator std::string() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Implicit conversion operator to std::wstring (wide string)
                    ///
                    /// Characters that do not fit in the target encoding are
                    /// discarded from the returned string.
                    /// This operator is defined for convenience, and is equivalent
                    /// to calling toWideString().
                    ///
                    /// \return Converted wide string
                    ///
                    /// \see toWideString, operator std::string
                    ///
                    ////////////////////////////////////////////////////////////
                    operator std::wstring() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Convert the Unicode string to an ANSI string
                    ///
                    /// The UTF-32 string is converted to an ANSI string in
                    /// the encoding defined by \a locale.
                    /// Characters that do not fit in the target encoding are
                    /// discarded from the returned string.
                    ///
                    /// \param locale Locale to use for conversion
                    ///
                    /// \return Converted ANSI string
                    ///
                    /// \see toWideString, operator std::string
                    ///
                    ////////////////////////////////////////////////////////////
                    std::string toAnsiString(const std::locale& locale = std::locale()) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Convert the Unicode string to a wide string
                    ///
                    /// Characters that do not fit in the target encoding are
                    /// discarded from the returned string.
                    ///
                    /// \return Converted wide string
                    ///
                    /// \see toAnsiString, operator std::wstring
                    ///
                    ////////////////////////////////////////////////////////////
                    std::wstring toWideString() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Convert the Unicode string to a UTF-8 string
                    ///
                    /// \return Converted UTF-8 string
                    ///
                    /// \see toUtf16, toUtf32
                    ///
                    ////////////////////////////////////////////////////////////
                    std::basic_string<Uint8> toUtf8() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Convert the Unicode string to a UTF-16 string
                    ///
                    /// \return Converted UTF-16 string
                    ///
                    /// \see toUtf8, toUtf32
                    ///
                    ////////////////////////////////////////////////////////////
                    std::basic_string<Uint16> toUtf16() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Convert the Unicode string to a UTF-32 string
                    ///
                    /// This function doesn't perform any conversion, since the
                    /// string is already stored as UTF-32 internally.
                    ///
                    /// \return Converted UTF-32 string
                    ///
                    /// \see toUtf8, toUtf16
                    ///
                    ////////////////////////////////////////////////////////////
                    std::basic_string<Uint32> toUtf32() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Overload of assignment operator
                    ///
                    /// \param right Instance to assign
                    ///
                    /// \return Reference to self
                    ///
                    ////////////////////////////////////////////////////////////
                    String& operator =(const String& right);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Overload of += operator to append an UTF-32 string
                    ///
                    /// \param right String to append
                    ///
                    /// \return Reference to self
                    ///
                    ////////////////////////////////////////////////////////////
                    String& operator +=(const String& right);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Overload of [] operator to access a character by its position
                    ///
                    /// This function provides read-only access to characters.
                    /// Note: the behavior is undefined if \a index is out of range.
                    ///
                    /// \param index Index of the character to get
                    ///
                    /// \return Character at position \a index
                    ///
                    ////////////////////////////////////////////////////////////
                    Uint32 operator [](std::size_t index) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Overload of [] operator to access a character by its position
                    ///
                    /// This function provides read and write access to characters.
                    /// Note: the behavior is undefined if \a index is out of range.
                    ///
                    /// \param index Index of the character to get
                    ///
                    /// \return Reference to the character at position \a index
                    ///
                    ////////////////////////////////////////////////////////////
                    Uint32& operator [](std::size_t index);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Clear the string
                    ///
                    /// This function removes all the characters from the string.
                    ///
                    /// \see isEmpty, erase
                    ///
                    ////////////////////////////////////////////////////////////
                    void clear();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the size of the string
                    ///
                    /// \return Number of characters in the string
                    ///
                    /// \see isEmpty
                    ///
                    ////////////////////////////////////////////////////////////
                    std::size_t getSize() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Check whether the string is empty or not
                    ///
                    /// \return True if the string is empty (i.e. contains no character)
                    ///
                    /// \see clear, getSize
                    ///
                    ////////////////////////////////////////////////////////////
                    bool isEmpty() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Erase one or more characters from the string
                    ///
                    /// This function removes a sequence of \a count characters
                    /// starting from \a position.
                    ///
                    /// \param position Position of the first character to erase
                    /// \param count    Number of characters to erase
                    ///
                    ////////////////////////////////////////////////////////////
                    void erase(std::size_t position, std::size_t count = 1);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Insert one or more characters into the string
                    ///
                    /// This function inserts the characters of \a str
                    /// into the string, starting from \a position.
                    ///
                    /// \param position Position of insertion
                    /// \param str      Characters to insert
                    ///
                    ////////////////////////////////////////////////////////////
                    void insert(std::size_t position, const String& str);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Find a sequence of one or more characters in the string
                    ///
                    /// This function searches for the characters of \a str
                    /// in the string, starting from \a start.
                    ///
                    /// \param str   Characters to find
                    /// \param start Where to begin searching
                    ///
                    /// \return Position of \a str in the string, or String::InvalidPos if not found
                    ///
                    ////////////////////////////////////////////////////////////
                    std::size_t find(const String& str, std::size_t start = 0) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Replace a substring with another string
                    ///
                    /// This function replaces the substring that starts at index \a position
                    /// and spans \a length characters with the string \a replaceWith.
                    ///
                    /// \param position    Index of the first character to be replaced
                    /// \param length      Number of characters to replace. You can pass InvalidPos to
                    ///                    replace all characters until the end of the string.
                    /// \param replaceWith String that replaces the given substring.
                    ///
                    ////////////////////////////////////////////////////////////
                    void replace(std::size_t position, std::size_t length, const String& replaceWith);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Replace all occurrences of a substring with a replacement string
                    ///
                    /// This function replaces all occurrences of \a searchFor in this string
                    /// with the string \a replaceWith.
                    ///
                    /// \param searchFor   The value being searched for
                    /// \param replaceWith The value that replaces found \a searchFor values
                    ///
                    ////////////////////////////////////////////////////////////
                    void replace(const String& searchFor, const String& replaceWith);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return a part of the string
                    ///
                    /// This function returns the substring that starts at index \a position
                    /// and spans \a length characters.
                    ///
                    /// \param position Index of the first character
                    /// \param length   Number of characters to include in the substring (if
                    ///                 the string is shorter, as many characters as possible
                    ///                 are included). \ref InvalidPos can be used to include all
                    ///                 characters until the end of the string.
                    ///
                    /// \return String object containing a substring of this object
                    ///
                    ////////////////////////////////////////////////////////////
                    String substring(std::size_t position, std::size_t length = InvalidPos) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get a pointer to the C-style array of characters
                    ///
                    /// This functions provides a read-only access to a
                    /// null-terminated C-style representation of the string.
                    /// The returned pointer is temporary and is meant only for
                    /// immediate use, thus it is not recommended to store it.
                    ///
                    /// \return Read-only pointer to the array of characters
                    ///
                    ////////////////////////////////////////////////////////////
                    const Uint32* getData() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return an iterator to the beginning of the string
                    ///
                    /// \return Read-write iterator to the beginning of the string characters
                    ///
                    /// \see end
                    ///
                    ////////////////////////////////////////////////////////////
                    Iterator begin();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return an iterator to the beginning of the string
                    ///
                    /// \return Read-only iterator to the beginning of the string characters
                    ///
                    /// \see end
                    ///
                    ////////////////////////////////////////////////////////////
                    ConstIterator begin() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return an iterator to the end of the string
                    ///
                    /// The end iterator refers to 1 position past the last character;
                    /// thus it represents an invalid character and should never be
                    /// accessed.
                    ///
                    /// \return Read-write iterator to the end of the string characters
                    ///
                    /// \see begin
                    ///
                    ////////////////////////////////////////////////////////////
                    Iterator end();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return an iterator to the end of the string
                    ///
                    /// The end iterator refers to 1 position past the last character;
                    /// thus it represents an invalid character and should never be
                    /// accessed.
                    ///
                    /// \return Read-only iterator to the end of the string characters
                    ///
                    /// \see begin
                    ///
                    ////////////////////////////////////////////////////////////
                    ConstIterator end() const;
                
                private:
                
                    friend SFML_SYSTEM_API bool operator ==(const String& left, const String& right);
                    friend SFML_SYSTEM_API bool operator <(const String& left, const String& right);
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    std::basic_string<Uint32> m_string; ///< Internal string of UTF-32 characters
                };
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of == operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if both strings are equal
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator ==(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of != operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if both strings are different
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator !=(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of < operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if \a left is lexicographically before \a right
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator <(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of > operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if \a left is lexicographically after \a right
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator >(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of <= operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if \a left is lexicographically before or equivalent to \a right
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator <=(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of >= operator to compare two UTF-32 strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return True if \a left is lexicographically after or equivalent to \a right
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API bool operator >=(const String& left, const String& right);
                
                ////////////////////////////////////////////////////////////
                /// \relates String
                /// \brief Overload of binary + operator to concatenate two strings
                ///
                /// \param left  Left operand (a string)
                /// \param right Right operand (a string)
                ///
                /// \return Concatenated string
                ///
                ////////////////////////////////////////////////////////////
                SFML_SYSTEM_API String operator +(const String& left, const String& right);
                
                #include <SFML/System/String.inl>
                
                } // namespace sf
                
                
                #endif // SFML_STRING_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::String
                /// \ingroup system
                ///
                /// sf::String is a utility string class defined mainly for
                /// convenience. It is a Unicode string (implemented using
                /// UTF-32), thus it can store any character in the world
                /// (European, Chinese, Arabic, Hebrew, etc.).
                ///
                /// It automatically handles conversions from/to ANSI and
                /// wide strings, so that you can work with standard string
                /// classes and still be compatible with functions taking a
                /// sf::String.
                ///
                /// \code
                /// sf::String s;
                ///
                /// std::string s1 = s;  // automatically converted to ANSI string
                /// std::wstring s2 = s; // automatically converted to wide string
                /// s = "hello";         // automatically converted from ANSI string
                /// s = L"hello";        // automatically converted from wide string
                /// s += 'a';            // automatically converted from ANSI string
                /// s += L'a';           // automatically converted from wide string
                /// \endcode
                ///
                /// Conversions involving ANSI strings use the default user locale. However
                /// it is possible to use a custom locale if necessary:
                /// \code
                /// std::locale locale;
                /// sf::String s;
                /// ...
                /// std::string s1 = s.toAnsiString(locale);
                /// s = sf::String("hello", locale);
                /// \endcode
                ///
                /// sf::String defines the most important functions of the
                /// standard std::string class: removing, random access, iterating,
                /// appending, comparing, etc. However it is a simple class
                /// provided for convenience, and you may have to consider using
                /// a more optimized class if your program requires complex string
                /// handling. The automatic conversion functions will then take
                /// care of converting your string to sf::String whenever SFML
                /// requires it.
                ///
                /// Please note that SFML also defines a low-level, generic
                /// interface for Unicode handling, see the sf::Utf classes.
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       45       1593

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1593   Total number of line executions
  1593.00   Average executions per line


*** File /usr/include/c++/11/bits/stl_pair.h:
                // Pair implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_pair.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _STL_PAIR_H
                #define _STL_PAIR_H 1
                
                #include <bits/move.h> // for std::move / std::forward, and std::swap
                
                #if __cplusplus >= 201103L
                # include <type_traits> // for std::__decay_and_strip, std::is_reference_v
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                # define __cpp_lib_constexpr_utility 201811L
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus >= 201103L
                  /// Tag type for piecewise construction of std::pair objects.
                  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };
                
                  /// Tag for piecewise construction of std::pair objects.
                  _GLIBCXX17_INLINE constexpr piecewise_construct_t piecewise_construct =
                    piecewise_construct_t();
                
                  /// @cond undocumented
                
                  // Forward declarations.
                  template<typename...>
                    class tuple;
                
                  template<size_t...>
                    struct _Index_tuple;
                
                  // Concept utility functions, reused in conditionally-explicit
                  // constructors.
                  // See PR 70437, don't look at is_constructible or
                  // is_convertible if the types are the same to
                  // avoid querying those properties for incomplete types.
                  template <bool, typename _T1, typename _T2>
                    struct _PCC
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, const _U2&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return __and_<is_convertible<const _U1&, _T1>,
                		      is_convertible<const _U2&, _T2>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, _U2&&>>::value;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return __and_<is_convertible<_U1&&, _T1>,
                		      is_convertible<_U2&&, _T2>>::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _CopyMovePair()
                      {
                	using __do_converts = __and_<is_convertible<const _U1&, _T1>,
                				  is_convertible<_U2&&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, const _U1&>,
                		      is_constructible<_T2, _U2&&>,
                		      __converts
                		      >::value;
                      }
                
                      template <bool __implicit, typename _U1, typename _U2>
                      static constexpr bool _MoveCopyPair()
                      {
                	using __do_converts = __and_<is_convertible<_U1&&, _T1>,
                				  is_convertible<const _U2&, _T2>>;
                	using __converts = typename conditional<__implicit,
                				       __do_converts,
                				       __not_<__do_converts>>::type;
                	return __and_<is_constructible<_T1, _U1&&>,
                		      is_constructible<_T2, const _U2&&>,
                		      __converts
                		      >::value;
                      }
                  };
                
                  template <typename _T1, typename _T2>
                    struct _PCC<false, _T1, _T2>
                    {
                      template <typename _U1, typename _U2>
                      static constexpr bool _ConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyConvertiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _MoveConstructiblePair()
                      {
                	return false;
                      }
                
                      template <typename _U1, typename _U2>
                      static constexpr bool _ImplicitlyMoveConvertiblePair()
                      {
                	return false;
                      }
                  };
                #endif // C++11
                
                  template<typename _U1, typename _U2> class __pair_base
                  {
                #if __cplusplus >= 201103L
                    template<typename _T1, typename _T2> friend struct pair;
                    __pair_base() = default;
                    ~__pair_base() = default;
                    __pair_base(const __pair_base&) = default;
                    __pair_base& operator=(const __pair_base&) = delete;
                #endif // C++11
                  };
                
                  /// @endcond
                
                 /**
                   *  @brief Struct holding two objects of arbitrary type.
                   *
                   *  @tparam _T1  Type of first object.
                   *  @tparam _T2  Type of second object.
                   *
                   *  <https://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html>
                   */
                  template<typename _T1, typename _T2>
                    struct pair
                    : private __pair_base<_T1, _T2>
                    {
                      typedef _T1 first_type;    ///< The type of the `first` member
                      typedef _T2 second_type;   ///< The type of the `second` member
                
                      _T1 first;                 ///< The first member
                      _T2 second;                ///< The second member
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 265.  std::pair::pair() effects overly restrictive
                      /** The default constructor creates @c first and @c second using their
                       *  respective default constructors.  */
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                                     __is_implicitly_default_constructible<_U1>,
                                                     __is_implicitly_default_constructible<_U2>>
                                                   ::value, bool>::type = true>
                #endif
                      _GLIBCXX_CONSTEXPR pair()
                      : first(), second() { }
                
                #if __cplusplus >= 201103L
                      template <typename _U1 = _T1,
                                typename _U2 = _T2,
                                typename enable_if<__and_<
                                       is_default_constructible<_U1>,
                                       is_default_constructible<_U2>,
                                       __not_<
                                         __and_<__is_implicitly_default_constructible<_U1>,
                                                __is_implicitly_default_constructible<_U2>>>>
                                                   ::value, bool>::type = false>
                      explicit constexpr pair()
                      : first(), second() { }
                #endif
                
                #if __cplusplus < 201103L
                      /// Two objects may be passed to a @c pair constructor to be copied.
                      pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #else
                      // Shortcut for constraining the templates that don't take pairs.
                      /// @cond undocumented
                      using _PCCP = _PCC<true, _T1, _T2>;
                      /// @endcond
                
                      /// Construct from two const lvalues, allowing implicit conversions.
                      template<typename _U1 = _T1, typename _U2=_T2, typename
                	       enable_if<_PCCP::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCP::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
                      constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                
                      /// Construct from two const lvalues, disallowing implicit conversions.
                       template<typename _U1 = _T1, typename _U2=_T2, typename
                		enable_if<_PCCP::template
                			    _ConstructiblePair<_U1, _U2>()
                	                  && !_PCCP::template
                			    _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                      explicit constexpr pair(const _T1& __a, const _T2& __b)
                      : first(__a), second(__b) { }
                #endif
                
                #if __cplusplus < 201103L
                      /// There is also a templated constructor to convert from other pairs.
                      template<typename _U1, typename _U2>
                	pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #else
                      // Shortcut for constraining the templates that take pairs.
                      /// @cond undocumented
                      template <typename _U1, typename _U2>
                        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
                			    || !is_same<_T2, _U2>::value,
                			    _T1, _T2>;
                      /// @endcond
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                	                 && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                			  bool>::type=true>
                        constexpr pair(const pair<_U1, _U2>& __p)
                        : first(__p.first), second(__p.second) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _ConstructiblePair<_U1, _U2>()
                			 && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(const pair<_U1, _U2>& __p)
                	: first(__p.first), second(__p.second) { }
                #endif
                
                #if __cplusplus >= 201103L
                      constexpr pair(const pair&) = default;	///< Copy constructor
                      constexpr pair(pair&&) = default;		///< Move constructor
                
                      // DR 811.
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<true, _U1, _T2>(),
                                         bool>::type=true>
                       constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U1, typename
                	       enable_if<_PCCP::template
                			   _MoveCopyPair<false, _U1, _T2>(),
                                         bool>::type=false>
                       explicit constexpr pair(_U1&& __x, const _T2& __y)
                       : first(std::forward<_U1>(__x)), second(__y) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<true, _T1, _U2>(),
                                         bool>::type=true>
                       constexpr pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U2, typename
                	       enable_if<_PCCP::template
                			   _CopyMovePair<false, _T1, _U2>(),
                                         bool>::type=false>
                       explicit pair(const _T1& __x, _U2&& __y)
                       : first(__x), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
       10153 -> 	constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCP::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCP::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(_U1&& __x, _U2&& __y)
                	: first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }
                
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && _PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=true>
        6391 -> 	constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename _U1, typename _U2, typename
                	       enable_if<_PCCFP<_U1, _U2>::template
                			   _MoveConstructiblePair<_U1, _U2>()
                			  && !_PCCFP<_U1, _U2>::template
                			   _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                                         bool>::type=false>
                	explicit constexpr pair(pair<_U1, _U2>&& __p)
                	: first(std::forward<_U1>(__p.first)),
                	  second(std::forward<_U2>(__p.second)) { }
                
                      template<typename... _Args1, typename... _Args2>
                	_GLIBCXX20_CONSTEXPR
                        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);
                
                      _GLIBCXX20_CONSTEXPR pair&
                      operator=(typename conditional<
                		__and_<is_copy_assignable<_T1>,
                		       is_copy_assignable<_T2>>::value,
                		const pair&, const __nonesuch&>::type __p)
                      {
                	first = __p.first;
                	second = __p.second;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR pair&
                      operator=(typename conditional<
                		__and_<is_move_assignable<_T1>,
                		       is_move_assignable<_T2>>::value,
                		pair&&, __nonesuch&&>::type __p)
                      noexcept(__and_<is_nothrow_move_assignable<_T1>,
                		      is_nothrow_move_assignable<_T2>>::value)
                      {
                	first = std::forward<first_type>(__p.first);
                	second = std::forward<second_type>(__p.second);
                	return *this;
                      }
                
                      template<typename _U1, typename _U2>
                	_GLIBCXX20_CONSTEXPR
                	typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
                				  is_assignable<_T2&, const _U2&>>::value,
                			   pair&>::type
                	operator=(const pair<_U1, _U2>& __p)
                	{
                	  first = __p.first;
                	  second = __p.second;
                	  return *this;
                	}
                
                      template<typename _U1, typename _U2>
                	_GLIBCXX20_CONSTEXPR
                	typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
                				  is_assignable<_T2&, _U2&&>>::value,
                			   pair&>::type
                	operator=(pair<_U1, _U2>&& __p)
                	{
                	  first = std::forward<_U1>(__p.first);
                	  second = std::forward<_U2>(__p.second);
                	  return *this;
                	}
                
                      /// Swap the first members and then the second members.
                      _GLIBCXX20_CONSTEXPR void
                      swap(pair& __p)
                      noexcept(__and_<__is_nothrow_swappable<_T1>,
                                      __is_nothrow_swappable<_T2>>::value)
                      {
                	using std::swap;
                	swap(first, __p.first);
                	swap(second, __p.second);
                      }
                
                    private:
                      template<typename... _Args1, size_t... _Indexes1,
                	       typename... _Args2, size_t... _Indexes2>
                	_GLIBCXX20_CONSTEXPR
                        pair(tuple<_Args1...>&, tuple<_Args2...>&,
                	     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
                #endif // C++11
                    };
                
                  /// @relates pair @{
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;
                #endif
                
                  /// Two pairs of the same type are equal iff their members are equal.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first == __y.first && __x.second == __y.second; }
                
                #if __cpp_lib_three_way_comparison && __cpp_lib_concepts
                  template<typename _T1, typename _T2>
                    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1>,
                					   __detail::__synth3way_t<_T2>>
                    operator<=>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    {
                      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
                	return __c;
                      return __detail::__synth3way(__x.second, __y.second);
                    }
                #else
                  /** Defines a lexicographical order for pairs.
                   *
                   * For two pairs of the same type, `P` is ordered before `Q` if
                   * `P.first` is less than `Q.first`, or if `P.first` and `Q.first`
                   * are equivalent (neither is less than the other) and `P.second` is less
                   * than `Q.second`.
                  */
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __x.first < __y.first
                	     || (!(__y.first < __x.first) && __x.second < __y.second); }
                
                  /// Uses @c operator== to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x == __y); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return __y < __x; }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__y < __x); }
                
                  /// Uses @c operator< to find the result.
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX_CONSTEXPR bool
                    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
                    { return !(__x < __y); }
                #endif // !(three_way_comparison && concepts)
                
                #if __cplusplus >= 201103L
                  /** Swap overload for pairs. Calls std::pair::swap().
                   *
                   * @note This std::swap overload is not declared in C++03 mode,
                   * which has performance implications, e.g. see https://gcc.gnu.org/PR38466
                  */
                  template<typename _T1, typename _T2>
                    _GLIBCXX20_CONSTEXPR inline
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                    // Constrained free swap overload, see p0185r1
                    typename enable_if<__and_<__is_swappable<_T1>,
                                              __is_swappable<_T2>>::value>::type
                #else
                    void
                #endif
                    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
                    noexcept(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                #if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
                  template<typename _T1, typename _T2>
                    typename enable_if<!__and_<__is_swappable<_T1>,
                			       __is_swappable<_T2>>::value>::type
                    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
                #endif
                #endif // __cplusplus >= 201103L
                
                  /// @} relates pair
                
                  /**
                   *  @brief A convenience wrapper for creating a pair from two objects.
                   *  @param  __x  The first object.
                   *  @param  __y  The second object.
                   *  @return   A newly-constructed pair<> object of the appropriate type.
                   *
                   *  The C++98 standard says the objects are passed by reference-to-const,
                   *  but C++03 says they are passed by value (this was LWG issue #181).
                   *
                   *  Since C++11 they have been passed by forwarding reference and then
                   *  forwarded to the new members of the pair. To create a pair with a
                   *  member of reference type, pass a `reference_wrapper` to this function.
                   */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 181.  make_pair() unintended behavior
                #if __cplusplus >= 201103L
                  // NB: DR 706.
                  template<typename _T1, typename _T2>
                    constexpr pair<typename __decay_and_strip<_T1>::__type,
                                   typename __decay_and_strip<_T2>::__type>
        6391 ->     make_pair(_T1&& __x, _T2&& __y)
                    {
                      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
                      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
                      typedef pair<__ds_type1, __ds_type2> 	      __pair_type;
                      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
                    }
                #else
                  template<typename _T1, typename _T2>
                    inline pair<_T1, _T2>
                    make_pair(_T1 __x, _T2 __y)
                    { return pair<_T1, _T2>(__x, __y); }
                #endif
                
                  /// @}
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_PAIR_H */


Top 10 Lines:

     Line      Count

      352      10153
      371       6391
      567       6391

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    22935   Total number of line executions
  7645.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Game.h:
                #ifndef GAME_H
                #define GAME_H
                
                #include <SFML/Graphics.hpp>
                #include <iostream>
                #include <optional>
                #include "GameState.h"
                
                #define TILE_SIZE 64
                #define MAX_WINDOW_X 30
                #define MAX_WINDOW_Y 10
                
                #define BONUS_SPAWN_CHANCE 15
                
       ##### -> class Game
                {
                private:
                    void processEvents();
                    void update();
                    void render();
                
                    sf::RenderWindow window; 
                
                    // GameState
                    GameState gameState;
                
                    float zoom;
                
                public:
           1 ->     Game() {
                        gameState = GameState(
                            Level(),
                            std::vector<Player>(),
                            false
                        );
                    }
                    void load(unsigned int level_nb);
                    void run();
                
                    Level &getLevel() { return gameState.level; }
         796 ->     std::vector<Player> &getPlayers() { return gameState.players; }
                    std::vector<Bomb> &getBombs() { return gameState.bombs; }
                };
                
                #endif // GAME_H

Top 10 Lines:

     Line      Count

       41        796
       30          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      797   Total number of line executions
   265.67   Average executions per line


*** File /usr/include/SFML/Graphics/Drawable.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_DRAWABLE_HPP
                #define SFML_DRAWABLE_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/RenderStates.hpp>
                
                
                namespace sf
                {
                class RenderTarget;
                
                ////////////////////////////////////////////////////////////
                /// \brief Abstract base class for objects that can be drawn
                ///        to a render target
                ///
                ////////////////////////////////////////////////////////////
       44171 -> class SFML_GRAPHICS_API Drawable
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Virtual destructor
                    ///
                    ////////////////////////////////////////////////////////////
       48333 ->     virtual ~Drawable() {}
                
                protected:
                
                    friend class RenderTarget;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Draw the object to a render target
                    ///
                    /// This is a pure virtual function that has to be implemented
                    /// by the derived class to define how the drawable should be
                    /// drawn.
                    ///
                    /// \param target Render target to draw to
                    /// \param states Current render states
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual void draw(RenderTarget& target, RenderStates states) const = 0;
                };
                
                } // namespace sf
                
                
                #endif // SFML_DRAWABLE_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::Drawable
                /// \ingroup graphics
                ///
                /// sf::Drawable is a very simple base class that allows objects
                /// of derived classes to be drawn to a sf::RenderTarget.
                ///
                /// All you have to do in your derived class is to override the
                /// draw virtual function.
                ///
                /// Note that inheriting from sf::Drawable is not mandatory,
                /// but it allows this nice syntax "window.draw(object)" rather
                /// than "object.draw(window)", which is more consistent with other
                /// SFML classes.
                ///
                /// Example:
                /// \code
                /// class MyDrawable : public sf::Drawable
                /// {
                /// public:
                ///
                ///    ...
                ///
                /// private:
                ///
                ///     virtual void draw(sf::RenderTarget& target, sf::RenderStates states) const
                ///     {
                ///         // You can draw other high-level objects
                ///         target.draw(m_sprite, states);
                ///
                ///         // ... or use the low-level API
                ///         states.texture = &m_texture;
                ///         target.draw(m_vertices, states);
                ///
                ///         // ... or draw with OpenGL directly
                ///         glBegin(GL_QUADS);
                ///         ...
                ///         glEnd();
                ///     }
                ///
                ///     sf::Sprite m_sprite;
                ///     sf::Texture m_texture;
                ///     sf::VertexArray m_vertices;
                /// };
                /// \endcode
                ///
                /// \see sf::RenderTarget
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       52      48333
       44      44171

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

    92504   Total number of line executions
 46252.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/GameState.h:
                #ifndef GAMESTATE_H
                #define GAMESTATE_H
                
                #include "Level.h"
                #include "Player.h"
                #include "Bomb.h"
                #include "Bonus.h"
                #include "Flame.h"
                
                enum Winner
                {
                    PLAYER1,
                    PLAYER2,
                    DRAW,
                    NO_WINNER
                };
                
       25337 -> class GameState
                {
                public:
           1 ->     GameState() {}
           1 ->     GameState(Level level, std::vector<Player> players, bool AIturn)
                        : level(level), players(players), AIturn(AIturn), winner(NO_WINNER), turns(0) {}
                
                    Level level;
                    std::vector<Player> players;
                    bool AIturn;
                    std::vector<Bomb> bombs;
                    std::vector<Bonus> bonuses;
                    std::vector<Flame> flames;
                
                    Winner winner;
                    int turns;
                
                    void PlayerCheckBonus(Player &player);
                    void update();
                };
                
                #endif // GAMESTATE_H

Top 10 Lines:

     Line      Count

       18      25337
       21          1
       22          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    25339   Total number of line executions
  8446.33   Average executions per line


*** File /usr/include/c++/11/bits/stl_iterator_base_funcs.h:
                // Functions used by iterators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator_base_funcs.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file contains all of the general iterator-related utility
                 *  functions, such as distance() and advance().
                 */
                
                #ifndef _STL_ITERATOR_BASE_FUNCS_H
                #define _STL_ITERATOR_BASE_FUNCS_H 1
                
                #pragma GCC system_header
                
                #include <bits/concept_check.h>
                #include <debug/assertions.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                  // Forward declaration for the overloads of __distance.
                  template <typename> struct _List_iterator;
                  template <typename> struct _List_const_iterator;
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                  template<typename _InputIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
                    __distance(_InputIterator __first, _InputIterator __last,
                               input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      while (__first != __last)
                	{
                	  ++__first;
                	  ++__n;
                	}
                      return __n;
                    }
                
                  template<typename _RandomAccessIterator>
                    inline _GLIBCXX14_CONSTEXPR
                    typename iterator_traits<_RandomAccessIterator>::difference_type
        4564 ->     __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
                               random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      return __last - __first;
                    }
                
                #if _GLIBCXX_USE_CXX11_ABI
                  // Forward declaration because of the qualified call in distance.
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_iterator<_Tp>,
                	       input_iterator_tag);
                
                  template<typename _Tp>
                    ptrdiff_t
                    __distance(_GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       _GLIBCXX_STD_C::_List_const_iterator<_Tp>,
                	       input_iterator_tag);
                #endif
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __first  An input iterator.
                   *  @param  __last  An input iterator.
                   *  @return  The distance between them.
                   *
                   *  Returns @c n such that __first + n == __last.  This requires
                   *  that @p __last must be reachable from @p __first.  Note that @c
                   *  n may be negative.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
        4564 ->     distance(_InputIterator __first, _InputIterator __last)
                    {
                      // concept requirements -- taken care of in __distance
                      return std::__distance(__first, __last,
                			     std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      __glibcxx_assert(__n >= 0);
                      while (__n--)
                	++__i;
                    }
                
                  template<typename _BidirectionalIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_BidirectionalIterator& __i, _Distance __n,
                	      bidirectional_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      if (__n > 0)
                        while (__n--)
                	  ++__i;
                      else
                        while (__n++)
                	  --__i;
                    }
                
                  template<typename _RandomAccessIterator, typename _Distance>
                    inline _GLIBCXX14_CONSTEXPR void
                    __advance(_RandomAccessIterator& __i, _Distance __n,
                              random_access_iterator_tag)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_RandomAccessIteratorConcept<
                				  _RandomAccessIterator>)
                      if (__builtin_constant_p(__n) && __n == 1)
                	++__i;
                      else if (__builtin_constant_p(__n) && __n == -1)
                	--__i;
                      else
                	__i += __n;
                    }
                
                  /**
                   *  @brief A generalization of pointer arithmetic.
                   *  @param  __i  An input iterator.
                   *  @param  __n  The @a delta by which to change @p __i.
                   *  @return  Nothing.
                   *
                   *  This increments @p i by @p n.  For bidirectional and random access
                   *  iterators, @p __n may be negative, in which case @p __i is decremented.
                   *
                   *  For random access iterators, this uses their @c + and @c - operations
                   *  and are constant time.  For other %iterator classes they are linear time.
                  */
                  template<typename _InputIterator, typename _Distance>
                    inline _GLIBCXX17_CONSTEXPR void
                    advance(_InputIterator& __i, _Distance __n)
                    {
                      // concept requirements -- taken care of in __advance
                      typename iterator_traits<_InputIterator>::difference_type __d = __n;
                      std::__advance(__i, __d, std::__iterator_category(__i));
                    }
                
                #if __cplusplus >= 201103L
                
                  template<typename _InputIterator>
                    inline _GLIBCXX17_CONSTEXPR _InputIterator
                    next(_InputIterator __x, typename
                	 iterator_traits<_InputIterator>::difference_type __n = 1)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
                      std::advance(__x, __n);
                      return __x;
                    }
                
                  template<typename _BidirectionalIterator>
                    inline _GLIBCXX17_CONSTEXPR _BidirectionalIterator
                    prev(_BidirectionalIterator __x, typename
                	 iterator_traits<_BidirectionalIterator>::difference_type __n = 1) 
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<
                				  _BidirectionalIterator>)
                      std::advance(__x, -__n);
                      return __x;
                    }
                
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_ITERATOR_BASE_FUNCS_H */


Top 10 Lines:

     Line      Count

       98       4564
      138       4564

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

     9128   Total number of line executions
  4564.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Player.h:
                #ifndef PLAYER_P
                #define PLAYER_P
                
                #include <SFML/Graphics.hpp>
                
                #define DEFAULT_PLAYER_SPEED 1
                #define DEFAULT_PLAYER_STRENGTH 1
                #define DEFAULT_PLAYER_BOMBS 1
                
                // Enum PlayerType
                enum PlayerType
                {
                    PLAYER,
                    AI,
                };
                
                class GameState;
                class Game;
                
                enum Action {
                    NO_ACTION,
                    MOVE_UP,
                    MOVE_DOWN,
                    MOVE_LEFT,
                    MOVE_RIGHT,
                    PLACE_BOMB
                };
                
       37898 -> class Player
                {
                private:
                    int id;
                    int x;
                    int y;
                    int speed;
                    sf::Texture texture;
                    sf::Sprite sprite;
                    PlayerType type;
                    bool alive;
                
                    int strength;
                    int numBombs;
                
                    void move(int dx, int dy);
                
                public:
                    Player(int id, int x, int y, int speed, std::string texturePath, PlayerType type, int zoom);
                    void draw(sf::RenderWindow &window, int zoom);
                    void play(Action action, GameState &state);
                
                    void update(GameState &gamestate);
                
                    void die();
                    bool dropBomb();
      189572 ->     int getX() const { return x; }
      101334 ->     int getY() const { return y; }
                
         398 ->     int getStrength() const { return strength; }
       16901 ->     int getNumBombs() const { return numBombs; }
        1249 ->     void addBomb() { numBombs++; }
                
                    void addBonus(int type);
                
        8383 ->     bool isAlive() const { return alive; }
                    bool isLegalMove(int x, int y, GameState &state);
                };
                
                #endif // PLAYER_P

Top 10 Lines:

     Line      Count

       55     189572
       56     101334
       29      37898
       59      16901
       64       8383
       60       1249
       58        398

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

   355735   Total number of line executions
 50819.29   Average executions per line


*** File /usr/include/c++/11/bits/stl_construct.h:
                // nonstandard construct and destroy functions -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_construct.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_CONSTRUCT_H
                #define _STL_CONSTRUCT_H 1
                
                #include <new>
                #include <bits/move.h>
                #include <bits/stl_iterator_base_types.h> // for iterator_traits
                #include <bits/stl_iterator_base_funcs.h> // for advance
                
                /* This file provides the C++17 functions std::destroy_at, std::destroy, and
                 * std::destroy_n, and the C++20 function std::construct_at.
                 * It also provides std::_Construct, std::_Destroy,and std::_Destroy_n functions
                 * which are defined in all standard modes and so can be used in C++98-14 code.
                 * The _Destroy functions will dispatch to destroy_at during constant
                 * evaluation, because calls to that function are intercepted by the compiler
                 * to allow use in constant expressions.
                 */
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201703L
                  template <typename _Tp>
                    _GLIBCXX20_CONSTEXPR inline void
                    destroy_at(_Tp* __location)
                    {
                      if constexpr (__cplusplus > 201703L && is_array_v<_Tp>)
                	{
                	  for (auto& __x : *__location)
                	    std::destroy_at(std::__addressof(__x));
                	}
                      else
                	__location->~_Tp();
                    }
                
                #if __cplusplus >= 202002L
                  template<typename _Tp, typename... _Args>
                    constexpr auto
                    construct_at(_Tp* __location, _Args&&... __args)
                    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
                    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
                    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
                #endif // C++20
                #endif// C++17
                
                  /**
                   * Constructs an object in existing memory by invoking an allocated
                   * object's constructor with an initializer.
                   */
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename... _Args>
                    _GLIBCXX20_CONSTEXPR
                    inline void
      146614 ->     _Construct(_Tp* __p, _Args&&... __args)
                    {
                #if __cplusplus >= 202002L && __has_builtin(__builtin_is_constant_evaluated)
                      if (__builtin_is_constant_evaluated())
                	{
                	  // Allow std::_Construct to be used in constant expressions.
                	  std::construct_at(__p, std::forward<_Args>(__args)...);
                	  return;
                	}
                #endif
                      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
                    }
                #else
                  template<typename _T1, typename _T2>
                    inline void
                    _Construct(_T1* __p, const _T2& __value)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_]allocator::construct
                      ::new(static_cast<void*>(__p)) _T1(__value);
                    }
                #endif
                
                  template<typename _T1>
                    inline void
                    _Construct_novalue(_T1* __p)
                    { ::new((void*)__p) _T1; }
                
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last);
                
                  /**
                   * Destroy the object pointed to by a pointer type.
                   */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR inline void
      119620 ->     _Destroy(_Tp* __pointer)
                    {
                #if __cplusplus > 201703L
                      std::destroy_at(__pointer);
                #else
                      __pointer->~_Tp();
                #endif
                    }
                
                  template<bool>
                    struct _Destroy_aux
                    {
                      template<typename _ForwardIterator>
                	static _GLIBCXX20_CONSTEXPR void
       81890 -> 	__destroy(_ForwardIterator __first, _ForwardIterator __last)
                	{
                	  for (; __first != __last; ++__first)
                	    std::_Destroy(std::__addressof(*__first));
                	}
                    };
                
                  template<>
                    struct _Destroy_aux<true>
                    {
                      template<typename _ForwardIterator>
                        static void
       36543 ->         __destroy(_ForwardIterator, _ForwardIterator) { }
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR inline void
      118433 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return _Destroy_aux<false>::__destroy(__first, __last);
                #endif
                      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy(__first, __last);
                    }
                
                  template<bool>
                    struct _Destroy_n_aux
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _GLIBCXX20_CONSTEXPR _ForwardIterator
                	__destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  for (; __count > 0; (void)++__first, --__count)
                	    std::_Destroy(std::__addressof(*__first));
                	  return __first;
                	}
                    };
                
                  template<>
                    struct _Destroy_n_aux<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __destroy_n(_ForwardIterator __first, _Size __count)
                	{
                	  std::advance(__first, __count);
                	  return __first;
                	}
                    };
                
                  /**
                   * Destroy a range of objects.  If the value_type of the object has
                   * a trivial destructor, the compiler should optimize all of this
                   * away, otherwise the objects' destructors must be invoked.
                   */
                  template<typename _ForwardIterator, typename _Size>
                    _GLIBCXX20_CONSTEXPR inline _ForwardIterator
                    _Destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                                       _Value_type;
                #if __cplusplus >= 201103L
                      // A deleted destructor is trivial, this ensures we reject such types:
                      static_assert(is_destructible<_Value_type>::value,
                		    "value type is destructible");
                #endif
                #if __cplusplus > 201703L && defined __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return _Destroy_n_aux<false>::__destroy_n(__first, __count);
                #endif
                      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
                	__destroy_n(__first, __count);
                    }
                
                #if __cplusplus >= 201703L
                  template <typename _ForwardIterator>
                    _GLIBCXX20_CONSTEXPR inline void
                    destroy(_ForwardIterator __first, _ForwardIterator __last)
                    {
                      std::_Destroy(__first, __last);
                    }
                
                  template <typename _ForwardIterator, typename _Size>
                    _GLIBCXX20_CONSTEXPR inline _ForwardIterator
                    destroy_n(_ForwardIterator __first, _Size __count)
                    {
                      return std::_Destroy_n(__first, __count);
                    }
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_CONSTRUCT_H */


Top 10 Lines:

     Line      Count

      109     146614
      146     119620
      182     118433
      160      81890
      172      36543

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   503100   Total number of line executions
100620.00   Average executions per line


*** File /usr/include/c++/11/initializer_list:
                // std::initializer_list support -*- C++ -*-
                
                // Copyright (C) 2008-2021 Free Software Foundation, Inc.
                //
                // This file is part of GCC.
                //
                // GCC is free software; you can redistribute it and/or modify
                // it under the terms of the GNU General Public License as published by
                // the Free Software Foundation; either version 3, or (at your option)
                // any later version.
                //
                // GCC is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                //
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file initializer_list
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _INITIALIZER_LIST
                #define _INITIALIZER_LIST
                
                #pragma GCC system_header
                
                #if __cplusplus < 201103L
                # include <bits/c++0x_warning.h>
                #else // C++0x
                
                #pragma GCC visibility push(default)
                
                #include <bits/c++config.h>
                
                namespace std
                {
                  /// initializer_list
                  template<class _E>
                    class initializer_list
                    {
                    public:
                      typedef _E 		value_type;
                      typedef const _E& 	reference;
                      typedef const _E& 	const_reference;
                      typedef size_t 		size_type;
                      typedef const _E* 	iterator;
                      typedef const _E* 	const_iterator;
                
                    private:
                      iterator			_M_array;
                      size_type			_M_len;
                
                      // The compiler can call a private constructor.
                      constexpr initializer_list(const_iterator __a, size_type __l)
                      : _M_array(__a), _M_len(__l) { }
                
                    public:
                      constexpr initializer_list() noexcept
                      : _M_array(0), _M_len(0) { }
                
                      // Number of elements.
                      constexpr size_type
           1 ->       size() const noexcept { return _M_len; }
                
                      // First element.
                      constexpr const_iterator
           2 ->       begin() const noexcept { return _M_array; }
                
                      // One past the last element.
                      constexpr const_iterator
           1 ->       end() const noexcept { return begin() + size(); }
                    };
                
                  /**
                   *  @brief  Return an iterator pointing to the first element of
                   *          the initializer_list.
                   *  @param  __ils  Initializer list.
                   *  @relates initializer_list
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    begin(initializer_list<_Tp> __ils) noexcept
                    { return __ils.begin(); }
                
                  /**
                   *  @brief  Return an iterator pointing to one past the last element
                   *          of the initializer_list.
                   *  @param  __ils  Initializer list.
                   *  @relates initializer_list
                   */
                  template<class _Tp>
                    constexpr const _Tp*
                    end(initializer_list<_Tp> __ils) noexcept
                    { return __ils.end(); }
                }
                
                #pragma GCC visibility pop
                
                #endif // C++11
                
                #endif // _INITIALIZER_LIST


Top 10 Lines:

     Line      Count

       75          2
       71          1
       79          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        4   Total number of line executions
     1.33   Average executions per line


*** File /usr/include/c++/11/bits/vector.tcc:
                // Vector implementation (out of line) -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/vector.tcc
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _VECTOR_TCC
                #define _VECTOR_TCC 1
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    reserve(size_type __n)
                    {
                      if (__n > this->max_size())
                	__throw_length_error(__N("vector::reserve"));
                      if (this->capacity() < __n)
                	{
                	  const size_type __old_size = size();
                	  pointer __tmp;
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __tmp = this->_M_allocate(__n);
                	      _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  __tmp, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __tmp = _M_allocate_and_copy(__n,
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
                		_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	    }
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	  _M_deallocate(this->_M_impl._M_start,
                			this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_start);
                	  this->_M_impl._M_start = __tmp;
                	  this->_M_impl._M_finish = __tmp + __old_size;
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                #if __cplusplus > 201402L
                      typename vector<_Tp, _Alloc>::reference
                #else
                      void
                #endif
       64239 ->       vector<_Tp, _Alloc>::
                      emplace_back(_Args&&... __args)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::forward<_Args>(__args)...);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
                #if __cplusplus > 201402L
                	return back();
                #endif
                      }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
                    vector<_Tp, _Alloc>::
                #if __cplusplus >= 201103L
                    insert(const_iterator __position, const value_type& __x)
                #else
                    insert(iterator __position, const value_type& __x)
                #endif
                    {
                      const size_type __n = __position - begin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == end())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  {
                #if __cplusplus >= 201103L
                	    const auto __pos = begin() + (__position - cbegin());
                	    // __x could be an existing element of this vector, so make a
                	    // copy of it before _M_insert_aux moves elements around.
                	    _Temporary_value __x_copy(this, __x);
                	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
                #else
                	    _M_insert_aux(__position, __x);
                #endif
                	  }
                      else
                #if __cplusplus >= 201103L
                	_M_realloc_insert(begin() + (__position - cbegin()), __x);
                #else
                	_M_realloc_insert(__position, __x);
                #endif
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
        2199 ->     vector<_Tp, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                	_GLIBCXX_MOVE3(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      return __position;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    typename vector<_Tp, _Alloc>::iterator
         750 ->     vector<_Tp, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	{
                	  if (__last != end())
                	    _GLIBCXX_MOVE3(__last, end(), __first);
                	  _M_erase_at_end(__first.base() + (end() - __last));
                	}
                      return __first;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    vector<_Tp, _Alloc>&
           1 ->     vector<_Tp, _Alloc>::
                    operator=(const vector<_Tp, _Alloc>& __x)
                    {
                      if (&__x != this)
                	{
                	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
                #if __cplusplus >= 201103L
                	  if (_Alloc_traits::_S_propagate_on_copy_assign())
                	    {
                	      if (!_Alloc_traits::_S_always_equal()
                	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
                	        {
                		  // replacement allocator cannot free existing storage
                		  this->clear();
                		  _M_deallocate(this->_M_impl._M_start,
                				this->_M_impl._M_end_of_storage
                				- this->_M_impl._M_start);
                		  this->_M_impl._M_start = nullptr;
                		  this->_M_impl._M_finish = nullptr;
                		  this->_M_impl._M_end_of_storage = nullptr;
                		}
                	      std::__alloc_on_copy(_M_get_Tp_allocator(),
                				   __x._M_get_Tp_allocator());
                	    }
                #endif
                	  const size_type __xlen = __x.size();
                	  if (__xlen > capacity())
                	    {
                	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
                						   __x.end());
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __tmp;
                	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
                	    }
                	  else if (size() >= __xlen)
                	    {
                	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
                			    end(), _M_get_Tp_allocator());
                	    }
                	  else
                	    {
                	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
                			this->_M_impl._M_start);
                	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
                					  __x._M_impl._M_finish,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    }
                	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
                	}
                      return *this;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_assign(size_t __n, const value_type& __val)
                    {
                      if (__n > capacity())
                	{
                	  vector __tmp(__n, __val, _M_get_Tp_allocator());
                	  __tmp._M_impl._M_swap_data(this->_M_impl);
                	}
                      else if (__n > size())
                	{
                	  std::fill(begin(), end(), __val);
                	  const size_type __add = __n - size();
                	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                					  __add, __val, _M_get_Tp_allocator());
                	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
                	}
                      else
                        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_InputIterator __first, _InputIterator __last,
                		    std::input_iterator_tag)
                      {
                	pointer __cur(this->_M_impl._M_start);
                	for (; __first != __last && __cur != this->_M_impl._M_finish;
                	     ++__cur, (void)++__first)
                	  *__cur = *__first;
                	if (__first == __last)
                	  _M_erase_at_end(__cur);
                	else
                	  _M_range_insert(end(), __first, __last,
                			  std::__iterator_category(__first));
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		    std::forward_iterator_tag)
                      {
                	const size_type __len = std::distance(__first, __last);
                
                	if (__len > capacity())
                	  {
                	    _S_check_init_len(__len, _M_get_Tp_allocator());
                	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
                	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	    _M_deallocate(this->_M_impl._M_start,
                			  this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_start);
                	    this->_M_impl._M_start = __tmp;
                	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
                	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
                	  }
                	else if (size() >= __len)
                	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
                	else
                	  {
                	    _ForwardIterator __mid = __first;
                	    std::advance(__mid, size());
                	    std::copy(__first, __mid, this->_M_impl._M_start);
                	    const size_type __attribute__((__unused__)) __n = __len - size();
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_copy_a(__mid, __last,
                					  this->_M_impl._M_finish,
                					  _M_get_Tp_allocator());
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	  }
                      }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    auto
                    vector<_Tp, _Alloc>::
                    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
                    {
                      const auto __n = __position - cbegin();
                      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	if (__position == cend())
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     std::move(__v));
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_insert_aux(begin() + __n, std::move(__v));
                      else
                	_M_realloc_insert(begin() + __n, std::move(__v));
                
                      return iterator(this->_M_impl._M_start + __n);
                    }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      auto
                      vector<_Tp, _Alloc>::
                      _M_emplace_aux(const_iterator __position, _Args&&... __args)
                      -> iterator
                      {
                	const auto __n = __position - cbegin();
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  if (__position == cend())
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				       std::forward<_Args>(__args)...);
                	      ++this->_M_impl._M_finish;
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	    }
                	  else
                	    {
                	      // We need to construct a temporary because something in __args...
                	      // could alias one of the elements of the container and so we
                	      // need to use it before _M_insert_aux moves elements around.
                	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
                	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
                	    }
                	else
                	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
                
                	return iterator(this->_M_impl._M_start + __n);
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _Arg>
                      void
                      vector<_Tp, _Alloc>::
                      _M_insert_aux(iterator __position, _Arg&& __arg)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_insert_aux(iterator __position, const _Tp& __x)
                #endif
                    {
                      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish - 1)));
                      ++this->_M_impl._M_finish;
                      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                #if __cplusplus < 201103L
                      _Tp __x_copy = __x;
                #endif
                      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                			      this->_M_impl._M_finish - 2,
                			      this->_M_impl._M_finish - 1);
                #if __cplusplus < 201103L
                      *__position = __x_copy;
                #else
                      *__position = std::forward<_Arg>(__arg);
                #endif
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    template<typename... _Args>
                      void
       56939 ->       vector<_Tp, _Alloc>::
                      _M_realloc_insert(iterator __position, _Args&&... __args)
                #else
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_realloc_insert(iterator __position, const _Tp& __x)
                #endif
                    {
                      const size_type __len =
                	_M_check_len(size_type(1), "vector::_M_realloc_insert");
                      pointer __old_start = this->_M_impl._M_start;
                      pointer __old_finish = this->_M_impl._M_finish;
                      const size_type __elems_before = __position - begin();
                      pointer __new_start(this->_M_allocate(__len));
                      pointer __new_finish(__new_start);
                      __try
                	{
                	  // The order of the three operations is dictated by the C++11
                	  // case, where the moves could alter a new element belonging
                	  // to the existing vector.  This is an issue only for callers
                	  // taking the element by lvalue ref (see last bullet of C++11
                	  // [res.on.arguments]).
                	  _Alloc_traits::construct(this->_M_impl,
                				   __new_start + __elems_before,
                #if __cplusplus >= 201103L
                				   std::forward<_Args>(__args)...);
                #else
                				   __x);
                #endif
                	  __new_finish = pointer();
                
                #if __cplusplus >= 201103L
                	  if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                	    {
                	      __new_finish = _S_relocate(__old_start, __position.base(),
                					 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish = _S_relocate(__position.base(), __old_finish,
                					 __new_finish, _M_get_Tp_allocator());
                	    }
                	  else
                #endif
                	    {
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__old_start, __position.base(),
                		 __new_start, _M_get_Tp_allocator());
                
                	      ++__new_finish;
                
                	      __new_finish
                		= std::__uninitialized_move_if_noexcept_a
                		(__position.base(), __old_finish,
                		 __new_finish, _M_get_Tp_allocator());
                	    }
                	}
                      __catch(...)
                	{
                	  if (!__new_finish)
                	    _Alloc_traits::destroy(this->_M_impl,
                				   __new_start + __elems_before);
                	  else
                	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
                	  _M_deallocate(__new_start, __len);
                	  __throw_exception_again;
                	}
                #if __cplusplus >= 201103L
                      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
                #endif
                	std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      _M_deallocate(__old_start,
                		    this->_M_impl._M_end_of_storage - __old_start);
                      this->_M_impl._M_start = __new_start;
                      this->_M_impl._M_finish = __new_finish;
                      this->_M_impl._M_end_of_storage = __new_start + __len;
                    }
                
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
                    {
                      if (__n != 0)
                	{
                	  if (size_type(this->_M_impl._M_end_of_storage
                			- this->_M_impl._M_finish) >= __n)
                	    {
                #if __cplusplus < 201103L
                	      value_type __x_copy = __x;
                #else
                	      _Temporary_value __tmp(this, __x);
                	      value_type& __x_copy = __tmp._M_val();
                #endif
                	      const size_type __elems_after = end() - __position;
                	      pointer __old_finish(this->_M_impl._M_finish);
                	      if (__elems_after > __n)
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                					      this->_M_impl._M_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __n;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					  __old_finish - __n, __old_finish);
                		  std::fill(__position.base(), __position.base() + __n,
                			    __x_copy);
                		}
                	      else
                		{
                		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		  this->_M_impl._M_finish =
                		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
                						  __n - __elems_after,
                						  __x_copy,
                						  _M_get_Tp_allocator());
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		  std::__uninitialized_move_a(__position.base(), __old_finish,
                					      this->_M_impl._M_finish,
                					      _M_get_Tp_allocator());
                		  this->_M_impl._M_finish += __elems_after;
                		  _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		  std::fill(__position.base(), __old_finish, __x_copy);
                		}
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_fill_insert");
                	      const size_type __elems_before = __position - begin();
                	      pointer __new_start(this->_M_allocate(__len));
                	      pointer __new_finish(__new_start);
                	      __try
                		{
                		  // See _M_realloc_insert above.
                		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
                						__n, __x,
                						_M_get_Tp_allocator());
                		  __new_finish = pointer();
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (this->_M_impl._M_start, __position.base(),
                		     __new_start, _M_get_Tp_allocator());
                
                		  __new_finish += __n;
                
                		  __new_finish
                		    = std::__uninitialized_move_if_noexcept_a
                		    (__position.base(), this->_M_impl._M_finish,
                		     __new_finish, _M_get_Tp_allocator());
                		}
                	      __catch(...)
                		{
                		  if (!__new_finish)
                		    std::_Destroy(__new_start + __elems_before,
                				  __new_start + __elems_before + __n,
                				  _M_get_Tp_allocator());
                		  else
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		  _M_deallocate(__new_start, __len);
                		  __throw_exception_again;
                		}
                	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			    _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_finish;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, typename _Alloc>
                    void
                    vector<_Tp, _Alloc>::
                    _M_default_append(size_type __n)
                    {
                      if (__n != 0)
                	{
                	  const size_type __size = size();
                	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
                					 - this->_M_impl._M_finish);
                
                	  if (__size > max_size() || __navail > max_size() - __size)
                	    __builtin_unreachable();
                
                	  if (__navail >= __n)
                	    {
                	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                	      this->_M_impl._M_finish =
                		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
                						 __n, _M_get_Tp_allocator());
                	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                	    }
                	  else
                	    {
                	      const size_type __len =
                		_M_check_len(__n, "vector::_M_default_append");
                	      pointer __new_start(this->_M_allocate(__len));
                	      if _GLIBCXX17_CONSTEXPR (_S_use_relocate())
                		{
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		}
                	      else
                		{
                		  pointer __destroy_from = pointer();
                		  __try
                		    {
                		      std::__uninitialized_default_n_a(__new_start + __size,
                			      __n, _M_get_Tp_allocator());
                		      __destroy_from = __new_start + __size;
                		      std::__uninitialized_move_if_noexcept_a(
                			      this->_M_impl._M_start, this->_M_impl._M_finish,
                			      __new_start, _M_get_Tp_allocator());
                		    }
                		  __catch(...)
                		    {
                		      if (__destroy_from)
                			std::_Destroy(__destroy_from, __destroy_from + __n,
                				      _M_get_Tp_allocator());
                		      _M_deallocate(__new_start, __len);
                		      __throw_exception_again;
                		    }
                		  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                				_M_get_Tp_allocator());
                		}
                	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                	      _M_deallocate(this->_M_impl._M_start,
                			    this->_M_impl._M_end_of_storage
                			    - this->_M_impl._M_start);
                	      this->_M_impl._M_start = __new_start;
                	      this->_M_impl._M_finish = __new_start + __size + __n;
                	      this->_M_impl._M_end_of_storage = __new_start + __len;
                	    }
                	}
                    }
                
                  template<typename _Tp, typename _Alloc>
                    bool
                    vector<_Tp, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() == size())
                	return false;
                      _GLIBCXX_ASAN_ANNOTATE_REINIT;
                      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
                    }
                #endif
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _InputIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __pos, _InputIterator __first,
                		      _InputIterator __last, std::input_iterator_tag)
                      {
                	if (__pos == end())
                	  {
                	    for (; __first != __last; ++__first)
                	      insert(end(), *__first);
                	  }
                	else if (__first != __last)
                	  {
                	    vector __tmp(__first, __last, _M_get_Tp_allocator());
                	    insert(__pos,
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.begin()),
                		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.end()));
                	  }
                      }
                
                  template<typename _Tp, typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<_Tp, _Alloc>::
                      _M_range_insert(iterator __position, _ForwardIterator __first,
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    const size_type __n = std::distance(__first, __last);
                	    if (size_type(this->_M_impl._M_end_of_storage
                			  - this->_M_impl._M_finish) >= __n)
                	      {
                		const size_type __elems_after = end() - __position;
                		pointer __old_finish(this->_M_impl._M_finish);
                		if (__elems_after > __n)
                		  {
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
                						this->_M_impl._M_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
                		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                					    __old_finish - __n, __old_finish);
                		    std::copy(__first, __last, __position);
                		  }
                		else
                		  {
                		    _ForwardIterator __mid = __first;
                		    std::advance(__mid, __elems_after);
                		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
                		    std::__uninitialized_copy_a(__mid, __last,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __n - __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
                		    std::__uninitialized_move_a(__position.base(),
                						__old_finish,
                						this->_M_impl._M_finish,
                						_M_get_Tp_allocator());
                		    this->_M_impl._M_finish += __elems_after;
                		    _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
                		    std::copy(__first, __mid, __position);
                		  }
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector::_M_range_insert");
                		pointer __new_start(this->_M_allocate(__len));
                		pointer __new_finish(__new_start);
                		__try
                		  {
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (this->_M_impl._M_start, __position.base(),
                		       __new_start, _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_copy_a(__first, __last,
                						    __new_finish,
                						    _M_get_Tp_allocator());
                		    __new_finish
                		      = std::__uninitialized_move_if_noexcept_a
                		      (__position.base(), this->_M_impl._M_finish,
                		       __new_finish, _M_get_Tp_allocator());
                		  }
                		__catch(...)
                		  {
                		    std::_Destroy(__new_start, __new_finish,
                				  _M_get_Tp_allocator());
                		    _M_deallocate(__new_start, __len);
                		    __throw_exception_again;
                		  }
                		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                			      _M_get_Tp_allocator());
                		_GLIBCXX_ASAN_ANNOTATE_REINIT;
                		_M_deallocate(this->_M_impl._M_start,
                			      this->_M_impl._M_end_of_storage
                			      - this->_M_impl._M_start);
                		this->_M_impl._M_start = __new_start;
                		this->_M_impl._M_finish = __new_finish;
                		this->_M_impl._M_end_of_storage = __new_start + __len;
                	      }
                	  }
                      }
                
                
                  // vector<bool>
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_reallocate(size_type __n)
                    {
                      _Bit_pointer __q = this->_M_allocate(__n);
                      iterator __start(std::__addressof(*__q), 0);
                      iterator __finish(_M_copy_aligned(begin(), end(), __start));
                      this->_M_deallocate();
                      this->_M_impl._M_start = __start;
                      this->_M_impl._M_finish = __finish;
                      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
                    }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_fill_insert(iterator __position, size_type __n, bool __x)
                    {
                      if (__n == 0)
                	return;
                      if (capacity() - size() >= __n)
                	{
                	  std::copy_backward(__position, end(),
                			     this->_M_impl._M_finish + difference_type(__n));
                	  std::fill(__position, __position + difference_type(__n), __x);
                	  this->_M_impl._M_finish += difference_type(__n);
                	}
                      else
                	{
                	  const size_type __len = 
                	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  std::fill(__i, __i + difference_type(__n), __x);
                	  iterator __finish = std::copy(__position, end(),
                					__i + difference_type(__n));
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    template<typename _ForwardIterator>
                      void
                      vector<bool, _Alloc>::
                      _M_insert_range(iterator __position, _ForwardIterator __first, 
                		      _ForwardIterator __last, std::forward_iterator_tag)
                      {
                	if (__first != __last)
                	  {
                	    size_type __n = std::distance(__first, __last);
                	    if (capacity() - size() >= __n)
                	      {
                		std::copy_backward(__position, end(),
                				   this->_M_impl._M_finish
                				   + difference_type(__n));
                		std::copy(__first, __last, __position);
                		this->_M_impl._M_finish += difference_type(__n);
                	      }
                	    else
                	      {
                		const size_type __len =
                		  _M_check_len(__n, "vector<bool>::_M_insert_range");
                		_Bit_pointer __q = this->_M_allocate(__len);
                		iterator __start(std::__addressof(*__q), 0);
                		iterator __i = _M_copy_aligned(begin(), __position, __start);
                		__i = std::copy(__first, __last, __i);
                		iterator __finish = std::copy(__position, end(), __i);
                		this->_M_deallocate();
                		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                		this->_M_impl._M_start = __start;
                		this->_M_impl._M_finish = __finish;
                	      }
                	  }
                      }
                
                  template<typename _Alloc>
                    void
                    vector<bool, _Alloc>::
                    _M_insert_aux(iterator __position, bool __x)
                    {
                      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
                	{
                	  std::copy_backward(__position, this->_M_impl._M_finish, 
                			     this->_M_impl._M_finish + 1);
                	  *__position = __x;
                	  ++this->_M_impl._M_finish;
                	}
                      else
                	{
                	  const size_type __len =
                	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
                	  _Bit_pointer __q = this->_M_allocate(__len);
                	  iterator __start(std::__addressof(*__q), 0);
                	  iterator __i = _M_copy_aligned(begin(), __position, __start);
                	  *__i++ = __x;
                	  iterator __finish = std::copy(__position, end(), __i);
                	  this->_M_deallocate();
                	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
                	  this->_M_impl._M_start = __start;
                	  this->_M_impl._M_finish = __finish;
                	}
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __position)
                    {
                      if (__position + 1 != end())
                        std::copy(__position + 1, end(), __position);
                      --this->_M_impl._M_finish;
                      return __position;
                    }
                
                  template<typename _Alloc>
                    typename vector<bool, _Alloc>::iterator
                    vector<bool, _Alloc>::
                    _M_erase(iterator __first, iterator __last)
                    {
                      if (__first != __last)
                	_M_erase_at_end(std::copy(__last, end(), __first));
                      return __first;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _Alloc>
                    bool
                    vector<bool, _Alloc>::
                    _M_shrink_to_fit()
                    {
                      if (capacity() - size() < int(_S_word_bit))
                	return false;
                      __try
                	{
                	  if (size_type __n = size())
                	    _M_reallocate(__n);
                	  else
                	    {
                	      this->_M_deallocate();
                	      this->_M_impl._M_reset();
                	    }
                	  return true;
                	}
                      __catch(...)
                	{ return false; }
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #if __cplusplus >= 201103L
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Alloc>
                    size_t
                    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
                    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
                    {
                      size_t __hash = 0;
                      using _GLIBCXX_STD_C::_S_word_bit;
                      using _GLIBCXX_STD_C::_Bit_type;
                
                      const size_t __words = __b.size() / _S_word_bit;
                      if (__words)
                	{
                	  const size_t __clength = __words * sizeof(_Bit_type);
                	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
                	}
                
                      const size_t __extrabits = __b.size() % _S_word_bit;
                      if (__extrabits)
                	{
                	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
                	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
                
                	  const size_t __clength
                	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
                	  if (__words)
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
                	  else
                	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
                	}
                
                      return __hash;
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #undef _GLIBCXX_ASAN_ANNOTATE_REINIT
                #undef _GLIBCXX_ASAN_ANNOTATE_GROW
                #undef _GLIBCXX_ASAN_ANNOTATE_GREW
                #undef _GLIBCXX_ASAN_ANNOTATE_SHRINK
                
                #endif /* _VECTOR_TCC */


Top 10 Lines:

     Line      Count

      109      64239
      426      56939
      171       2199
      184        750
      198          1

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   124128   Total number of line executions
 24825.60   Average executions per line


*** File /usr/include/SFML/Graphics/RectangleShape.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_RECTANGLESHAPE_HPP
                #define SFML_RECTANGLESHAPE_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/Shape.hpp>
                
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Specialized shape representing a rectangle
                ///
                ////////////////////////////////////////////////////////////
         199 -> class SFML_GRAPHICS_API RectangleShape : public Shape
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// \param size Size of the rectangle
                    ///
                    ////////////////////////////////////////////////////////////
                    explicit RectangleShape(const Vector2f& size = Vector2f(0, 0));
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the size of the rectangle
                    ///
                    /// \param size New size of the rectangle
                    ///
                    /// \see getSize
                    ///
                    ////////////////////////////////////////////////////////////
                    void setSize(const Vector2f& size);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the size of the rectangle
                    ///
                    /// \return Size of the rectangle
                    ///
                    /// \see setSize
                    ///
                    ////////////////////////////////////////////////////////////
                    const Vector2f& getSize() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the number of points defining the shape
                    ///
                    /// \return Number of points of the shape. For rectangle
                    ///         shapes, this number is always 4.
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual std::size_t getPointCount() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get a point of the rectangle
                    ///
                    /// The returned point is in local coordinates, that is,
                    /// the shape's transforms (position, rotation, scale) are
                    /// not taken into account.
                    /// The result is undefined if \a index is out of the valid range.
                    ///
                    /// \param index Index of the point to get, in range [0 .. 3]
                    ///
                    /// \return index-th point of the shape
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual Vector2f getPoint(std::size_t index) const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    Vector2f m_size; ///< Size of the rectangle
                };
                
                } // namespace sf
                
                
                #endif // SFML_RECTANGLESHAPE_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::RectangleShape
                /// \ingroup graphics
                ///
                /// This class inherits all the functions of sf::Transformable
                /// (position, rotation, scale, bounds, ...) as well as the
                /// functions of sf::Shape (outline, color, texture, ...).
                ///
                /// Usage example:
                /// \code
                /// sf::RectangleShape rectangle;
                /// rectangle.setSize(sf::Vector2f(100, 50));
                /// rectangle.setOutlineColor(sf::Color::Red);
                /// rectangle.setOutlineThickness(5);
                /// rectangle.setPosition(10, 20);
                /// ...
                /// window.draw(rectangle);
                /// \endcode
                ///
                /// \see sf::Shape, sf::CircleShape, sf::ConvexShape
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       41        199

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      199   Total number of line executions
   199.00   Average executions per line


*** File /usr/include/c++/11/bits/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/alloc_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOC_TRAITS_H
                #define _ALLOC_TRAITS_H 1
                
                #include <bits/stl_construct.h>
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                # include <bits/allocator.h>
                # include <bits/ptr_traits.h>
                # include <ext/numeric_traits.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #if __cplusplus >= 201103L
                #define __cpp_lib_allocator_traits_is_always_equal 201411
                
                  /// @cond undocumented
                  struct __allocator_traits_base
                  {
                    template<typename _Tp, typename _Up, typename = void>
                      struct __rebind : __replace_first_arg<_Tp, _Up> { };
                
                    template<typename _Tp, typename _Up>
                      struct __rebind<_Tp, _Up,
                		      __void_t<typename _Tp::template rebind<_Up>::other>>
                      { using type = typename _Tp::template rebind<_Up>::other; };
                
                  protected:
                    template<typename _Tp>
                      using __pointer = typename _Tp::pointer;
                    template<typename _Tp>
                      using __c_pointer = typename _Tp::const_pointer;
                    template<typename _Tp>
                      using __v_pointer = typename _Tp::void_pointer;
                    template<typename _Tp>
                      using __cv_pointer = typename _Tp::const_void_pointer;
                    template<typename _Tp>
                      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
                    template<typename _Tp>
                      using __pocma = typename _Tp::propagate_on_container_move_assignment;
                    template<typename _Tp>
                      using __pocs = typename _Tp::propagate_on_container_swap;
                    template<typename _Tp>
                      using __equal = typename _Tp::is_always_equal;
                  };
                
                  template<typename _Alloc, typename _Up>
                    using __alloc_rebind
                      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
                  /// @endcond
                
                  /**
                   * @brief  Uniform interface to all allocator types.
                   * @headerfile memory
                   * @ingroup allocators
                   * @since C++11
                  */
                  template<typename _Alloc>
                    struct allocator_traits : __allocator_traits_base
                    {
                      /// The allocator type
                      typedef _Alloc allocator_type;
                      /// The allocated type
                      typedef typename _Alloc::value_type value_type;
                
                      /**
                       * @brief   The allocator's pointer type.
                       *
                       * @c Alloc::pointer if that type exists, otherwise @c value_type*
                      */
                      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;
                
                    private:
                      // Select _Func<_Alloc> or pointer_traits<pointer>::rebind<_Tp>
                      template<template<typename> class _Func, typename _Tp, typename = void>
                	struct _Ptr
                	{
                	  using type = typename pointer_traits<pointer>::template rebind<_Tp>;
                	};
                
                      template<template<typename> class _Func, typename _Tp>
                	struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
                	{
                	  using type = _Func<_Alloc>;
                	};
                
                      // Select _A2::difference_type or pointer_traits<_Ptr>::difference_type
                      template<typename _A2, typename _PtrT, typename = void>
                	struct _Diff
                	{ using type = typename pointer_traits<_PtrT>::difference_type; };
                
                      template<typename _A2, typename _PtrT>
                	struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
                	{ using type = typename _A2::difference_type; };
                
                      // Select _A2::size_type or make_unsigned<_DiffT>::type
                      template<typename _A2, typename _DiffT, typename = void>
                	struct _Size : make_unsigned<_DiffT> { };
                
                      template<typename _A2, typename _DiffT>
                	struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
                	{ using type = typename _A2::size_type; };
                
                    public:
                      /**
                       * @brief   The allocator's const pointer type.
                       *
                       * @c Alloc::const_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const value_type> </tt>
                      */
                      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;
                
                      /**
                       * @brief   The allocator's void pointer type.
                       *
                       * @c Alloc::void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<void> </tt>
                      */
                      using void_pointer = typename _Ptr<__v_pointer, void>::type;
                
                      /**
                       * @brief   The allocator's const void pointer type.
                       *
                       * @c Alloc::const_void_pointer if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::rebind<const void> </tt>
                      */
                      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;
                
                      /**
                       * @brief   The allocator's difference type
                       *
                       * @c Alloc::difference_type if that type exists, otherwise
                       * <tt> pointer_traits<pointer>::difference_type </tt>
                      */
                      using difference_type = typename _Diff<_Alloc, pointer>::type;
                
                      /**
                       * @brief   The allocator's size type
                       *
                       * @c Alloc::size_type if that type exists, otherwise
                       * <tt> make_unsigned<difference_type>::type </tt>
                      */
                      using size_type = typename _Size<_Alloc, difference_type>::type;
                
                      /**
                       * @brief   How the allocator is propagated on copy assignment
                       *
                       * @c Alloc::propagate_on_container_copy_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_copy_assignment
                	= __detected_or_t<false_type, __pocca, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on move assignment
                       *
                       * @c Alloc::propagate_on_container_move_assignment if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_move_assignment
                	= __detected_or_t<false_type, __pocma, _Alloc>;
                
                      /**
                       * @brief   How the allocator is propagated on swap
                       *
                       * @c Alloc::propagate_on_container_swap if that type exists,
                       * otherwise @c false_type
                      */
                      using propagate_on_container_swap
                	= __detected_or_t<false_type, __pocs, _Alloc>;
                
                      /**
                       * @brief   Whether all instances of the allocator type compare equal.
                       *
                       * @c Alloc::is_always_equal if that type exists,
                       * otherwise @c is_empty<Alloc>::type
                      */
                      using is_always_equal
                	= __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;
                
                      template<typename _Tp>
                	using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
                      template<typename _Tp>
                	using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
                
                    private:
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
                	-> decltype(__a.allocate(__n, __hint))
                	{ return __a.allocate(__n, __hint); }
                
                      template<typename _Alloc2>
                	static constexpr pointer
                	_S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
                	{ return __a.allocate(__n); }
                
                      template<typename _Tp, typename... _Args>
                	struct __construct_helper
                	{
                	  template<typename _Alloc2,
                	    typename = decltype(std::declval<_Alloc2*>()->construct(
                		  std::declval<_Tp*>(), std::declval<_Args>()...))>
                	    static true_type __test(int);
                
                	  template<typename>
                	    static false_type __test(...);
                
                	  using type = decltype(__test<_Alloc>(0));
                	};
                
                      template<typename _Tp, typename... _Args>
                	using __has_construct
                	  = typename __construct_helper<_Tp, _Args...>::type;
                
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX14_CONSTEXPR _Require<__has_construct<_Tp, _Args...>>
                	_S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
                	{ __a.construct(__p, std::forward<_Args>(__args)...); }
                
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX14_CONSTEXPR
                	_Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
                			       is_constructible<_Tp, _Args...>>>
                	_S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
                	{
                #if __cplusplus <= 201703L
                	  ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
                #else
                	  std::construct_at(__p, std::forward<_Args>(__args)...);
                #endif
                	}
                
                      template<typename _Alloc2, typename _Tp>
                	static _GLIBCXX14_CONSTEXPR auto
                	_S_destroy(_Alloc2& __a, _Tp* __p, int)
                	noexcept(noexcept(__a.destroy(__p)))
                	-> decltype(__a.destroy(__p))
                	{ __a.destroy(__p); }
                
                      template<typename _Alloc2, typename _Tp>
                	static _GLIBCXX14_CONSTEXPR void
                	_S_destroy(_Alloc2&, _Tp* __p, ...)
                	noexcept(std::is_nothrow_destructible<_Tp>::value)
                	{ std::_Destroy(__p); }
                
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_max_size(_Alloc2& __a, int)
                	-> decltype(__a.max_size())
                	{ return __a.max_size(); }
                
                      template<typename _Alloc2>
                	static constexpr size_type
                	_S_max_size(_Alloc2&, ...)
                	{
                	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	  // 2466. allocator_traits::max_size() default behavior is incorrect
                	  return __gnu_cxx::__numeric_traits<size_type>::__max
                	    / sizeof(value_type);
                	}
                
                      template<typename _Alloc2>
                	static constexpr auto
                	_S_select(_Alloc2& __a, int)
                	-> decltype(__a.select_on_container_copy_construction())
                	{ return __a.select_on_container_copy_construction(); }
                
                      template<typename _Alloc2>
                	static constexpr _Alloc2
                	_S_select(_Alloc2& __a, ...)
                	{ return __a; }
                
                    public:
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(_Alloc& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt> if that expression is
                       *  well-formed, otherwise returns @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
                      { return _S_allocate(__a, __n, __hint, 0); }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static _GLIBCXX20_CONSTEXPR void
                      deallocate(_Alloc& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Tp`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for Tp
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls <tt> __a.construct(__p, std::forward<Args>(__args)...) </tt>
                       *  if that expression is well-formed, otherwise uses placement-new
                       *  to construct an object of type @a _Tp at location @a __p from the
                       *  arguments @a __args...
                      */
                      template<typename _Tp, typename... _Args>
                	static _GLIBCXX20_CONSTEXPR auto
                	construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
                	noexcept(noexcept(_S_construct(__a, __p,
                				       std::forward<_Args>(__args)...)))
                	-> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
                	{ _S_construct(__a, __p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type @a _Tp
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p) if that expression is well-formed,
                       *  otherwise calls @c __p->~_Tp()
                      */
                      template<typename _Tp>
                	static _GLIBCXX20_CONSTEXPR void
                	destroy(_Alloc& __a, _Tp* __p)
                	noexcept(noexcept(_S_destroy(__a, __p, 0)))
                	{ _S_destroy(__a, __p, 0); }
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size() or @c numeric_limits<size_type>::max()
                       *
                       *  Returns @c __a.max_size() if that expression is well-formed,
                       *  otherwise returns @c numeric_limits<size_type>::max()
                      */
                      static _GLIBCXX20_CONSTEXPR size_type
                      max_size(const _Alloc& __a) noexcept
                      { return _S_max_size(__a, 0); }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs
                       *
                       *  Returns @c __rhs.select_on_container_copy_construction() if that
                       *  expression is well-formed, otherwise returns @a __rhs
                      */
                      static _GLIBCXX20_CONSTEXPR _Alloc
                      select_on_container_copy_construction(const _Alloc& __rhs)
                      { return _S_select(__rhs, 0); }
                    };
                
                #if __cplusplus > 201703L
                # define __cpp_lib_constexpr_dynamic_alloc 201907L
                #endif
                
                  /// Partial specialization for std::allocator.
                  template<typename _Tp>
                    struct allocator_traits<allocator<_Tp>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<_Tp>;
                
                      /// The allocated type
                      using value_type = _Tp;
                
                      /// The allocator's pointer type.
                      using pointer = _Tp*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const _Tp*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      /// Whether all instances of the allocator type compare equal.
                      using is_always_equal = true_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *
                       *  Calls @c a.allocate(n)
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
       95422 ->       allocate(allocator_type& __a, size_type __n)
                      { return __a.allocate(__n); }
                
                      /**
                       *  @brief  Allocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __n  The number of objects to allocate space for.
                       *  @param  __hint Aid to locality.
                       *  @return Memory of suitable size and alignment for @a n objects
                       *          of type @c value_type
                       *
                       *  Returns <tt> a.allocate(n, hint) </tt>
                      */
                      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
                      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
                      {
                #if __cplusplus <= 201703L
                	return __a.allocate(__n, __hint);
                #else
                	return __a.allocate(__n);
                #endif
                      }
                
                      /**
                       *  @brief  Deallocate memory.
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the memory to deallocate.
                       *  @param  __n  The number of objects space was allocated for.
                       *
                       *  Calls <tt> a.deallocate(p, n) </tt>
                      */
                      static _GLIBCXX20_CONSTEXPR void
       94339 ->       deallocate(allocator_type& __a, pointer __p, size_type __n)
                      { __a.deallocate(__p, __n); }
                
                      /**
                       *  @brief  Construct an object of type `_Up`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for
                       *	       an object of type `_Up`.
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
                       *  in C++11, C++14 and C++17. Changed in C++20 to call
                       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
                      */
                      template<typename _Up, typename... _Args>
                	static _GLIBCXX20_CONSTEXPR void
       76703 -> 	construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
                		  _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{
                #if __cplusplus <= 201703L
                	  __a.construct(__p, std::forward<_Args>(__args)...);
                #else
                	  std::construct_at(__p, std::forward<_Args>(__args)...);
                #endif
                	}
                
                      /**
                       *  @brief  Destroy an object of type @a _Up
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Calls @c __a.destroy(__p).
                      */
                      template<typename _Up>
                	static _GLIBCXX20_CONSTEXPR void
       13821 -> 	destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
                	noexcept(is_nothrow_destructible<_Up>::value)
                	{
                #if __cplusplus <= 201703L
                	  __a.destroy(__p);
                #else
                	  std::destroy_at(__p);
                #endif
                	}
                
                      /**
                       *  @brief  The maximum supported allocation size
                       *  @param  __a  An allocator.
                       *  @return @c __a.max_size()
                      */
                      static _GLIBCXX20_CONSTEXPR size_type
      113879 ->       max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
                      {
                #if __cplusplus <= 201703L
                	return __a.max_size();
                #else
                	return size_t(-1) / sizeof(value_type);
                #endif
                      }
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return @c __rhs
                      */
                      static _GLIBCXX20_CONSTEXPR allocator_type
       59344 ->       select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                  /// Explicit specialization for std::allocator<void>.
                  template<>
                    struct allocator_traits<allocator<void>>
                    {
                      /// The allocator type
                      using allocator_type = allocator<void>;
                
                      /// The allocated type
                      using value_type = void;
                
                      /// The allocator's pointer type.
                      using pointer = void*;
                
                      /// The allocator's const pointer type.
                      using const_pointer = const void*;
                
                      /// The allocator's void pointer type.
                      using void_pointer = void*;
                
                      /// The allocator's const void pointer type.
                      using const_void_pointer = const void*;
                
                      /// The allocator's difference type
                      using difference_type = std::ptrdiff_t;
                
                      /// The allocator's size type
                      using size_type = std::size_t;
                
                      /// How the allocator is propagated on copy assignment
                      using propagate_on_container_copy_assignment = false_type;
                
                      /// How the allocator is propagated on move assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      /// How the allocator is propagated on swap
                      using propagate_on_container_swap = false_type;
                
                      /// Whether all instances of the allocator type compare equal.
                      using is_always_equal = true_type;
                
                      template<typename _Up>
                	using rebind_alloc = allocator<_Up>;
                
                      template<typename _Up>
                	using rebind_traits = allocator_traits<allocator<_Up>>;
                
                      /// allocate is ill-formed for allocator<void>
                      static void*
                      allocate(allocator_type&, size_type, const void* = nullptr) = delete;
                
                      /// deallocate is ill-formed for allocator<void>
                      static void
                      deallocate(allocator_type&, void*, size_type) = delete;
                
                      /**
                       *  @brief  Construct an object of type `_Up`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to memory of suitable size and alignment for
                       *	       an object of type `_Up`.
                       *  @param  __args Constructor arguments.
                       *
                       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`
                       *  in C++11, C++14 and C++17. Changed in C++20 to call
                       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.
                      */
                      template<typename _Up, typename... _Args>
                	static _GLIBCXX20_CONSTEXPR void
                	construct(allocator_type&, _Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ std::_Construct(__p, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Destroy an object of type `_Up`
                       *  @param  __a  An allocator.
                       *  @param  __p  Pointer to the object to destroy
                       *
                       *  Invokes the destructor for `*__p`.
                      */
                      template<typename _Up>
                	static _GLIBCXX20_CONSTEXPR void
                	destroy(allocator_type&, _Up* __p)
                	noexcept(is_nothrow_destructible<_Up>::value)
                	{ std::_Destroy(__p); }
                
                      /// max_size is ill-formed for allocator<void>
                      static size_type
                      max_size(const allocator_type&) = delete;
                
                      /**
                       *  @brief  Obtain an allocator to use when copying a container.
                       *  @param  __rhs  An allocator.
                       *  @return `__rhs`
                      */
                      static _GLIBCXX20_CONSTEXPR allocator_type
                      select_on_container_copy_construction(const allocator_type& __rhs)
                      { return __rhs; }
                    };
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
                    { __one = __two; }
                
                  template<typename _Alloc>
                    inline void
                    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
       ##### ->     __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
                #if __cplusplus >= 201703L
                      if constexpr (__pocca::value)
                	__one = __two;
                #else
                      __do_alloc_on_copy(__one, __two, __pocca());
                #endif
                    }
                
                  template<typename _Alloc>
                    constexpr _Alloc
                    __alloc_on_copy(const _Alloc& __a)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      return __traits::select_on_container_copy_construction(__a);
                    }
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
                    { __one = std::move(__two); }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
       38340 ->     __alloc_on_move(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_move_assignment __pocma;
                #if __cplusplus >= 201703L
                      if constexpr (__pocma::value)
                	__one = std::move(__two);
                #else
                      __do_alloc_on_move(__one, __two, __pocma());
                #endif
                    }
                
                #if __cplusplus < 201703L
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
                    {
                      using std::swap;
                      swap(__one, __two);
                    }
                
                  template<typename _Alloc>
                    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
                    { }
                #endif
                
                  template<typename _Alloc>
                    _GLIBCXX14_CONSTEXPR inline void
                    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
                    {
                      typedef allocator_traits<_Alloc> __traits;
                      typedef typename __traits::propagate_on_container_swap __pocs;
                #if __cplusplus >= 201703L
                      if constexpr (__pocs::value)
                	{
                	  using std::swap;
                	  swap(__one, __two);
                	}
                #else
                      __do_alloc_on_swap(__one, __two, __pocs());
                #endif
                    }
                
                  template<typename _Alloc, typename _Tp,
                	   typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
                	   typename = void>
                    struct __is_alloc_insertable_impl
                    : false_type
                    { };
                
                  template<typename _Alloc, typename _Tp, typename _ValueT>
                    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
                      __void_t<decltype(allocator_traits<_Alloc>::construct(
                		   std::declval<_Alloc&>(), std::declval<_ValueT*>(),
                		   std::declval<_Tp>()))>>
                    : true_type
                    { };
                
                  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_copy_insertable
                    : __is_alloc_insertable_impl<_Alloc,
                				 typename _Alloc::value_type const&>::type
                    { };
                
                  // std::allocator<_Tp> just requires CopyConstructible
                  template<typename _Tp>
                    struct __is_copy_insertable<allocator<_Tp>>
                    : is_copy_constructible<_Tp>
                    { };
                
                  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc
                  // (might be wrong if _Alloc::construct exists but is not constrained,
                  // i.e. actually trying to use it would still be invalid. Use with caution.)
                  template<typename _Alloc>
                    struct __is_move_insertable
                    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
                    { };
                
                  // std::allocator<_Tp> just requires MoveConstructible
                  template<typename _Tp>
                    struct __is_move_insertable<allocator<_Tp>>
                    : is_move_constructible<_Tp>
                    { };
                
                  // Trait to detect Allocator-like types.
                  template<typename _Alloc, typename = void>
                    struct __is_allocator : false_type { };
                
                  template<typename _Alloc>
                    struct __is_allocator<_Alloc,
                      __void_t<typename _Alloc::value_type,
                	       decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
                    : true_type { };
                
                  template<typename _Alloc>
                    using _RequireAllocator
                      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;
                
                  template<typename _Alloc>
                    using _RequireNotAllocator
                      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
                
                #if __cpp_concepts >= 201907L
                  template<typename _Alloc>
                    concept __allocator_like = requires (_Alloc& __a) {
                      typename _Alloc::value_type;
                      __a.deallocate(__a.allocate(1u), 1u);
                    };
                #endif
                #endif // C++11
                
                  /**
                   * Destroy a range of objects using the supplied allocator.  For
                   * non-default allocators we do not optimize away invocation of
                   * destroy() even if _Tp has a trivial destructor.
                   */
                
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     _Allocator& __alloc)
                    {
                      for (; __first != __last; ++__first)
                #if __cplusplus < 201103L
                	__alloc.destroy(std::__addressof(*__first));
                #else
                	allocator_traits<_Allocator>::destroy(__alloc,
                					      std::__addressof(*__first));
                #endif
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
      118433 ->     _Destroy(_ForwardIterator __first, _ForwardIterator __last,
                	     allocator<_Tp>&)
                    {
                      _Destroy(__first, __last);
                    }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                #endif // _ALLOC_TRAITS_H


Top 10 Lines:

     Line      Count

      845     118433
      547     113879
      463      95422
      495      94339
      511      76703
      562      59344
      710      38340
      531      13821

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

   610281   Total number of line executions
 67809.00   Average executions per line


*** File /usr/include/SFML/Graphics/Text.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_TEXT_HPP
                #define SFML_TEXT_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/Drawable.hpp>
                #include <SFML/Graphics/Transformable.hpp>
                #include <SFML/Graphics/Font.hpp>
                #include <SFML/Graphics/Rect.hpp>
                #include <SFML/Graphics/VertexArray.hpp>
                #include <SFML/System/String.hpp>
                #include <string>
                #include <vector>
                
                
                namespace sf
                {
                ////////////////////////////////////////////////////////////
                /// \brief Graphical text that can be drawn to a render target
                ///
                ////////////////////////////////////////////////////////////
         796 -> class SFML_GRAPHICS_API Text : public Drawable, public Transformable
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Enumeration of the string drawing styles
                    ///
                    ////////////////////////////////////////////////////////////
                    enum Style
                    {
                        Regular       = 0,      ///< Regular characters, no style
                        Bold          = 1 << 0, ///< Bold characters
                        Italic        = 1 << 1, ///< Italic characters
                        Underlined    = 1 << 2, ///< Underlined characters
                        StrikeThrough = 1 << 3  ///< Strike through characters
                    };
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// Creates an empty text.
                    ///
                    ////////////////////////////////////////////////////////////
                    Text();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct the text from a string, font and size
                    ///
                    /// Note that if the used font is a bitmap font, it is not
                    /// scalable, thus not all requested sizes will be available
                    /// to use. This needs to be taken into consideration when
                    /// setting the character size. If you need to display text
                    /// of a certain size, make sure the corresponding bitmap
                    /// font that supports that size is used.
                    ///
                    /// \param string         Text assigned to the string
                    /// \param font           Font used to draw the string
                    /// \param characterSize  Base size of characters, in pixels
                    ///
                    ////////////////////////////////////////////////////////////
                    Text(const String& string, const Font& font, unsigned int characterSize = 30);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the text's string
                    ///
                    /// The \a string argument is a sf::String, which can
                    /// automatically be constructed from standard string types.
                    /// So, the following calls are all valid:
                    /// \code
                    /// text.setString("hello");
                    /// text.setString(L"hello");
                    /// text.setString(std::string("hello"));
                    /// text.setString(std::wstring(L"hello"));
                    /// \endcode
                    /// A text's string is empty by default.
                    ///
                    /// \param string New string
                    ///
                    /// \see getString
                    ///
                    ////////////////////////////////////////////////////////////
                    void setString(const String& string);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the text's font
                    ///
                    /// The \a font argument refers to a font that must
                    /// exist as long as the text uses it. Indeed, the text
                    /// doesn't store its own copy of the font, but rather keeps
                    /// a pointer to the one that you passed to this function.
                    /// If the font is destroyed and the text tries to
                    /// use it, the behavior is undefined.
                    ///
                    /// \param font New font
                    ///
                    /// \see getFont
                    ///
                    ////////////////////////////////////////////////////////////
                    void setFont(const Font& font);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the character size
                    ///
                    /// The default size is 30.
                    ///
                    /// Note that if the used font is a bitmap font, it is not
                    /// scalable, thus not all requested sizes will be available
                    /// to use. This needs to be taken into consideration when
                    /// setting the character size. If you need to display text
                    /// of a certain size, make sure the corresponding bitmap
                    /// font that supports that size is used.
                    ///
                    /// \param size New character size, in pixels
                    ///
                    /// \see getCharacterSize
                    ///
                    ////////////////////////////////////////////////////////////
                    void setCharacterSize(unsigned int size);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the line spacing factor
                    ///
                    /// The default spacing between lines is defined by the font.
                    /// This method enables you to set a factor for the spacing
                    /// between lines. By default the line spacing factor is 1.
                    ///
                    /// \param spacingFactor New line spacing factor
                    ///
                    /// \see getLineSpacing
                    ///
                    ////////////////////////////////////////////////////////////
                    void setLineSpacing(float spacingFactor);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the letter spacing factor
                    ///
                    /// The default spacing between letters is defined by the font.
                    /// This factor doesn't directly apply to the existing
                    /// spacing between each character, it rather adds a fixed
                    /// space between them which is calculated from the font
                    /// metrics and the character size.
                    /// Note that factors below 1 (including negative numbers) bring
                    /// characters closer to each other.
                    /// By default the letter spacing factor is 1.
                    ///
                    /// \param spacingFactor New letter spacing factor
                    ///
                    /// \see getLetterSpacing
                    ///
                    ////////////////////////////////////////////////////////////
                    void setLetterSpacing(float spacingFactor);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the text's style
                    ///
                    /// You can pass a combination of one or more styles, for
                    /// example sf::Text::Bold | sf::Text::Italic.
                    /// The default style is sf::Text::Regular.
                    ///
                    /// \param style New style
                    ///
                    /// \see getStyle
                    ///
                    ////////////////////////////////////////////////////////////
                    void setStyle(Uint32 style);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the fill color of the text
                    ///
                    /// By default, the text's fill color is opaque white.
                    /// Setting the fill color to a transparent color with an outline
                    /// will cause the outline to be displayed in the fill area of the text.
                    ///
                    /// \param color New fill color of the text
                    ///
                    /// \see getFillColor
                    ///
                    /// \deprecated There is now fill and outline colors instead
                    /// of a single global color.
                    /// Use setFillColor() or setOutlineColor() instead.
                    ///
                    ////////////////////////////////////////////////////////////
                    SFML_DEPRECATED void setColor(const Color& color);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the fill color of the text
                    ///
                    /// By default, the text's fill color is opaque white.
                    /// Setting the fill color to a transparent color with an outline
                    /// will cause the outline to be displayed in the fill area of the text.
                    ///
                    /// \param color New fill color of the text
                    ///
                    /// \see getFillColor
                    ///
                    ////////////////////////////////////////////////////////////
                    void setFillColor(const Color& color);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the outline color of the text
                    ///
                    /// By default, the text's outline color is opaque black.
                    ///
                    /// \param color New outline color of the text
                    ///
                    /// \see getOutlineColor
                    ///
                    ////////////////////////////////////////////////////////////
                    void setOutlineColor(const Color& color);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the thickness of the text's outline
                    ///
                    /// By default, the outline thickness is 0.
                    ///
                    /// Be aware that using a negative value for the outline
                    /// thickness will cause distorted rendering.
                    ///
                    /// \param thickness New outline thickness, in pixels
                    ///
                    /// \see getOutlineThickness
                    ///
                    ////////////////////////////////////////////////////////////
                    void setOutlineThickness(float thickness);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the text's string
                    ///
                    /// The returned string is a sf::String, which can automatically
                    /// be converted to standard string types. So, the following
                    /// lines of code are all valid:
                    /// \code
                    /// sf::String   s1 = text.getString();
                    /// std::string  s2 = text.getString();
                    /// std::wstring s3 = text.getString();
                    /// \endcode
                    ///
                    /// \return Text's string
                    ///
                    /// \see setString
                    ///
                    ////////////////////////////////////////////////////////////
                    const String& getString() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the text's font
                    ///
                    /// If the text has no font attached, a NULL pointer is returned.
                    /// The returned pointer is const, which means that you
                    /// cannot modify the font when you get it from this function.
                    ///
                    /// \return Pointer to the text's font
                    ///
                    /// \see setFont
                    ///
                    ////////////////////////////////////////////////////////////
                    const Font* getFont() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the character size
                    ///
                    /// \return Size of the characters, in pixels
                    ///
                    /// \see setCharacterSize
                    ///
                    ////////////////////////////////////////////////////////////
                    unsigned int getCharacterSize() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the size of the letter spacing factor
                    ///
                    /// \return Size of the letter spacing factor
                    ///
                    /// \see setLetterSpacing
                    ///
                    ////////////////////////////////////////////////////////////
                    float getLetterSpacing() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the size of the line spacing factor
                    ///
                    /// \return Size of the line spacing factor
                    ///
                    /// \see setLineSpacing
                    ///
                    ////////////////////////////////////////////////////////////
                    float getLineSpacing() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the text's style
                    ///
                    /// \return Text's style
                    ///
                    /// \see setStyle
                    ///
                    ////////////////////////////////////////////////////////////
                    Uint32 getStyle() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the fill color of the text
                    ///
                    /// \return Fill color of the text
                    ///
                    /// \see setFillColor
                    ///
                    /// \deprecated There is now fill and outline colors instead
                    /// of a single global color.
                    /// Use getFillColor() or getOutlineColor() instead.
                    ///
                    ////////////////////////////////////////////////////////////
                    SFML_DEPRECATED const Color& getColor() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the fill color of the text
                    ///
                    /// \return Fill color of the text
                    ///
                    /// \see setFillColor
                    ///
                    ////////////////////////////////////////////////////////////
                    const Color& getFillColor() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the outline color of the text
                    ///
                    /// \return Outline color of the text
                    ///
                    /// \see setOutlineColor
                    ///
                    ////////////////////////////////////////////////////////////
                    const Color& getOutlineColor() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the outline thickness of the text
                    ///
                    /// \return Outline thickness of the text, in pixels
                    ///
                    /// \see setOutlineThickness
                    ///
                    ////////////////////////////////////////////////////////////
                    float getOutlineThickness() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Return the position of the \a index-th character
                    ///
                    /// This function computes the visual position of a character
                    /// from its index in the string. The returned position is
                    /// in global coordinates (translation, rotation, scale and
                    /// origin are applied).
                    /// If \a index is out of range, the position of the end of
                    /// the string is returned.
                    ///
                    /// \param index Index of the character
                    ///
                    /// \return Position of the character
                    ///
                    ////////////////////////////////////////////////////////////
                    Vector2f findCharacterPos(std::size_t index) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the local bounding rectangle of the entity
                    ///
                    /// The returned rectangle is in local coordinates, which means
                    /// that it ignores the transformations (translation, rotation,
                    /// scale, ...) that are applied to the entity.
                    /// In other words, this function returns the bounds of the
                    /// entity in the entity's coordinate system.
                    ///
                    /// \return Local bounding rectangle of the entity
                    ///
                    ////////////////////////////////////////////////////////////
                    FloatRect getLocalBounds() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the global bounding rectangle of the entity
                    ///
                    /// The returned rectangle is in global coordinates, which means
                    /// that it takes into account the transformations (translation,
                    /// rotation, scale, ...) that are applied to the entity.
                    /// In other words, this function returns the bounds of the
                    /// text in the global 2D world's coordinate system.
                    ///
                    /// \return Global bounding rectangle of the entity
                    ///
                    ////////////////////////////////////////////////////////////
                    FloatRect getGlobalBounds() const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Draw the text to a render target
                    ///
                    /// \param target Render target to draw to
                    /// \param states Current render states
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual void draw(RenderTarget& target, RenderStates states) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Make sure the text's geometry is updated
                    ///
                    /// All the attributes related to rendering are cached, such
                    /// that the geometry is only updated when necessary.
                    ///
                    ////////////////////////////////////////////////////////////
                    void ensureGeometryUpdate() const;
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    String              m_string;              ///< String to display
                    const Font*         m_font;                ///< Font used to display the string
                    unsigned int        m_characterSize;       ///< Base size of characters, in pixels
                    float               m_letterSpacingFactor; ///< Spacing factor between letters
                    float               m_lineSpacingFactor;   ///< Spacing factor between lines
                    Uint32              m_style;               ///< Text style (see Style enum)
                    Color               m_fillColor;           ///< Text fill color
                    Color               m_outlineColor;        ///< Text outline color
                    float               m_outlineThickness;    ///< Thickness of the text's outline
                    mutable VertexArray m_vertices;            ///< Vertex array containing the fill geometry
                    mutable VertexArray m_outlineVertices;     ///< Vertex array containing the outline geometry
                    mutable FloatRect   m_bounds;              ///< Bounding rectangle of the text (in local coordinates)
                    mutable bool        m_geometryNeedUpdate;  ///< Does the geometry need to be recomputed?
                    mutable Uint64      m_fontTextureId;       ///< The font texture id
                };
                
                } // namespace sf
                
                
                #endif // SFML_TEXT_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::Text
                /// \ingroup graphics
                ///
                /// sf::Text is a drawable class that allows to easily display
                /// some text with custom style and color on a render target.
                ///
                /// It inherits all the functions from sf::Transformable:
                /// position, rotation, scale, origin. It also adds text-specific
                /// properties such as the font to use, the character size,
                /// the font style (bold, italic, underlined and strike through), the
                /// text color, the outline thickness, the outline color, the character
                /// spacing, the line spacing and the text to display of course.
                /// It also provides convenience functions to calculate the
                /// graphical size of the text, or to get the global position
                /// of a given character.
                ///
                /// sf::Text works in combination with the sf::Font class, which
                /// loads and provides the glyphs (visual characters) of a given font.
                ///
                /// The separation of sf::Font and sf::Text allows more flexibility
                /// and better performances: indeed a sf::Font is a heavy resource,
                /// and any operation on it is slow (often too slow for real-time
                /// applications). On the other side, a sf::Text is a lightweight
                /// object which can combine the glyphs data and metrics of a sf::Font
                /// to display any text on a render target.
                ///
                /// It is important to note that the sf::Text instance doesn't
                /// copy the font that it uses, it only keeps a reference to it.
                /// Thus, a sf::Font must not be destructed while it is
                /// used by a sf::Text (i.e. never write a function that
                /// uses a local sf::Font instance for creating a text).
                ///
                /// See also the note on coordinates and undistorted rendering in sf::Transformable.
                ///
                /// Usage example:
                /// \code
                /// // Declare and load a font
                /// sf::Font font;
                /// font.loadFromFile("arial.ttf");
                ///
                /// // Create a text
                /// sf::Text text("hello", font);
                /// text.setCharacterSize(30);
                /// text.setStyle(sf::Text::Bold);
                /// text.setFillColor(sf::Color::Red);
                ///
                /// // Draw it
                /// window.draw(text);
                /// \endcode
                ///
                /// \see sf::Font, sf::Transformable
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       48        796

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      796   Total number of line executions
   796.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Level.h:
                
                #ifndef LEVEL_H
                #define LEVEL_H
                
                #include <SFML/Graphics.hpp>
                #include <string>
                #include <vector>
                
                class Bomb;
                class GameState;
                
       25341 -> class Level {
                private:
                    std::vector<std::string> levelData;
                    size_t width;
                    size_t height;
                
                    std::vector<std::pair<int, int>> spawnPositions;
                
                public:
                    // return a vector of all Bombs
                    std::vector<Bomb> load(unsigned int levelNumber);
                    void draw(sf::RenderWindow &window, int zoom);
                
                    bool isEmpty(int x, int y);
                    bool isDestroyable(int x, int y);
                    bool isundestroyWall(int x, int y);
                    void destroyWall(int x, int y);
                
           1 ->     size_t getWidth() const { return width; }
           1 ->     size_t getHeight() const { return height; }
           1 ->     std::vector<std::pair<int, int>> getSpawnPositions() const {
                        return spawnPositions;
                    }
                };
                
                #endif // LEVEL_H

Top 10 Lines:

     Line      Count

       12      25341
       30          1
       31          1
       32          1

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

    25344   Total number of line executions
  6336.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Flame.h:
                #ifndef FLAME_H
                #define FLAME_H
                
                #include <SFML/Graphics.hpp>
                
                #define DEFAULT_FLAME_TIMER 1
                
       25165 -> class Flame
                {
                private:
                    int x;
                    int y;
                    int time_left;
                    
                    sf::Texture texture;
                    sf::Sprite sprite;
                
                public:
                    Flame();
                    Flame(int x, int y);
                    void draw(sf::RenderWindow &window, int zoom);
                    void update();
        2746 ->     int getX() const { return x; }
          24 ->     int getY() const { return y; }
        4706 ->     int getTimeLeft() const { return time_left; }
                    void changeTexture();
                };
                
                #endif // FLAME_H

Top 10 Lines:

     Line      Count

        8      25165
       25       4706
       23       2746
       24         24

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

    32641   Total number of line executions
  8160.25   Average executions per line


*** File /usr/include/c++/11/ext/new_allocator.h:
                // Allocator that wraps operator new -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/new_allocator.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _NEW_ALLOCATOR_H
                #define _NEW_ALLOCATOR_H 1
                
                #include <bits/c++config.h>
                #include <new>
                #include <bits/functexcept.h>
                #include <bits/move.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].
                   *  @ingroup allocators
                   *
                   *  This is precisely the allocator defined in the C++ Standard.
                   *    - all allocation calls operator new
                   *    - all deallocation calls operator delete
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class new_allocator
                    {
                    public:
                      typedef _Tp        value_type;
                      typedef std::size_t     size_type;
                      typedef std::ptrdiff_t  difference_type;
                #if __cplusplus <= 201703L
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef new_allocator<_Tp1> other; };
                #endif
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. propagate_on_container_move_assignment
                      typedef std::true_type propagate_on_container_move_assignment;
                #endif
                
                      _GLIBCXX20_CONSTEXPR
       19600 ->       new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      _GLIBCXX20_CONSTEXPR
      195370 ->       new_allocator(const new_allocator&) _GLIBCXX_USE_NOEXCEPT { }
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
                	new_allocator(const new_allocator<_Tp1>&) _GLIBCXX_USE_NOEXCEPT { }
                
                #if __cplusplus <= 201703L
      212310 ->       ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }
                
                      pointer
                      address(reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                
                      const_pointer
                      address(const_reference __x) const _GLIBCXX_NOEXCEPT
                      { return std::__addressof(__x); }
                #endif
                
                      // NB: __n is permitted to be 0.  The C++ standard says nothing
                      // about what the return value is when __n == 0.
                      _GLIBCXX_NODISCARD _Tp*
       95422 ->       allocate(size_type __n, const void* = static_cast<const void*>(0))
                      {
                #if __cplusplus >= 201103L
                	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	 // 3308. std::allocator<void>().allocate(n)
                	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
                #endif
                
                	if (__builtin_expect(__n > this->_M_max_size(), false))
                	  {
                	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
                	    // 3190. allocator::allocate sometimes returns too little storage
                	    if (__n > (std::size_t(-1) / sizeof(_Tp)))
                	      std::__throw_bad_array_new_length();
                	    std::__throw_bad_alloc();
                	  }
                
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    std::align_val_t __al = std::align_val_t(alignof(_Tp));
                	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
                	  }
                #endif
                	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                      }
                
                      // __p is not permitted to be a null pointer.
                      void
       94339 ->       deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
                      {
                #if __cpp_aligned_new
                	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
                	  {
                	    ::operator delete(__p,
                # if __cpp_sized_deallocation
                			      __t * sizeof(_Tp),
                # endif
                			      std::align_val_t(alignof(_Tp)));
                	    return;
                	  }
                #endif
                	::operator delete(__p
                #if __cpp_sized_deallocation
                			  , __t * sizeof(_Tp)
                #endif
                			 );
                      }
                
                #if __cplusplus <= 201703L
                      size_type
      113879 ->       max_size() const _GLIBCXX_USE_NOEXCEPT
                      { return _M_max_size(); }
                
                #if __cplusplus >= 201103L
                      template<typename _Up, typename... _Args>
                	void
       76703 -> 	construct(_Up* __p, _Args&&... __args)
                	noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
                	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
                
                      template<typename _Up>
                	void
       13821 -> 	destroy(_Up* __p)
                	noexcept(std::is_nothrow_destructible<_Up>::value)
                	{ __p->~_Up(); }
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 402. wrong new expression in [some_] allocator::construct
                      void
                      construct(pointer __p, const _Tp& __val)
                      { ::new((void *)__p) _Tp(__val); }
                
                      void
                      destroy(pointer __p) { __p->~_Tp(); }
                #endif
                #endif // ! C++20
                
                      template<typename _Up>
                	friend _GLIBCXX20_CONSTEXPR bool
                	operator==(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                      template<typename _Up>
                	friend _GLIBCXX20_CONSTEXPR bool
                	operator!=(const new_allocator&, const new_allocator<_Up>&)
                	_GLIBCXX_NOTHROW
                	{ return false; }
                #endif
                
                    private:
                      _GLIBCXX_CONSTEXPR size_type
      209301 ->       _M_max_size() const _GLIBCXX_USE_NOEXCEPT
                      {
                #if __PTRDIFF_MAX__ < __SIZE_MAX__
                	return std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);
                #else
                	return std::size_t(-1) / sizeof(_Tp);
                #endif
                      }
                    };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif


Top 10 Lines:

     Line      Count

       89     212310
      197     209301
       82     195370
      154     113879
      103      95422
      132      94339
      160      76703
       79      19600
      166      13821

Execution Summary:

        9   Executable lines in this file
        9   Lines executed
   100.00   Percent of the file executed

  1030745   Total number of line executions
114527.22   Average executions per line


*** File /usr/include/c++/11/bits/stl_uninitialized.h:
                // Raw memory manipulators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996,1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_uninitialized.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _STL_UNINITIALIZED_H
                #define _STL_UNINITIALIZED_H 1
                
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #include <bits/stl_algobase.h>    // copy
                #include <ext/alloc_traits.h>     // __alloc_traits
                
                #if __cplusplus >= 201703L
                #include <bits/stl_pair.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /** @addtogroup memory
                   *  @{
                   */
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueTypes>
                    struct __uninitialized_copy
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
       68647 ->         __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        {
                	  _ForwardIterator __cur = __result;
                	  __try
                	    {
                	      for (; __first != __last; ++__first, (void)++__cur)
                		std::_Construct(std::__addressof(*__cur), *__first);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__result, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_copy<true>
                    {
                      template<typename _InputIterator, typename _ForwardIterator>
                        static _ForwardIterator
                        __uninit_copy(_InputIterator __first, _InputIterator __last,
                		      _ForwardIterator __result)
                        { return std::copy(__first, __last, __result); }
                    };
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                   *
                   *  Like copy(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
       68647 ->     uninitialized_copy(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::copy
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
                	  "result type must be constructible from value type of input range");
                
                      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
                      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
                      // Trivial types can have deleted assignment, so using std::copy
                      // would be ill-formed. Require assignability before using std::copy:
                      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;
                #endif
                
                      return std::__uninitialized_copy<__is_trivial(_ValueType1)
                				       && __is_trivial(_ValueType2)
                				       && __assignable>::
                	__uninit_copy(__first, __last, __result);
                    }
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill<true>
                    {
                      template<typename _ForwardIterator, typename _Tp>
                        static void
                        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
                		      const _Tp& __x)
                        { std::fill(__first, __last, __x); }
                    };
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the value x into the range [first,last).
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
                		       const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                #if __cplusplus < 201103L
                      const bool __assignable = true;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill
                      // would be ill-formed. Require assignability before using std::fill:
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                #endif
                
                      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
                	__uninit_fill(__first, __last, __x);
                    }
                
                  /// @cond undocumented
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_fill_n
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
       ##### ->         __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur), __x);
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_fill_n<true>
                    {
                      template<typename _ForwardIterator, typename _Size, typename _Tp>
                        static _ForwardIterator
                        __uninit_fill_n(_ForwardIterator __first, _Size __n,
                			const _Tp& __x)
                        { return std::fill_n(__first, __n, __x); }
                    };
                
                  /// @endcond
                
                   // _GLIBCXX_RESOLVE_LIB_DEFECTS
                   // DR 1339. uninitialized_fill_n should return the end of its range
                  /**
                   *  @brief Copies the value x into the range [first,first+n).
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of copies to make.
                   *  @param  __x      The source value.
                   *  @return   Nothing.
                   *
                   *  Like fill_n(), but does not require an initialized output range.
                  */
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
       ##### ->     uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      // Trivial types do not need a constructor to begin their lifetime,
                      // so try to use std::fill_n to benefit from its memmove optimization.
                      // For arbitrary class types and floating point types we can't assume
                      // that __n > 0 and std::__size_to_integer(__n) > 0 are equivalent,
                      // so only use std::fill_n when _Size is already an integral type.
                #if __cplusplus < 201103L
                      const bool __can_fill = __is_integer<_Size>::__value;
                #else
                      // Trivial types can have deleted copy constructor, but the std::fill_n
                      // optimization that uses memmove would happily "copy" them anyway.
                      static_assert(is_constructible<_ValueType, const _Tp&>::value,
                	  "result type must be constructible from input type");
                
                      // Trivial types can have deleted assignment, so using std::fill_n
                      // would be ill-formed. Require assignability before using std::fill_n:
                      constexpr bool __can_fill
                	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
                #endif
                      return __uninitialized_fill_n<__is_trivial(_ValueType) && __can_fill>::
                	__uninit_fill_n(__first, __n, __x);
                    }
                
                  /// @cond undocumented
                
                  // Extensions: versions of uninitialized_copy, uninitialized_fill,
                  //  and uninitialized_fill_n that take an allocator parameter.
                  //  We dispatch back to the standard versions when we're given the
                  //  default allocator.  For nondefault allocators we do not use 
                  //  any of the POD optimizations.
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __first != __last; ++__first, (void)++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
                    inline _ForwardIterator
       68647 ->     __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, allocator<_Tp>&)
                    { return std::uninitialized_copy(__first, __last, __result); }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
                			   _ForwardIterator __result, _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
                					 __result, __alloc);
                    }
                
                  template<typename _InputIterator, typename _ForwardIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
        9302 ->     __uninitialized_move_if_noexcept_a(_InputIterator __first,
                				       _InputIterator __last,
                				       _ForwardIterator __result,
                				       _Allocator& __alloc)
                    {
                      return std::__uninitialized_copy_a
                	(_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
                    void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
                    inline void
                    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
                			   const _Tp& __x, allocator<_Tp2>&)
                    { std::uninitialized_fill(__first, __last, __x); }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Allocator>
                    _ForwardIterator
                    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur), __x);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Size, typename _Tp,
                	   typename _Tp2>
                    inline _ForwardIterator
       ##### ->     __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n, 
                			     const _Tp& __x, allocator<_Tp2>&)
                    { return std::uninitialized_fill_n(__first, __n, __x); }
                
                
                  // Extensions: __uninitialized_copy_move, __uninitialized_move_copy,
                  // __uninitialized_fill_move, __uninitialized_move_fill.
                  // All of these algorithms take a user-supplied allocator, which is used
                  // for construction and destruction.
                
                  // __uninitialized_copy_move
                  // Copies [first1, last1) into [result, result + (last1 - first1)), and
                  //  move [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_copy_move(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_copy
                  // Moves [first1, last1) into [result, result + (last1 - first1)), and
                  //  copies [first2, last2) into
                  //  [result, result + (last1 - first1) + (last2 - first2)).
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _ForwardIterator, typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_move_copy(_InputIterator1 __first1,
                			      _InputIterator1 __last1,
                			      _InputIterator2 __first2,
                			      _InputIterator2 __last2,
                			      _ForwardIterator __result,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
                							   __result,
                							   __alloc);
                      __try
                	{
                	  return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                  
                  // __uninitialized_fill_move
                  // Fills [result, mid) with x, and moves [first, last) into
                  //  [mid, mid + (last - first)).
                  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
                	   typename _Allocator>
                    inline _ForwardIterator
                    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
                			      const _Tp& __x, _InputIterator __first,
                			      _InputIterator __last, _Allocator& __alloc)
                    {
                      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
                      __try
                	{
                	  return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __mid, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_move_fill
                  // Moves [first1, last1) into [first2, first2 + (last1 - first1)), and
                  //  fills [first2 + (last1 - first1), last2) with x.
                  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
                	   typename _Allocator>
                    inline void
                    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
                			      _ForwardIterator __first2,
                			      _ForwardIterator __last2, const _Tp& __x,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
                							    __first2,
                							    __alloc);
                      __try
                	{
                	  std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first2, __mid2, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  /// @endcond
                
                #if __cplusplus >= 201103L
                  /// @cond undocumented
                
                  // Extensions: __uninitialized_default, __uninitialized_default_n,
                  // __uninitialized_default_a, __uninitialized_default_n_a.
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_1
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
                        {
                	  if (__first == __last)
                	    return;
                
                	  typename iterator_traits<_ForwardIterator>::value_type* __val
                	    = std::__addressof(*__first);
                	  std::_Construct(__val);
                	  if (++__first != __last)
                	    std::fill(__first, __last, *__val);
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                        static _ForwardIterator
                        __uninit_default_n(_ForwardIterator __first, _Size __n)
                        {
                	  if (__n > 0)
                	    {
                	      typename iterator_traits<_ForwardIterator>::value_type* __val
                		= std::__addressof(*__first);
                	      std::_Construct(__val);
                	      ++__first;
                	      __first = std::fill_n(__first, __n - 1, *__val);
                	    }
                	  return __first;
                	}
                    };
                
                  // __uninitialized_default
                  // Fills [first, last) with value-initialized value_types.
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default(_ForwardIterator __first,
                			    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // trivial types can have deleted assignment
                      const bool __assignable = is_copy_assignable<_ValueType>::value;
                
                      std::__uninitialized_default_1<__is_trivial(_ValueType)
                				     && __assignable>::
                	__uninit_default(__first, __last);
                    }
                
                  // __uninitialized_default_n
                  // Fills [first, first + n) with value-initialized value_types.
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                      // See uninitialized_fill_n for the conditions for using std::fill_n.
                      constexpr bool __can_fill
                	= __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;
                
                      return __uninitialized_default_n_1<__is_trivial(_ValueType)
                					 && __can_fill>::
                	__uninit_default_n(__first, __n);
                    }
                
                
                  // __uninitialized_default_a
                  // Fills [first, last) with value_types constructed by the allocator
                  // alloc, with no arguments passed to the construct call.
                  template<typename _ForwardIterator, typename _Allocator>
                    void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      _Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __cur != __last; ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    inline void
                    __uninitialized_default_a(_ForwardIterator __first,
                			      _ForwardIterator __last,
                			      allocator<_Tp>&)
                    { std::__uninitialized_default(__first, __last); }
                
                
                  // __uninitialized_default_n_a
                  // Fills [first, first + n) with value_types constructed by the allocator
                  // alloc, with no arguments passed to the construct call.
                  template<typename _ForwardIterator, typename _Size, typename _Allocator>
                    _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				_Allocator& __alloc)
                    {
                      _ForwardIterator __cur = __first;
                      __try
                	{
                	  typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
                	  for (; __n > 0; --__n, (void) ++__cur)
                	    __traits::construct(__alloc, std::__addressof(*__cur));
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__first, __cur, __alloc);
                	  __throw_exception_again;
                	}
                    }
                
                  // __uninitialized_default_n_a specialization for std::allocator,
                  // which ignores the allocator and value-initializes the elements.
                  template<typename _ForwardIterator, typename _Size, typename _Tp>
                    inline _ForwardIterator
                    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n, 
                				allocator<_Tp>&)
                    { return std::__uninitialized_default_n(__first, __n); }
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_1
                    {
                      template<typename _ForwardIterator>
                	static void
                	__uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __cur != __last; ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_1<true>
                    {
                      template<typename _ForwardIterator>
                        static void
                        __uninit_default_novalue(_ForwardIterator __first,
                				 _ForwardIterator __last)
                	{
                	}
                    };
                
                  template<bool _TrivialValueType>
                    struct __uninitialized_default_novalue_n_1
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{
                	  _ForwardIterator __cur = __first;
                	  __try
                	    {
                	      for (; __n > 0; --__n, (void) ++__cur)
                		std::_Construct_novalue(std::__addressof(*__cur));
                	      return __cur;
                	    }
                	  __catch(...)
                	    {
                	      std::_Destroy(__first, __cur);
                	      __throw_exception_again;
                	    }
                	}
                    };
                
                  template<>
                    struct __uninitialized_default_novalue_n_1<true>
                    {
                      template<typename _ForwardIterator, typename _Size>
                	static _ForwardIterator
                	__uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
                	{ return std::next(__first, __n); }
                    };
                
                  // __uninitialized_default_novalue
                  // Fills [first, last) with default-initialized value_types.
                  template<typename _ForwardIterator>
                    inline void
                    __uninitialized_default_novalue(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      std::__uninitialized_default_novalue_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue(__first, __last);
                    }
                
                  // __uninitialized_default_novalue_n
                  // Fills [first, first + n) with default-initialized value_types.
                  template<typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType;
                
                      return __uninitialized_default_novalue_n_1<
                	is_trivially_default_constructible<_ValueType>::value>::
                	__uninit_default_novalue_n(__first, __n);
                    }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    _ForwardIterator
                    __uninitialized_copy_n(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return __cur;
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline _ForwardIterator
                    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    { return std::uninitialized_copy(__first, __first + __n, __result); }
                
                  template<typename _InputIterator, typename _Size,
                	   typename _ForwardIterator>
                    pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			   _ForwardIterator __result, input_iterator_tag)
                    {
                      _ForwardIterator __cur = __result;
                      __try
                	{
                	  for (; __n > 0; --__n, (void) ++__first, ++__cur)
                	    std::_Construct(std::__addressof(*__cur), *__first);
                	  return {__first, __cur};
                	}
                      __catch(...)
                	{
                	  std::_Destroy(__result, __cur);
                	  __throw_exception_again;
                	}
                    }
                
                  template<typename _RandomAccessIterator, typename _Size,
                	   typename _ForwardIterator>
                    inline pair<_RandomAccessIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
                			   _ForwardIterator __result,
                			   random_access_iterator_tag)
                    {
                      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
                      auto __first_res = std::next(__first, __n);
                      return {__first_res, __second_res};
                    }
                
                  /// @endcond
                
                  /**
                   *  @brief Copies the range [first,first+n) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __n      The number of elements to copy.
                   *  @param  __result An output iterator.
                   *  @return  __result + __n
                   *
                   *  Like copy_n(), but does not require an initialized output range.
                  */
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_copy_n(_InputIterator __first, _Size __n,
                			 _ForwardIterator __result)
                    { return std::__uninitialized_copy_n(__first, __n, __result,
                					 std::__iterator_category(__first)); }
                
                  /// @cond undocumented
                  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
                			      _ForwardIterator __result)
                    {
                      return
                	std::__uninitialized_copy_n_pair(__first, __n, __result,
                					 std::__iterator_category(__first));
                    }
                  /// @endcond
                #endif
                
                #if __cplusplus >= 201703L
                # define __cpp_lib_raw_memory_algorithms 201606L
                
                  /**
                   *  @brief Default-initializes objects in the range [first,last).
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                  */
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_default_construct(_ForwardIterator __first,
                				    _ForwardIterator __last)
                    {
                      __uninitialized_default_novalue(__first, __last);
                    }
                
                  /**
                   *  @brief Default-initializes objects in the range [first,first+count).
                   *  @param  __first  A forward iterator.
                   *  @param  __count  The number of objects to construct.
                   *  @return   __first + __count
                  */
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_novalue_n(__first, __count);
                    }
                
                  /**
                   *  @brief Value-initializes objects in the range [first,last).
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                  */
                  template <typename _ForwardIterator>
                    inline void
                    uninitialized_value_construct(_ForwardIterator __first,
                				  _ForwardIterator __last)
                    {
                      return __uninitialized_default(__first, __last);
                    }
                
                  /**
                   *  @brief Value-initializes objects in the range [first,first+count).
                   *  @param  __first  A forward iterator.
                   *  @param  __count  The number of objects to construct.
                   *  @return   __result + __count
                  */
                  template <typename _ForwardIterator, typename _Size>
                    inline _ForwardIterator
                    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
                    {
                      return __uninitialized_default_n(__first, __count);
                    }
                
                  /**
                   *  @brief Move-construct from the range [first,last) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   __result + (__first - __last)
                  */
                  template <typename _InputIterator, typename _ForwardIterator>
                    inline _ForwardIterator
                    uninitialized_move(_InputIterator __first, _InputIterator __last,
                		       _ForwardIterator __result)
                    {
                      return std::uninitialized_copy
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 _GLIBCXX_MAKE_MOVE_ITERATOR(__last), __result);
                    }
                
                  /**
                   *  @brief Move-construct from the range [first,first+count) into result.
                   *  @param  __first  An input iterator.
                   *  @param  __count  The number of objects to initialize.
                   *  @param  __result An output iterator.
                   *  @return  __result + __count
                  */
                  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
                    inline pair<_InputIterator, _ForwardIterator>
                    uninitialized_move_n(_InputIterator __first, _Size __count,
                			 _ForwardIterator __result)
                    {
                      auto __res = std::__uninitialized_copy_n_pair
                	(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
                	 __count, __result);
                      return {__res.first.base(), __res.second};
                    }
                #endif // C++17
                
                #if __cplusplus >= 201103L
                  /// @cond undocumented
                
                  template<typename _Tp, typename _Up, typename _Allocator>
                    inline void
       11622 ->     __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
                			_Allocator& __alloc)
                    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
                			 __dest, std::move(*__orig)))
                	     && noexcept(std::allocator_traits<_Allocator>::destroy(
                			    __alloc, std::__addressof(*__orig))))
                    {
                      typedef std::allocator_traits<_Allocator> __traits;
                      __traits::construct(__alloc, __dest, std::move(*__orig));
                      __traits::destroy(__alloc, std::__addressof(*__orig));
                    }
                
                  // This class may be specialized for specific types.
                  // Also known as is_trivially_relocatable.
                  template<typename _Tp, typename = void>
                    struct __is_bitwise_relocatable
                    : is_trivial<_Tp> { };
                
                  template <typename _Tp, typename _Up>
                    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
       90676 ->     __relocate_a_1(_Tp* __first, _Tp* __last,
                		   _Tp* __result, allocator<_Up>&) noexcept
                    {
                      ptrdiff_t __count = __last - __first;
                      if (__count > 0)
                	__builtin_memmove(__result, __first, __count * sizeof(_Tp));
                      return __result + __count;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
       13900 ->     __relocate_a_1(_InputIterator __first, _InputIterator __last,
                		   _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
                					       std::addressof(*__first),
                					       __alloc)))
                    {
                      typedef typename iterator_traits<_InputIterator>::value_type
                	_ValueType;
                      typedef typename iterator_traits<_ForwardIterator>::value_type
                	_ValueType2;
                      static_assert(std::is_same<_ValueType, _ValueType2>::value,
                	  "relocation is only possible for values of the same type");
                      _ForwardIterator __cur = __result;
                      for (; __first != __last; ++__first, (void)++__cur)
                	std::__relocate_object_a(std::__addressof(*__cur),
                				 std::__addressof(*__first), __alloc);
                      return __cur;
                    }
                
                  template <typename _InputIterator, typename _ForwardIterator,
                	    typename _Allocator>
                    inline _ForwardIterator
      104576 ->     __relocate_a(_InputIterator __first, _InputIterator __last,
                		 _ForwardIterator __result, _Allocator& __alloc)
                    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
                				     std::__niter_base(__last),
                				     std::__niter_base(__result), __alloc)))
                    {
                      return __relocate_a_1(std::__niter_base(__first),
                			    std::__niter_base(__last),
                			    std::__niter_base(__result), __alloc);
                    }
                
                  /// @endcond
                #endif
                
                  /// @} group memory
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _STL_UNINITIALIZED_H */


Top 10 Lines:

     Line      Count

     1040     104576
     1006      90676
       85      68647
      126      68647
      331      68647
     1018      13900
      986      11622
      349       9302

Execution Summary:

       11   Executable lines in this file
       11   Lines executed
   100.00   Percent of the file executed

   436017   Total number of line executions
 39637.91   Average executions per line


*** File /usr/include/c++/11/ext/alloc_traits.h:
                // Allocator traits -*- C++ -*-
                
                // Copyright (C) 2011-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file ext/alloc_traits.h
                 *  This file is a GNU extension to the Standard C++ Library.
                 */
                
                #ifndef _EXT_ALLOC_TRAITS_H
                #define _EXT_ALLOC_TRAITS_H 1
                
                #pragma GCC system_header
                
                # include <bits/alloc_traits.h>
                #if __cplusplus < 201103L
                # include <bits/allocator.h>  // for __alloc_swap
                #endif
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                /**
                 * @brief  Uniform interface to C++98 and C++11 allocators.
                 * @ingroup allocators
                */
                template<typename _Alloc, typename = typename _Alloc::value_type>
                  struct __alloc_traits
                #if __cplusplus >= 201103L
                  : std::allocator_traits<_Alloc>
                #endif
                  {
                    typedef _Alloc allocator_type;
                #if __cplusplus >= 201103L
                    typedef std::allocator_traits<_Alloc>           _Base_type;
                    typedef typename _Base_type::value_type         value_type;
                    typedef typename _Base_type::pointer            pointer;
                    typedef typename _Base_type::const_pointer      const_pointer;
                    typedef typename _Base_type::size_type          size_type;
                    typedef typename _Base_type::difference_type    difference_type;
                    // C++11 allocators do not define reference or const_reference
                    typedef value_type&                             reference;
                    typedef const value_type&                       const_reference;
                    using _Base_type::allocate;
                    using _Base_type::deallocate;
                    using _Base_type::construct;
                    using _Base_type::destroy;
                    using _Base_type::max_size;
                
                  private:
                    template<typename _Ptr>
                      using __is_custom_pointer
                	= std::__and_<std::is_same<pointer, _Ptr>,
                		      std::__not_<std::is_pointer<_Ptr>>>;
                
                  public:
                    // overload construct for non-standard pointer types
                    template<typename _Ptr, typename... _Args>
                      static _GLIBCXX14_CONSTEXPR
                      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
                      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
                      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
                					      std::forward<_Args>(__args)...)))
                      {
                	_Base_type::construct(__a, std::__to_address(__p),
                			      std::forward<_Args>(__args)...);
                      }
                
                    // overload destroy for non-standard pointer types
                    template<typename _Ptr>
                      static _GLIBCXX14_CONSTEXPR
                      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
                      destroy(_Alloc& __a, _Ptr __p)
                      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
                      { _Base_type::destroy(__a, std::__to_address(__p)); }
                
       59344 ->     static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
                    { return _Base_type::select_on_container_copy_construction(__a); }
                
                    static _GLIBCXX14_CONSTEXPR void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    { std::__alloc_on_swap(__a, __b); }
                
           1 ->     static constexpr bool _S_propagate_on_copy_assign()
                    { return _Base_type::propagate_on_container_copy_assignment::value; }
                
                    static constexpr bool _S_propagate_on_move_assign()
                    { return _Base_type::propagate_on_container_move_assignment::value; }
                
                    static constexpr bool _S_propagate_on_swap()
                    { return _Base_type::propagate_on_container_swap::value; }
                
       ##### ->     static constexpr bool _S_always_equal()
                    { return _Base_type::is_always_equal::value; }
                
                    static constexpr bool _S_nothrow_move()
                    { return _S_propagate_on_move_assign() || _S_always_equal(); }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
                #else // ! C++11
                
                    typedef typename _Alloc::pointer                pointer;
                    typedef typename _Alloc::const_pointer          const_pointer;
                    typedef typename _Alloc::value_type             value_type;
                    typedef typename _Alloc::reference              reference;
                    typedef typename _Alloc::const_reference        const_reference;
                    typedef typename _Alloc::size_type              size_type;
                    typedef typename _Alloc::difference_type        difference_type;
                
                    _GLIBCXX_NODISCARD static pointer
                    allocate(_Alloc& __a, size_type __n)
                    { return __a.allocate(__n); }
                
                    template<typename _Hint>
                      _GLIBCXX_NODISCARD static pointer
                      allocate(_Alloc& __a, size_type __n, _Hint __hint)
                      { return __a.allocate(__n, __hint); }
                
                    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
                    { __a.deallocate(__p, __n); }
                
                    template<typename _Tp>
                      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
                      { __a.construct(__p, __arg); }
                
                    static void destroy(_Alloc& __a, pointer __p)
                    { __a.destroy(__p); }
                
                    static size_type max_size(const _Alloc& __a)
                    { return __a.max_size(); }
                
                    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }
                
                    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 431. Swapping containers with unequal allocators.
                      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
                    }
                
                    template<typename _Tp>
                      struct rebind
                      { typedef typename _Alloc::template rebind<_Tp>::other other; };
                #endif // C++11
                  };
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace __gnu_cxx
                
                #endif


Top 10 Lines:

     Line      Count

       97      59344
      103          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    59345   Total number of line executions
 19781.67   Average executions per line


*** File /usr/include/c++/11/bits/cpp_type_traits.h:
                // The  -*- C++ -*- type traits classes for internal use in libstdc++
                
                // Copyright (C) 2000-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/cpp_type_traits.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{ext/type_traits}
                 */
                
                // Written by Gabriel Dos Reis <dosreis@cmla.ens-cachan.fr>
                
                #ifndef _CPP_TYPE_TRAITS_H
                #define _CPP_TYPE_TRAITS_H 1
                
                #pragma GCC system_header
                
                #include <bits/c++config.h>
                
                //
                // This file provides some compile-time information about various types.
                // These representations were designed, on purpose, to be constant-expressions
                // and not types as found in <bits/type_traits.h>.  In particular, they
                // can be used in control structures and the optimizer hopefully will do
                // the obvious thing.
                //
                // Why integral expressions, and not functions nor types?
                // Firstly, these compile-time entities are used as template-arguments
                // so function return values won't work:  We need compile-time entities.
                // We're left with types and constant  integral expressions.
                // Secondly, from the point of view of ease of use, type-based compile-time
                // information is -not- *that* convenient.  One has to write lots of
                // overloaded functions and to hope that the compiler will select the right
                // one. As a net effect, the overall structure isn't very clear at first
                // glance.
                // Thirdly, partial ordering and overload resolution (of function templates)
                // is highly costly in terms of compiler-resource.  It is a Good Thing to
                // keep these resource consumption as least as possible.
                //
                // See valarray_array.h for a case use.
                //
                // -- Gaby (dosreis@cmla.ens-cachan.fr) 2000-03-06.
                //
                // Update 2005: types are also provided and <bits/type_traits.h> has been
                // removed.
                //
                
                extern "C++" {
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  struct __true_type { };
                  struct __false_type { };
                
                  template<bool>
                    struct __truth_type
                    { typedef __false_type __type; };
                
                  template<>
                    struct __truth_type<true>
                    { typedef __true_type __type; };
                
                  // N.B. The conversions to bool are needed due to the issue
                  // explained in c++/19404.
                  template<class _Sp, class _Tp>
                    struct __traitor
                    {
                      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
                      typedef typename __truth_type<__value>::__type __type;
                    };
                
                  // Compare for equality of types.
                  template<typename, typename>
                    struct __are_same
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __are_same<_Tp, _Tp>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  // Holds if the template-argument is a void type.
                  template<typename _Tp>
                    struct __is_void
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_void<void>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Integer types
                  //
                  template<typename _Tp>
                    struct __is_integer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Thirteen specializations (yes there are eleven standard integer
                  // types; <em>long long</em> and <em>unsigned long long</em> are
                  // supported as extensions).  Up to four target-specific __int<N>
                  // types are supported as well.
                  template<>
                    struct __is_integer<bool>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                # ifdef __WCHAR_TYPE__
                  template<>
                    struct __is_integer<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                # endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_integer<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __is_integer<char16_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<char32_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<>
                    struct __is_integer<short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned short>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned int>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_integer<unsigned long long>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #define __INT_N(TYPE) 			\
                  template<>				\
                    struct __is_integer<TYPE>		\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };					\
                  template<>				\
                    struct __is_integer<unsigned TYPE>	\
                    {					\
                      enum { __value = 1 };		\
                      typedef __true_type __type;	\
                    };
                
                #ifdef __GLIBCXX_TYPE_INT_N_0
                __INT_N(__GLIBCXX_TYPE_INT_N_0)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_1
                __INT_N(__GLIBCXX_TYPE_INT_N_1)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_2
                __INT_N(__GLIBCXX_TYPE_INT_N_2)
                #endif
                #ifdef __GLIBCXX_TYPE_INT_N_3
                __INT_N(__GLIBCXX_TYPE_INT_N_3)
                #endif
                
                #undef __INT_N
                
                  //
                  // Floating point types
                  //
                  template<typename _Tp>
                    struct __is_floating
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // three specializations (float, double and 'long double')
                  template<>
                    struct __is_floating<float>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_floating<long double>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // Pointer types
                  //
                  template<typename _Tp>
                    struct __is_pointer
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<typename _Tp>
                    struct __is_pointer<_Tp*>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  //
                  // An arithmetic type is an integer type or a floating point type
                  //
                  template<typename _Tp>
                    struct __is_arithmetic
                    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
                    { };
                
                  //
                  // A scalar type is an arithmetic type or a pointer type
                  // 
                  template<typename _Tp>
                    struct __is_scalar
                    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
                    { };
                
                  //
                  // For use in std::copy and std::find overloads for streambuf iterators.
                  //
                  template<typename _Tp>
                    struct __is_char
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_char<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #ifdef __WCHAR_TYPE__
                  template<>
                    struct __is_char<wchar_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename _Tp>
                    struct __is_byte
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  template<>
                    struct __is_byte<char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<signed char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<>
                    struct __is_byte<unsigned char>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                #if __cplusplus >= 201703L
                  enum class byte : unsigned char;
                
                  template<>
                    struct __is_byte<byte>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif // C++17
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  template<>
                    struct __is_byte<char8_t>
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                #endif
                
                  template<typename> struct iterator_traits;
                
                  // A type that is safe for use with memcpy, memmove, memcmp etc.
                  template<typename _Tp>
                    struct __is_nonvolatile_trivially_copyable
                    {
                      enum { __value = __is_trivially_copyable(_Tp) };
                    };
                
                  // Cannot use memcpy/memmove/memcmp on volatile types even if they are
                  // trivially copyable, so ensure __memcpyable<volatile int*, volatile int*>
                  // and similar will be false.
                  template<typename _Tp>
                    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
                    {
                      enum { __value = 0 };
                    };
                
                  // Whether two iterator types can be used with memcpy/memmove.
                  template<typename _OutputIter, typename _InputIter>
                    struct __memcpyable
                    {
                      enum { __value = 0 };
                    };
                
                  template<typename _Tp>
                    struct __memcpyable<_Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcpyable<_Tp*, const _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  // Whether two iterator types can be used with memcmp.
                  // This trait only says it's well-formed to use memcmp, not that it
                  // gives the right answer for a given algorithm. So for example, std::equal
                  // needs to add additional checks that the types are integers or pointers,
                  // because other trivially copyable types can overload operator==.
                  template<typename _Iter1, typename _Iter2>
                    struct __memcmpable
                    {
                      enum { __value = 0 };
                    };
                
                  // OK to use memcmp with pointers to trivially copyable types.
                  template<typename _Tp>
                    struct __memcmpable<_Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcmpable<const _Tp*, _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  template<typename _Tp>
                    struct __memcmpable<_Tp*, const _Tp*>
                    : __is_nonvolatile_trivially_copyable<_Tp>
                    { };
                
                  // Whether memcmp can be used to determine ordering for a type
                  // e.g. in std::lexicographical_compare or three-way comparisons.
                  // True for unsigned integer-like types where comparing each byte in turn
                  // as an unsigned char yields the right result. This is true for all
                  // unsigned integers on big endian targets, but only unsigned narrow
                  // character types (and std::byte) on little endian targets.
                  template<typename _Tp, bool _TreatAsBytes =
                #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
                	__is_integer<_Tp>::__value
                #else
                	__is_byte<_Tp>::__value
                #endif
                    >
                    struct __is_memcmp_ordered
                    {
                      static const bool __value = _Tp(-1) > _Tp(1); // is unsigned
                    };
                
                  template<typename _Tp>
                    struct __is_memcmp_ordered<_Tp, false>
                    {
                      static const bool __value = false;
                    };
                
                  // Whether two types can be compared using memcmp.
                  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
                    struct __is_memcmp_ordered_with
                    {
                      static const bool __value = __is_memcmp_ordered<_Tp>::__value
                	&& __is_memcmp_ordered<_Up>::__value;
                    };
                
                  template<typename _Tp, typename _Up>
                    struct __is_memcmp_ordered_with<_Tp, _Up, false>
                    {
                      static const bool __value = false;
                    };
                
                #if __cplusplus >= 201703L
                #if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
                  // std::byte is not an integer, but it can be compared using memcmp.
                  template<>
                    struct __is_memcmp_ordered<std::byte, false>
                    { static constexpr bool __value = true; };
                #endif
                
                  // std::byte can only be compared to itself, not to other types.
                  template<>
                    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
                    { static constexpr bool __value = true; };
                
                  template<typename _Tp, bool _SameSize>
                    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
                    { static constexpr bool __value = false; };
                
                  template<typename _Up, bool _SameSize>
                    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
                    { static constexpr bool __value = false; };
                #endif
                
                  //
                  // Move iterator type
                  //
                  template<typename _Tp>
                    struct __is_move_iterator
                    {
                      enum { __value = 0 };
                      typedef __false_type __type;
                    };
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the move_iterator wrapper.
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
        1746 ->     __miter_base(_Iterator __it)
                    { return __it; }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                } // extern "C++"
                
                #endif //_CPP_TYPE_TRAITS_H


Top 10 Lines:

     Line      Count

      560       1746

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

     1746   Total number of line executions
  1746.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Bonus.h:
                #ifndef BONUS_H
                #define BONUS_H
                
                #include <SFML/Graphics.hpp>
                #include "Level.h"
                #include "Player.h"
                
                enum BonusType
                {
                    STRENGTH,
                    NUMBOMB,
                };
                
        1259 -> class Bonus
                {
                private:
                    int x;
                    int y;
                    sf::Texture texture;
                    sf::Sprite sprite;
                    BonusType type;
                
                public:
                    Bonus();
                    Bonus(int x, int y, BonusType type);
                    void draw(sf::RenderWindow &window, int zoom);
                    void update();
         351 ->     int getX() const { return x; }
          67 ->     int getY() const { return y; }
           6 ->     BonusType getType() const { return type; }
                
                    static BonusType getRandomType();
                
                };
                
                #endif // BONUS_H

Top 10 Lines:

     Line      Count

       14       1259
       28        351
       29         67
       30          6

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

     1683   Total number of line executions
   420.75   Average executions per line


*** File /usr/include/c++/11/bits/allocator.h:
                // Allocators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 * Copyright (c) 1996-1997
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/allocator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{memory}
                 */
                
                #ifndef _ALLOCATOR_H
                #define _ALLOCATOR_H 1
                
                #include <bits/c++allocator.h> // Define the base class to std::allocator.
                #include <bits/memoryfwd.h>
                #if __cplusplus >= 201103L
                #include <type_traits>
                #endif
                
                #define __cpp_lib_incomplete_container_elements 201505
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup allocators
                   *  @{
                   */
                
                  // Since C++20 the primary template should be used for allocator<void>,
                  // but then it would have a non-trivial default ctor and dtor for C++20,
                  // but trivial for C++98-17, which would be an ABI incompatibiliy between
                  // different standard dialects. So C++20 still uses the allocator<void>
                  // explicit specialization, with the historical ABI properties, but with
                  // the same members that are present in the primary template.
                
                  /// allocator<void> specialization.
                  template<>
                    class allocator<void>
                    {
                    public:
                      typedef void        value_type;
                      typedef size_t      size_type;
                      typedef ptrdiff_t   difference_type;
                
                #if __cplusplus <= 201703L
                      // These were removed for C++20, allocator_traits does the right thing.
                      typedef void*       pointer;
                      typedef const void* const_pointer;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                #endif
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      using is_always_equal
                	_GLIBCXX20_DEPRECATED_SUGGEST("std::allocator_traits::is_always_equal")
                	= true_type;
                
                #if __cplusplus >= 202002L
                      // As noted above, these members are present for C++20 to provide the
                      // same API as the primary template, but still trivial as in pre-C++20.
                      allocator() = default;
                      ~allocator() = default;
                
                      template<typename _Up>
                	constexpr
                	allocator(const allocator<_Up>&) noexcept { }
                
                      // No allocate member because it's ill-formed by LWG 3307.
                      // No deallocate member because it would be undefined to call it
                      // with any pointer which wasn't obtained from allocate.
                #endif // C++20
                #endif // C++11
                    };
                
                  /**
                   * @brief  The @a standard allocator, as per C++03 [20.4.1].
                   *
                   *  See https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#std.util.memory.allocator
                   *  for further details.
                   *
                   *  @tparam  _Tp  Type of allocated object.
                   */
                  template<typename _Tp>
                    class allocator : public __allocator_base<_Tp>
                    {
                    public:
                      typedef _Tp        value_type;
                      typedef size_t     size_type;
                      typedef ptrdiff_t  difference_type;
                
                #if __cplusplus <= 201703L
                      // These were removed for C++20.
                      typedef _Tp*       pointer;
                      typedef const _Tp* const_pointer;
                      typedef _Tp&       reference;
                      typedef const _Tp& const_reference;
                
                      template<typename _Tp1>
                	struct rebind
                	{ typedef allocator<_Tp1> other; };
                #endif
                
                #if __cplusplus >= 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2103. std::allocator propagate_on_container_move_assignment
                      using propagate_on_container_move_assignment = true_type;
                
                      using is_always_equal
                	_GLIBCXX20_DEPRECATED_SUGGEST("std::allocator_traits::is_always_equal")
                	= true_type;
                #endif
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3035. std::allocator's constructors should be constexpr
                      _GLIBCXX20_CONSTEXPR
       19600 ->       allocator() _GLIBCXX_NOTHROW { }
                
                      _GLIBCXX20_CONSTEXPR
      195370 ->       allocator(const allocator& __a) _GLIBCXX_NOTHROW
                      : __allocator_base<_Tp>(__a) { }
                
                #if __cplusplus >= 201103L
                      // Avoid implicit deprecation.
                      allocator& operator=(const allocator&) = default;
                #endif
                
                      template<typename _Tp1>
                	_GLIBCXX20_CONSTEXPR
       ##### -> 	allocator(const allocator<_Tp1>&) _GLIBCXX_NOTHROW { }
                
                #if __cpp_constexpr_dynamic_alloc
                      constexpr
                #endif
      212310 ->       ~allocator() _GLIBCXX_NOTHROW { }
                
                #if __cplusplus > 201703L
                      [[nodiscard,__gnu__::__always_inline__]]
                      constexpr _Tp*
                      allocate(size_t __n)
                      {
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
                #endif
                	return __allocator_base<_Tp>::allocate(__n, 0);
                      }
                
                      [[__gnu__::__always_inline__]]
                      constexpr void
                      deallocate(_Tp* __p, size_t __n)
                      {
                #ifdef __cpp_lib_is_constant_evaluated
                	if (std::is_constant_evaluated())
                	  {
                	    ::operator delete(__p);
                	    return;
                	  }
                #endif
                	__allocator_base<_Tp>::deallocate(__p, __n);
                      }
                #endif // C++20
                
                      friend _GLIBCXX20_CONSTEXPR bool
                      operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                      friend _GLIBCXX20_CONSTEXPR bool
       ##### ->       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW
                      { return false; }
                #endif
                
                      // Inherit everything else.
                    };
                
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX20_CONSTEXPR bool
                    operator==(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return true; }
                
                #if __cpp_impl_three_way_comparison < 201907L
                  template<typename _T1, typename _T2>
                    inline _GLIBCXX20_CONSTEXPR bool
                    operator!=(const allocator<_T1>&, const allocator<_T2>&)
                    _GLIBCXX_NOTHROW
                    { return false; }
                #endif
                
                  // Invalid allocator<cv T> partial specializations.
                  // allocator_traits::rebind_alloc can be used to form a valid allocator type.
                  template<typename _Tp>
                    class allocator<const _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  template<typename _Tp>
                    class allocator<const volatile _Tp>
                    {
                    public:
                      typedef _Tp value_type;
                      template<typename _Up> allocator(const allocator<_Up>&) { }
                    };
                
                  /// @} group allocator
                
                  // Inhibit implicit instantiations for required instantiations,
                  // which are defined via explicit instantiations elsewhere.
                #if _GLIBCXX_EXTERN_TEMPLATE
                  extern template class allocator<char>;
                  extern template class allocator<wchar_t>;
                #endif
                
                  // Undefine.
                #undef __allocator_base
                
                  // To implement Option 3 of DR 431.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_swap
                    { static void _S_do_it(_Alloc&, _Alloc&) _GLIBCXX_NOEXCEPT { } };
                
                  template<typename _Alloc>
                    struct __alloc_swap<_Alloc, false>
                    {
                      static void
                      _S_do_it(_Alloc& __one, _Alloc& __two) _GLIBCXX_NOEXCEPT
                      {
                	// Precondition: swappable allocators.
                	if (__one != __two)
                	  swap(__one, __two);
                      }
                    };
                
                  // Optimize for stateless allocators.
                  template<typename _Alloc, bool = __is_empty(_Alloc)>
                    struct __alloc_neq
                    {
                      static bool
                      _S_do_it(const _Alloc&, const _Alloc&)
                      { return false; }
                    };
                
                  template<typename _Alloc>
                    struct __alloc_neq<_Alloc, false>
                    {
                      static bool
                      _S_do_it(const _Alloc& __one, const _Alloc& __two)
                      { return __one != __two; }
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Tp, bool
                    = __or_<is_copy_constructible<typename _Tp::value_type>,
                            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
                    struct __shrink_to_fit_aux
                    { static bool _S_do_it(_Tp&) noexcept { return false; } };
                
                  template<typename _Tp>
                    struct __shrink_to_fit_aux<_Tp, true>
                    {
                      static bool
                      _S_do_it(_Tp& __c) noexcept
                      {
                #if __cpp_exceptions
                	try
                	  {
                	    _Tp(__make_move_if_noexcept_iterator(__c.begin()),
                		__make_move_if_noexcept_iterator(__c.end()),
                		__c.get_allocator()).swap(__c);
                	    return true;
                	  }
                	catch(...)
                	  { return false; }
                #else
                	return false;
                #endif
                      }
                    };
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif


Top 10 Lines:

     Line      Count

      174     212310
      159     195370
      156      19600

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   427280   Total number of line executions
 85456.00   Average executions per line


*** File /usr/include/c++/11/bits/move.h:
                // Move, forward and identity for C++11 + swap -*- C++ -*-
                
                // Copyright (C) 2007-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/move.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{utility}
                 */
                
                #ifndef _MOVE_H
                #define _MOVE_H 1
                
                #include <bits/c++config.h>
                #if __cplusplus < 201103L
                # include <bits/concept_check.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // Used, in C++03 mode too, by allocators, etc.
                  /**
                   *  @brief Same as C++11 std::addressof
                   *  @ingroup utilities
                   */
                  template<typename _Tp>
                    inline _GLIBCXX_CONSTEXPR _Tp*
      302693 ->     __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
                    { return __builtin_addressof(__r); }
                
                #if __cplusplus >= 201103L
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #include <type_traits> // Brings in std::declval too.
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief  Forward an lvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr _Tp&&
      486542 ->     forward(typename std::remove_reference<_Tp>::type& __t) noexcept
                    { return static_cast<_Tp&&>(__t); }
                
                  /**
                   *  @brief  Forward an rvalue.
                   *  @return The parameter cast to the specified type.
                   *
                   *  This function is used to implement "perfect forwarding".
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr _Tp&&
                    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
                    {
                      static_assert(!std::is_lvalue_reference<_Tp>::value,
                	  "std::forward must not be used to convert an rvalue to an lvalue");
                      return static_cast<_Tp&&>(__t);
                    }
                
                  /**
                   *  @brief  Convert a value to an rvalue.
                   *  @param  __t  A thing of arbitrary type.
                   *  @return The parameter cast to an rvalue-reference to allow moving it.
                  */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr typename std::remove_reference<_Tp>::type&&
      151976 ->     move(_Tp&& __t) noexcept
                    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
                
                
                  template<typename _Tp>
                    struct __move_if_noexcept_cond
                    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                                    is_copy_constructible<_Tp>>::type { };
                
                  /**
                   *  @brief  Conditionally convert a value to an rvalue.
                   *  @param  __x  A thing of arbitrary type.
                   *  @return The parameter, possibly cast to an rvalue-reference.
                   *
                   *  Same as std::move unless the type's move constructor could throw and the
                   *  type is copyable, in which case an lvalue-reference is returned instead.
                   */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    constexpr typename
                    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
                    move_if_noexcept(_Tp& __x) noexcept
                    { return std::move(__x); }
                
                  // declval, from type_traits.
                
                #if __cplusplus > 201402L
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2296. std::addressof should be constexpr
                # define __cpp_lib_addressof_constexpr 201603
                #endif
                  /**
                   *  @brief Returns the actual address of the object or function
                   *         referenced by r, even in the presence of an overloaded
                   *         operator&.
                   *  @param  __r  Reference to an object or function.
                   *  @return   The actual address.
                  */
                  template<typename _Tp>
                    _GLIBCXX_NODISCARD
                    inline _GLIBCXX17_CONSTEXPR _Tp*
        1593 ->     addressof(_Tp& __r) noexcept
                    { return std::__addressof(__r); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2598. addressof works on temporaries
                  template<typename _Tp>
                    const _Tp* addressof(const _Tp&&) = delete;
                
                  // C++11 version of std::exchange for internal use.
                  template <typename _Tp, typename _Up = _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _Tp
                    __exchange(_Tp& __obj, _Up&& __new_val)
                    {
                      _Tp __old_val = std::move(__obj);
                      __obj = std::forward<_Up>(__new_val);
                      return __old_val;
                    }
                
                  /// @} group utilities
                
                #define _GLIBCXX_FWDREF(_Tp) _Tp&&
                #define _GLIBCXX_MOVE(__val) std::move(__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) std::forward<_Tp>(__val)
                #else
                #define _GLIBCXX_FWDREF(_Tp) const _Tp&
                #define _GLIBCXX_MOVE(__val) (__val)
                #define _GLIBCXX_FORWARD(_Tp, __val) (__val)
                #endif
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                  /**
                   *  @brief Swaps two values.
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   Nothing.
                  */
                  template<typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
                			      is_move_constructible<_Tp>,
                			      is_move_assignable<_Tp>>::value>::type
                #else
                    void
                #endif
       ##### ->     swap(_Tp& __a, _Tp& __b)
                    _GLIBCXX_NOEXCEPT_IF(__and_<is_nothrow_move_constructible<_Tp>,
                				is_nothrow_move_assignable<_Tp>>::value)
                    {
                #if __cplusplus < 201103L
                      // concept requirements
                      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)
                #endif
                      _Tp __tmp = _GLIBCXX_MOVE(__a);
                      __a = _GLIBCXX_MOVE(__b);
                      __b = _GLIBCXX_MOVE(__tmp);
                    }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 809. std::swap should be overloaded for array types.
                  /// Swap the contents of two arrays.
                  template<typename _Tp, size_t _Nm>
                    _GLIBCXX20_CONSTEXPR
                    inline
                #if __cplusplus >= 201103L
                    typename enable_if<__is_swappable<_Tp>::value>::type
                #else
                    void
                #endif
                    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
                    _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Tp>::value)
                    {
                      for (size_t __n = 0; __n < _Nm; ++__n)
                	swap(__a[__n], __b[__n]);
                    }
                
                  /// @} group utilities
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* _MOVE_H */


Top 10 Lines:

     Line      Count

       77     486542
       49     302693
      104     151976
      145       1593

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

   942804   Total number of line executions
188560.80   Average executions per line


*** File /usr/include/c++/11/bits/stl_vector.h:
                // Vector implementation -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this  software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_vector.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{vector}
                 */
                
                #ifndef _STL_VECTOR_H
                #define _STL_VECTOR_H 1
                
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/functexcept.h>
                #include <bits/concept_check.h>
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                #include <debug/assertions.h>
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                extern "C" void
                __sanitizer_annotate_contiguous_container(const void*, const void*,
                					  const void*, const void*);
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  /// See bits/stl_deque.h's _Deque_base for an explanation.
                  template<typename _Tp, typename _Alloc>
                    struct _Vector_base
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_Tp>::other _Tp_alloc_type;
                      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
                       	pointer;
                
                      struct _Vector_impl_data
                      {
                	pointer _M_start;
                	pointer _M_finish;
                	pointer _M_end_of_storage;
                
      193964 -> 	_Vector_impl_data() _GLIBCXX_NOEXCEPT
                	: _M_start(), _M_finish(), _M_end_of_storage()
                	{ }
                
                #if __cplusplus >= 201103L
                	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
                	: _M_start(__x._M_start), _M_finish(__x._M_finish),
                	  _M_end_of_storage(__x._M_end_of_storage)
                	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
                #endif
                
                	void
      230040 -> 	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
                	{
                	  _M_start = __x._M_start;
                	  _M_finish = __x._M_finish;
                	  _M_end_of_storage = __x._M_end_of_storage;
                	}
                
                	void
       76680 -> 	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
                	{
                	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
                	  // information used by TBAA.
                	  _Vector_impl_data __tmp;
                	  __tmp._M_copy_data(*this);
                	  _M_copy_data(__x);
                	  __x._M_copy_data(__tmp);
                	}
                      };
                
      113031 ->       struct _Vector_impl
                	: public _Tp_alloc_type, public _Vector_impl_data
                      {
       19599 -> 	_Vector_impl() _GLIBCXX_NOEXCEPT_IF(
                	    is_nothrow_default_constructible<_Tp_alloc_type>::value)
                	: _Tp_alloc_type()
                	{ }
                
       97685 -> 	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
                	: _Tp_alloc_type(__a)
                	{ }
                
                #if __cplusplus >= 201103L
                	// Not defaulted, to enforce noexcept(true) even when
                	// !is_nothrow_move_constructible<_Tp_alloc_type>.
                	_Vector_impl(_Vector_impl&& __x) noexcept
                	: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a) noexcept
                	: _Tp_alloc_type(std::move(__a))
                	{ }
                
                	_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
                	: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
                	{ }
                #endif
                
                #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                	template<typename = _Tp_alloc_type>
                	  struct _Asan
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    static void _S_shrink(_Vector_impl&, size_type) { }
                	    static void _S_on_dealloc(_Vector_impl&) { }
                
                	    typedef _Vector_impl& _Reinit;
                
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl&, size_type) { }
                	      void _M_grew(size_type) { }
                	    };
                	  };
                
                	// Enable ASan annotations for memory obtained from std::allocator.
                	template<typename _Up>
                	  struct _Asan<allocator<_Up> >
                	  {
                	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
                	      ::size_type size_type;
                
                	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to
                	    // mark end of valid region as __curr instead of __prev.
                	    static void
                	    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)
                	    {
                	      __sanitizer_annotate_contiguous_container(__impl._M_start,
                		  __impl._M_end_of_storage, __prev, __curr);
                	    }
                
                	    static void
                	    _S_grow(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }
                
                	    static void
                	    _S_shrink(_Vector_impl& __impl, size_type __n)
                	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }
                
                	    static void
                	    _S_on_dealloc(_Vector_impl& __impl)
                	    {
                	      if (__impl._M_start)
                		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);
                	    }
                
                	    // Used on reallocation to tell ASan unused capacity is invalid.
                	    struct _Reinit
                	    {
                	      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)
                	      {
                		// Mark unused capacity as valid again before deallocating it.
                		_S_on_dealloc(_M_impl);
                	      }
                
                	      ~_Reinit()
                	      {
                		// Mark unused capacity as invalid after reallocation.
                		if (_M_impl._M_start)
                		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,
                			    _M_impl._M_finish);
                	      }
                
                	      _Vector_impl& _M_impl;
                
                #if __cplusplus >= 201103L
                	      _Reinit(const _Reinit&) = delete;
                	      _Reinit& operator=(const _Reinit&) = delete;
                #endif
                	    };
                
                	    // Tell ASan when unused capacity is initialized to be valid.
                	    struct _Grow
                	    {
                	      _Grow(_Vector_impl& __impl, size_type __n)
                	      : _M_impl(__impl), _M_n(__n)
                	      { _S_grow(_M_impl, __n); }
                
                	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }
                
                	      void _M_grew(size_type __n) { _M_n -= __n; }
                
                #if __cplusplus >= 201103L
                	      _Grow(const _Grow&) = delete;
                	      _Grow& operator=(const _Grow&) = delete;
                #endif
                	    private:
                	      _Vector_impl& _M_impl;
                	      size_type _M_n;
                	    };
                	  };
                
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT \
                  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \
                	__attribute__((__unused__)) __reinit_guard(this->_M_impl)
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \
                  typename _Base::_Vector_impl::template _Asan<>::_Grow \
                	__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \
                  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \
                  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)
                #else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)
                #define _GLIBCXX_ASAN_ANNOTATE_REINIT
                #define _GLIBCXX_ASAN_ANNOTATE_GROW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_GREW(n)
                #define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)
                #define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
                #endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
                      };
                
                    public:
                      typedef _Alloc allocator_type;
                
                      _Tp_alloc_type&
      368337 ->       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      const _Tp_alloc_type&
      211562 ->       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
                      { return this->_M_impl; }
                
                      allocator_type
       38340 ->       get_allocator() const _GLIBCXX_NOEXCEPT
                      { return allocator_type(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
       19599 ->       _Vector_base() = default;
                #else
                      _Vector_base() { }
                #endif
                
       38341 ->       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _M_impl(__a) { }
                
                      // Kept for ABI compatibility.
                #if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(size_t __n)
                      : _M_impl()
                      { _M_create_storage(__n); }
                #endif
                
       59344 ->       _Vector_base(size_t __n, const allocator_type& __a)
                      : _M_impl(__a)
                      { _M_create_storage(__n); }
                
                #if __cplusplus >= 201103L
                      _Vector_base(_Vector_base&&) = default;
                
                      // Kept for ABI compatibility.
                # if !_GLIBCXX_INLINE_VERSION
                      _Vector_base(_Tp_alloc_type&& __a) noexcept
                      : _M_impl(std::move(__a)) { }
                
                      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
                      : _M_impl(__a)
                      {
                	if (__x.get_allocator() == __a)
                	  this->_M_impl._M_swap_data(__x._M_impl);
                	else
                	  {
                	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
                	    _M_create_storage(__n);
                	  }
                      }
                # endif
                
                      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
                      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
                      { }
                #endif
                
      113031 ->       ~_Vector_base() _GLIBCXX_NOEXCEPT
                      {
                	_M_deallocate(_M_impl._M_start,
                		      _M_impl._M_end_of_storage - _M_impl._M_start);
                      }
                
                    public:
                      _Vector_impl _M_impl;
                
                      pointer
      116284 ->       _M_allocate(size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
                      }
                
                      void
      169970 ->       _M_deallocate(pointer __p, size_t __n)
                      {
                	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
                	if (__p)
                	  _Tr::deallocate(_M_impl, __p, __n);
                      }
                
                    protected:
                      void
       59344 ->       _M_create_storage(size_t __n)
                      {
                	this->_M_impl._M_start = this->_M_allocate(__n);
                	this->_M_impl._M_finish = this->_M_impl._M_start;
                	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                      }
                    };
                
                  /**
                   *  @brief A standard container which offers fixed time access to
                   *  individual elements in any order.
                   *
                   *  @ingroup sequences
                   *
                   *  @tparam _Tp  Type of element.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>, including the
                   *  <a href="tables.html#68">optional sequence requirements</a> with the
                   *  %exception of @c push_front and @c pop_front.
                   *
                   *  In some terminology a %vector can be described as a dynamic
                   *  C-style array, it offers fast and efficient access to individual
                   *  elements in any order and saves the user from worrying about
                   *  memory and size allocation.  Subscripting ( @c [] ) access is
                   *  also provided as with C-style arrays.
                  */
                  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
                    class vector : protected _Vector_base<_Tp, _Alloc>
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // Concept requirements.
                      typedef typename _Alloc::value_type		_Alloc_value_type;
                # if __cplusplus < 201103L
                      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
                # endif
                      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
                #endif
                
                #if __cplusplus >= 201103L
                      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
                	  "std::vector must have a non-const, non-volatile value_type");
                # if __cplusplus > 201703L || defined __STRICT_ANSI__
                      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
                	  "std::vector must have the same value_type as its allocator");
                # endif
                #endif
                
                      typedef _Vector_base<_Tp, _Alloc>			_Base;
                      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
                
                    public:
                      typedef _Tp					value_type;
                      typedef typename _Base::pointer			pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
                      const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                      typedef size_t					size_type;
                      typedef ptrdiff_t					difference_type;
                      typedef _Alloc					allocator_type;
                
                    private:
                #if __cplusplus >= 201103L
                      static constexpr bool
                      _S_nothrow_relocate(true_type)
                      {
                	return noexcept(std::__relocate_a(std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<pointer>(),
                					  std::declval<_Tp_alloc_type&>()));
                      }
                
                      static constexpr bool
                      _S_nothrow_relocate(false_type)
                      { return false; }
                
                      static constexpr bool
                      _S_use_relocate()
                      {
                	// Instantiating std::__relocate_a might cause an error outside the
                	// immediate context (in __relocate_object_a's noexcept-specifier),
                	// so only do it if we know the type can be move-inserted into *this.
                	return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
                      }
                
                      static pointer
      104576 ->       _S_do_relocate(pointer __first, pointer __last, pointer __result,
                		     _Tp_alloc_type& __alloc, true_type) noexcept
                      {
                	return std::__relocate_a(__first, __last, __result, __alloc);
                      }
                
                      static pointer
                      _S_do_relocate(pointer, pointer, pointer __result,
                		     _Tp_alloc_type&, false_type) noexcept
                      { return __result; }
                
                      static pointer
      104576 ->       _S_relocate(pointer __first, pointer __last, pointer __result,
                		  _Tp_alloc_type& __alloc) noexcept
                      {
                	using __do_it = __bool_constant<_S_use_relocate()>;
                	return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
                      }
                #endif // C++11
                
                    protected:
                      using _Base::_M_allocate;
                      using _Base::_M_deallocate;
                      using _Base::_M_impl;
                      using _Base::_M_get_Tp_allocator;
                
                    public:
                      // [23.2.4.1] construct/copy/destroy
                      // (assign() and get_allocator() are also listed in this section)
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       */
                #if __cplusplus >= 201103L
       19599 ->       vector() = default;
                #else
                      vector() { }
                #endif
                
                      /**
                       *  @brief  Creates a %vector with no elements.
                       *  @param  __a  An allocator object.
                       */
                      explicit
       38340 ->       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
                      : _Base(__a) { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Creates a %vector with default constructed elements.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n default
                       *  constructed elements.
                       */
                      explicit
                      vector(size_type __n, const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_default_initialize(__n); }
                
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
       ##### ->       vector(size_type __n, const value_type& __value,
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #else
                      /**
                       *  @brief  Creates a %vector with copies of an exemplar element.
                       *  @param  __n  The number of elements to initially create.
                       *  @param  __value  An element to copy.
                       *  @param  __a  An allocator.
                       *
                       *  This constructor fills the %vector with @a __n copies of @a __value.
                       */
                      explicit
                      vector(size_type __n, const value_type& __value = value_type(),
                	     const allocator_type& __a = allocator_type())
                      : _Base(_S_check_init_len(__n, __a), __a)
                      { _M_fill_initialize(__n, __value); }
                #endif
                
                      /**
                       *  @brief  %Vector copy constructor.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x  will not be copied
                       *  (i.e. capacity() == size() in the new %vector).
                       *
                       *  The newly-created %vector uses a copy of the allocator object used
                       *  by @a __x (unless the allocator traits dictate a different object).
                       */
       59344 ->       vector(const vector& __x)
                      : _Base(__x.size(),
                	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move constructor.
                       *
                       *  The newly-created %vector contains the exact contents of the
                       *  moved instance.
                       *  The contents of the moved instance are a valid, but unspecified
                       *  %vector.
                       */
                      vector(vector&&) noexcept = default;
                
                      /// Copy constructor with alternative allocator
                      vector(const vector& __x, const allocator_type& __a)
                      : _Base(__x.size(), __a)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
                				      this->_M_impl._M_start,
                				      _M_get_Tp_allocator());
                      }
                
                    private:
                      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
                      : _Base(__m, std::move(__rv))
                      { }
                
                      vector(vector&& __rv, const allocator_type& __m, false_type)
                      : _Base(__m)
                      {
                	if (__rv.get_allocator() == __m)
                	  this->_M_impl._M_swap_data(__rv._M_impl);
                	else if (!__rv.empty())
                	  {
                	    this->_M_create_storage(__rv.size());
                	    this->_M_impl._M_finish =
                	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
                					  this->_M_impl._M_start,
                					  _M_get_Tp_allocator());
                	    __rv.clear();
                	  }
                      }
                
                    public:
                      /// Move constructor with alternative allocator
                      vector(vector&& __rv, const allocator_type& __m)
                      noexcept( noexcept(
                	vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
                	       std::declval<typename _Alloc_traits::is_always_equal>())) )
                      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
                      { }
                
                      /**
                       *  @brief  Builds a %vector from an initializer list.
                       *  @param  __l  An initializer_list.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements in the
                       *  initializer_list @a __l.
                       *
                       *  This will call the element type's copy constructor N times
                       *  (where N is @a __l.size()) and do no memory reallocation.
                       */
           1 ->       vector(initializer_list<value_type> __l,
                	     const allocator_type& __a = allocator_type())
                      : _Base(__a)
                      {
                	_M_range_initialize(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /**
                       *  @brief  Builds a %vector from a range.
                       *  @param  __first  An input iterator.
                       *  @param  __last  An input iterator.
                       *  @param  __a  An allocator.
                       *
                       *  Create a %vector consisting of copies of the elements from
                       *  [first,last).
                       *
                       *  If the iterators are forward, bidirectional, or
                       *  random-access, then this will call the elements' copy
                       *  constructor N times (where N is distance(first,last)) and do
                       *  no memory reallocation.  But if only input iterators are
                       *  used, then this will do at most 2N calls to the copy
                       *  constructor, and logN memory reallocations.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #else
                      template<typename _InputIterator>
                	vector(_InputIterator __first, _InputIterator __last,
                	       const allocator_type& __a = allocator_type())
                	: _Base(__a)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_initialize_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  The dtor only erases the elements, and note that if the
                       *  elements themselves are pointers, the pointed-to memory is
                       *  not touched in any way.  Managing the pointer is the user's
                       *  responsibility.
                       */
      113031 ->       ~vector() _GLIBCXX_NOEXCEPT
                      {
                	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                		      _M_get_Tp_allocator());
                	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
                      }
                
                      /**
                       *  @brief  %Vector assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  All the elements of @a __x are copied, but any unused capacity in
                       *  @a __x will not be copied.
                       *
                       *  Whether the allocator is copied depends on the allocator traits.
                       */
                      vector&
                      operator=(const vector& __x);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  %Vector move assignment operator.
                       *  @param  __x  A %vector of identical element and allocator types.
                       *
                       *  The contents of @a __x are moved into this %vector (without copying,
                       *  if the allocators permit it).
                       *  Afterwards @a __x is a valid, but unspecified %vector.
                       *
                       *  Whether the allocator is moved depends on the allocator traits.
                       */
                      vector&
       38340 ->       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	constexpr bool __move_storage =
                	  _Alloc_traits::_S_propagate_on_move_assign()
                	  || _Alloc_traits::_S_always_equal();
                	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
                	return *this;
                      }
                
                      /**
                       *  @brief  %Vector list assignment operator.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      vector&
                      operator=(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                	return *this;
                      }
                #endif
                
                      /**
                       *  @brief  Assigns a given value to a %vector.
                       *  @param  __n  Number of elements to be assigned.
                       *  @param  __val  Value to be assigned.
                       *
                       *  This function fills a %vector with @a __n copies of the given
                       *  value.  Note that the assignment completely changes the
                       *  %vector and that the resulting %vector's size is the same as
                       *  the number of elements assigned.
                       */
                      void
                      assign(size_type __n, const value_type& __val)
                      { _M_fill_assign(__n, __val); }
                
                      /**
                       *  @brief  Assigns a range to a %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  range [__first,__last).
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{ _M_assign_dispatch(__first, __last, __false_type()); }
                #else
                      template<typename _InputIterator>
                	void
                	assign(_InputIterator __first, _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_assign_dispatch(__first, __last, _Integral());
                	}
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Assigns an initializer list to a %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function fills a %vector with copies of the elements in the
                       *  initializer list @a __l.
                       *
                       *  Note that the assignment completely changes the %vector and
                       *  that the resulting %vector's size is the same as the number
                       *  of elements assigned.
                       */
                      void
                      assign(initializer_list<value_type> __l)
                      {
                	this->_M_assign_aux(__l.begin(), __l.end(),
                			    random_access_iterator_tag());
                      }
                #endif
                
                      /// Get a copy of the memory allocation object.
                      using _Base::get_allocator;
                
                      // iterators
                      /**
                       *  Returns a read/write iterator that points to the first
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
       95772 ->       begin() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
       59345 ->       begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      iterator
      160184 ->       end() _GLIBCXX_NOEXCEPT
                      { return iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
       59345 ->       end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the
                       *  last element in the %vector.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one
                       *  before the first element in the %vector.  Iteration is done
                       *  in reverse element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the
                       *  first element in the %vector.  Iteration is done in ordinary
                       *  element order.
                       */
                      const_iterator
        2949 ->       cbegin() const noexcept
                      { return const_iterator(this->_M_impl._M_start); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past
                       *  the last element in the %vector.  Iteration is done in
                       *  ordinary element order.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_impl._M_finish); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last element in the %vector.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first element in the %vector.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(begin()); }
                #endif
                
                      // [23.2.4.2] capacity
                      /**  Returns the number of elements in the %vector.  */
                      size_type
      378787 ->       size() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                
                      /**  Returns the size() of the largest possible %vector.  */
                      size_type
      113878 ->       max_size() const _GLIBCXX_NOEXCEPT
                      { return _S_max_size(_M_get_Tp_allocator()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  default constructed elements are appended.
                       */
                      void
                      resize(size_type __new_size)
                      {
                	if (__new_size > size())
                	  _M_default_append(__new_size - size());
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, const value_type& __x)
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #else
                      /**
                       *  @brief  Resizes the %vector to the specified number of elements.
                       *  @param  __new_size  Number of elements the %vector should contain.
                       *  @param  __x  Data with which new elements should be populated.
                       *
                       *  This function will %resize the %vector to the specified
                       *  number of elements.  If the number is smaller than the
                       *  %vector's current size the %vector is truncated, otherwise
                       *  the %vector is extended and new elements are populated with
                       *  given data.
                       */
                      void
                      resize(size_type __new_size, value_type __x = value_type())
                      {
                	if (__new_size > size())
                	  _M_fill_insert(end(), __new_size - size(), __x);
                	else if (__new_size < size())
                	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**  A non-binding request to reduce capacity() to size().  */
                      void
                      shrink_to_fit()
                      { _M_shrink_to_fit(); }
                #endif
                
                      /**
                       *  Returns the total number of elements that the %vector can
                       *  hold before needing to allocate more memory.
                       */
                      size_type
           1 ->       capacity() const _GLIBCXX_NOEXCEPT
                      { return size_type(this->_M_impl._M_end_of_storage
                			 - this->_M_impl._M_start); }
                
                      /**
                       *  Returns true if the %vector is empty.  (Thus begin() would
                       *  equal end().)
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return begin() == end(); }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          elements.
                       *  @param  __n  Number of elements required.
                       *  @throw  std::length_error  If @a n exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %vector to hold the specified number of elements.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the number of elements
                       *  that will be required, the user can reserve the memory in
                       *  %advance, and thus prevent a possible reallocation of memory
                       *  and copying of %vector data.
                       */
                      void
                      reserve(size_type __n);
                
                      // element access
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
      514090 ->       operator[](size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_subscript(__n);
                	return *(this->_M_impl._M_start + __n);
                      }
                
                    protected:
                      /// Safety check used only from at().
                      void
        4876 ->       _M_range_check(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                      }
                
                    public:
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read/write reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      reference
        4876 ->       at(size_type __n)
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %vector.
                       *  @param __n The index of the element for which data should be
                       *  accessed.
                       *  @return  Read-only (constant) reference to data.
                       *  @throw  std::out_of_range  If @a __n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter
                       *  is first checked that it is in the range of the vector.  The
                       *  function throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	_M_range_check(__n);
                	return (*this)[__n];
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %vector.
                       */
                      reference
                      front() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %vector.
                       */
                      const_reference
                      front() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *begin();
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %vector.
                       */
                      reference
       64239 ->       back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %vector.
                       */
                      const_reference
                      back() const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	return *(end() - 1);
                      }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // DR 464. Suggestion for new member functions in standard containers.
                      // data access
                      /**
                       *   Returns a pointer such that [data(), data() + size()) is a valid
                       *   range.  For a non-empty %vector, data() == &front().
                       */
                      _Tp*
                      data() _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      const _Tp*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data_ptr(this->_M_impl._M_start); }
                
                      // [23.2.4.3] modifiers
                      /**
                       *  @brief  Add data to the end of the %vector.
                       *  @param  __x  Data to be added.
                       *
                       *  This is a typical stack operation.  The function creates an
                       *  element at the end of the %vector and assigns the given data
                       *  to it.  Due to the nature of a %vector this operation can be
                       *  done in constant time if the %vector has preallocated space
                       *  available.
                       */
                      void
         842 ->       push_back(const value_type& __x)
                      {
                	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
                	  {
                	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
                	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                				     __x);
                	    ++this->_M_impl._M_finish;
                	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
                	  }
                	else
                	  _M_realloc_insert(end(), __x);
                      }
                
                #if __cplusplus >= 201103L
                      void
       60477 ->       push_back(value_type&& __x)
                      { emplace_back(std::move(__x)); }
                
                      template<typename... _Args>
                #if __cplusplus > 201402L
                	reference
                #else
                	void
                #endif
                	emplace_back(_Args&&... __args);
                #endif
                
                      /**
                       *  @brief  Removes last element.
                       *
                       *  This is a typical stack operation. It shrinks the %vector by one.
                       *
                       *  Note that no data is returned, and if the last element's
                       *  data is needed, it should be retrieved before pop_back() is
                       *  called.
                       */
                      void
                      pop_back() _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_nonempty();
                	--this->_M_impl._M_finish;
                	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
                	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts an object in %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __args  Arguments.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert an object of type T constructed
                       *  with T(std::forward<Args>(args)...) before the specified location.
                       *  Note that this kind of operation could be expensive for a %vector
                       *  and if it is frequently used the user should consider using
                       *  std::list.
                       */
                      template<typename... _Args>
                	iterator
                	emplace(const_iterator __position, _Args&&... __args)
                	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
                
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, const value_type& __x);
                #else
                      /**
                       *  @brief  Inserts given value into %vector before specified iterator.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given value before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(iterator __position, const value_type& __x);
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts given rvalue into %vector before specified iterator.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a copy of the given rvalue before
                       *  the specified location.  Note that this kind of operation
                       *  could be expensive for a %vector and if it is frequently
                       *  used the user should consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, value_type&& __x)
                      { return _M_insert_rval(__position, std::move(__x)); }
                
                      /**
                       *  @brief  Inserts an initializer_list into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __l  An initializer_list.
                       *
                       *  This function will insert copies of the data in the
                       *  initializer_list @a l into the %vector before the location
                       *  specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, initializer_list<value_type> __l)
                      {
                	auto __offset = __position - cbegin();
                	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                			std::random_access_iterator_tag());
                	return begin() + __offset;
                      }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      iterator
                      insert(const_iterator __position, size_type __n, const value_type& __x)
                      {
                	difference_type __offset = __position - cbegin();
                	_M_fill_insert(begin() + __offset, __n, __x);
                	return begin() + __offset;
                      }
                #else
                      /**
                       *  @brief  Inserts a number of copies of given data into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __n  Number of elements to be inserted.
                       *  @param  __x  Data to be inserted.
                       *
                       *  This function will insert a specified number of copies of
                       *  the given data before the location specified by @a position.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      void
                      insert(iterator __position, size_type __n, const value_type& __x)
                      { _M_fill_insert(__position, __n, __x); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  A const_iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *  @return  An iterator that points to the inserted data.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                	insert(const_iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  difference_type __offset = __position - cbegin();
                	  _M_insert_dispatch(begin() + __offset,
                			     __first, __last, __false_type());
                	  return begin() + __offset;
                	}
                #else
                      /**
                       *  @brief  Inserts a range into the %vector.
                       *  @param  __position  An iterator into the %vector.
                       *  @param  __first  An input iterator.
                       *  @param  __last   An input iterator.
                       *
                       *  This function will insert copies of the data in the range
                       *  [__first,__last) into the %vector before the location specified
                       *  by @a pos.
                       *
                       *  Note that this kind of operation could be expensive for a
                       *  %vector and if it is frequently used the user should
                       *  consider using std::list.
                       */
                      template<typename _InputIterator>
                	void
                	insert(iterator __position, _InputIterator __first,
                	       _InputIterator __last)
                	{
                	  // Check whether it's an integral type.  If so, it's not an iterator.
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  _M_insert_dispatch(__position, __first, __last, _Integral());
                	}
                #endif
                
                      /**
                       *  @brief  Remove element at given position.
                       *  @param  __position  Iterator pointing to element to be erased.
                       *  @return  An iterator pointing to the next element (or end()).
                       *
                       *  This function will erase the element at the given position and thus
                       *  shorten the %vector by one.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the element, and that if the element is itself a pointer,
                       *  the pointed-to memory is not touched in any way.  Managing
                       *  the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
        2199 ->       erase(const_iterator __position)
                      { return _M_erase(begin() + (__position - cbegin())); }
                #else
                      erase(iterator __position)
                      { return _M_erase(__position); }
                #endif
                
                      /**
                       *  @brief  Remove a range of elements.
                       *  @param  __first  Iterator pointing to the first element to be erased.
                       *  @param  __last  Iterator pointing to one past the last element to be
                       *                  erased.
                       *  @return  An iterator pointing to the element pointed to by @a __last
                       *           prior to erasing (or end()).
                       *
                       *  This function will erase the elements in the range
                       *  [__first,__last) and shorten the %vector accordingly.
                       *
                       *  Note This operation could be expensive and if it is
                       *  frequently used the user should consider using std::list.
                       *  The user is also cautioned that this function only erases
                       *  the elements, and that if the elements themselves are
                       *  pointers, the pointed-to memory is not touched in any way.
                       *  Managing the pointer is the user's responsibility.
                       */
                      iterator
                #if __cplusplus >= 201103L
         750 ->       erase(const_iterator __first, const_iterator __last)
                      {
                	const auto __beg = begin();
                	const auto __cbeg = cbegin();
                	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
                      }
                #else
                      erase(iterator __first, iterator __last)
                      { return _M_erase(__first, __last); }
                #endif
                
                      /**
                       *  @brief  Swaps data with another %vector.
                       *  @param  __x  A %vector of the same element and allocator types.
                       *
                       *  This exchanges the elements between two vectors in constant time.
                       *  (Three pointers, so it should be quite fast.)
                       *  Note that the global std::swap() function is specialized such that
                       *  std::swap(v1,v2) will feed to this function.
                       *
                       *  Whether the allocators are swapped depends on the allocator traits.
                       */
                      void
                      swap(vector& __x) _GLIBCXX_NOEXCEPT
                      {
                #if __cplusplus >= 201103L
                	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
                			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
                #endif
                	this->_M_impl._M_swap_data(__x._M_impl);
                	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                				  __x._M_get_Tp_allocator());
                      }
                
                      /**
                       *  Erases all the elements.  Note that this function only erases the
                       *  elements, and that if the elements themselves are pointers, the
                       *  pointed-to memory is not touched in any way.  Managing the pointer is
                       *  the user's responsibility.
                       */
                      void
       ##### ->       clear() _GLIBCXX_NOEXCEPT
                      { _M_erase_at_end(this->_M_impl._M_start); }
                
                    protected:
                      /**
                       *  Memory expansion handler.  Uses the member allocation function to
                       *  obtain @a n bytes of memory, and then copies [first,last) into it.
                       */
                      template<typename _ForwardIterator>
                	pointer
       ##### -> 	_M_allocate_and_copy(size_type __n,
                			     _ForwardIterator __first, _ForwardIterator __last)
                	{
                	  pointer __result = this->_M_allocate(__n);
                	  __try
                	    {
                	      std::__uninitialized_copy_a(__first, __last, __result,
                					  _M_get_Tp_allocator());
                	      return __result;
                	    }
                	  __catch(...)
                	    {
                	      _M_deallocate(__result, __n);
                	      __throw_exception_again;
                	    }
                	}
                
                
                      // Internal constructor functions follow.
                
                      // Called by the range constructor to implement [23.1.1]/9
                
                #if __cplusplus < 201103L
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
                	{
                	  this->_M_impl._M_start = _M_allocate(_S_check_init_len(
                		static_cast<size_type>(__n), _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage =
                	    this->_M_impl._M_start + static_cast<size_type>(__n);
                	  _M_fill_initialize(static_cast<size_type>(__n), __value);
                	}
                
                      // Called by the range constructor to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
                			       __false_type)
                	{
                	  _M_range_initialize(__first, __last,
                			      std::__iterator_category(__first));
                	}
                #endif
                
                      // Called by the second initialize_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_initialize(_InputIterator __first, _InputIterator __last,
                			    std::input_iterator_tag)
                	{
                	  __try {
                	    for (; __first != __last; ++__first)
                #if __cplusplus >= 201103L
                	      emplace_back(*__first);
                #else
                	      push_back(*__first);
                #endif
                	  } __catch(...) {
                	    clear();
                	    __throw_exception_again;
                	  }
                	}
                
                      // Called by the second initialize_dispatch above
                      template<typename _ForwardIterator>
                	void
           1 -> 	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                			    std::forward_iterator_tag)
                	{
                	  const size_type __n = std::distance(__first, __last);
                	  this->_M_impl._M_start
                	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
                	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
                	  this->_M_impl._M_finish =
                	    std::__uninitialized_copy_a(__first, __last,
                					this->_M_impl._M_start,
                					_M_get_Tp_allocator());
                	}
                
                      // Called by the first initialize_dispatch above and by the
                      // vector(n,value,a) constructor.
                      void
       ##### ->       _M_fill_initialize(size_type __n, const value_type& __value)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
                					_M_get_Tp_allocator());
                      }
                
                #if __cplusplus >= 201103L
                      // Called by the vector(n) constructor.
                      void
                      _M_default_initialize(size_type __n)
                      {
                	this->_M_impl._M_finish =
                	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
                					   _M_get_Tp_allocator());
                      }
                #endif
                
                      // Internal assign functions follow.  The *_aux functions do the actual
                      // assignment work for the range versions.
                
                      // Called by the range assign to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
                	{ _M_fill_assign(__n, __val); }
                
                      // Called by the range assign to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
                			   __false_type)
                	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
                
                      // Called by the second assign_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_assign_aux(_InputIterator __first, _InputIterator __last,
                		      std::input_iterator_tag);
                
                      // Called by the second assign_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
                		      std::forward_iterator_tag);
                
                      // Called by assign(n,t), and the range assign when it turns out
                      // to be the same thing.
                      void
                      _M_fill_assign(size_type __n, const value_type& __val);
                
                      // Internal insert functions follow.
                
                      // Called by the range insert to implement [23.1.1]/9
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                	void
                	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
                			   __true_type)
                	{ _M_fill_insert(__pos, __n, __val); }
                
                      // Called by the range insert to implement [23.1.1]/9
                      template<typename _InputIterator>
                	void
                	_M_insert_dispatch(iterator __pos, _InputIterator __first,
                			   _InputIterator __last, __false_type)
                	{
                	  _M_range_insert(__pos, __first, __last,
                			  std::__iterator_category(__first));
                	}
                
                      // Called by the second insert_dispatch above
                      template<typename _InputIterator>
                	void
                	_M_range_insert(iterator __pos, _InputIterator __first,
                			_InputIterator __last, std::input_iterator_tag);
                
                      // Called by the second insert_dispatch above
                      template<typename _ForwardIterator>
                	void
                	_M_range_insert(iterator __pos, _ForwardIterator __first,
                			_ForwardIterator __last, std::forward_iterator_tag);
                
                      // Called by insert(p,n,x), and the range insert when it turns out to be
                      // the same thing.
                      void
                      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
                
                #if __cplusplus >= 201103L
                      // Called by resize(n).
                      void
                      _M_default_append(size_type __n);
                
                      bool
                      _M_shrink_to_fit();
                #endif
                
                #if __cplusplus < 201103L
                      // Called by insert(p,x)
                      void
                      _M_insert_aux(iterator __position, const value_type& __x);
                
                      void
                      _M_realloc_insert(iterator __position, const value_type& __x);
                #else
                      // A value_type object constructed with _Alloc_traits::construct()
                      // and destroyed with _Alloc_traits::destroy().
                      struct _Temporary_value
                      {
                	template<typename... _Args>
                	  explicit
                	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
                	  {
                	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
                				     std::forward<_Args>(__args)...);
                	  }
                
                	~_Temporary_value()
                	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
                
                	value_type&
                	_M_val() { return *_M_ptr(); }
                
                      private:
                	_Tp*
                	_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }
                
                	vector* _M_this;
                	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
                      };
                
                      // Called by insert(p,x) and other functions when insertion needs to
                      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
                      template<typename _Arg>
                	void
                	_M_insert_aux(iterator __position, _Arg&& __arg);
                
                      template<typename... _Args>
                	void
                	_M_realloc_insert(iterator __position, _Args&&... __args);
                
                      // Either move-construct at the end, or forward to _M_insert_aux.
                      iterator
                      _M_insert_rval(const_iterator __position, value_type&& __v);
                
                      // Try to emplace at the end, otherwise forward to _M_insert_aux.
                      template<typename... _Args>
                	iterator
                	_M_emplace_aux(const_iterator __position, _Args&&... __args);
                
                      // Emplacing an rvalue of the correct type can use _M_insert_rval.
                      iterator
                      _M_emplace_aux(const_iterator __position, value_type&& __v)
                      { return _M_insert_rval(__position, std::move(__v)); }
                #endif
                
                      // Called by _M_fill_insert, _M_insert_aux etc.
                      size_type
       56939 ->       _M_check_len(size_type __n, const char* __s) const
                      {
                	if (max_size() - size() < __n)
                	  __throw_length_error(__N(__s));
                
                	const size_type __len = size() + (std::max)(size(), __n);
                	return (__len < size() || __len > max_size()) ? max_size() : __len;
                      }
                
                      // Called by constructors to check initial size.
                      static size_type
           1 ->       _S_check_init_len(size_type __n, const allocator_type& __a)
                      {
                	if (__n > _S_max_size(_Tp_alloc_type(__a)))
                	  __throw_length_error(
                	      __N("cannot create std::vector larger than max_size()"));
                	return __n;
                      }
                
                      static size_type
      113879 ->       _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
                      {
                	// std::distance(begin(), end()) cannot be greater than PTRDIFF_MAX,
                	// and realistically we can't store more than PTRDIFF_MAX/sizeof(T)
                	// (even if std::allocator_traits::max_size says we can).
                	const size_t __diffmax
                	  = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
                	const size_t __allocmax = _Alloc_traits::max_size(__a);
                	return (std::min)(__diffmax, __allocmax);
                      }
                
                      // Internal erase functions follow.
                
                      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
                      // _M_assign_aux.
                      void
         750 ->       _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
                      {
                	if (size_type __n = this->_M_impl._M_finish - __pos)
                	  {
                	    std::_Destroy(__pos, this->_M_impl._M_finish,
                			  _M_get_Tp_allocator());
                	    this->_M_impl._M_finish = __pos;
                	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
                	  }
                      }
                
                      iterator
                      _M_erase(iterator __position);
                
                      iterator
                      _M_erase(iterator __first, iterator __last);
                
                #if __cplusplus >= 201103L
                    private:
                      // Constant-time move assignment when source object's memory can be
                      // moved, either because the source's allocator will move too
                      // or because the allocators are equal.
                      void
       38340 ->       _M_move_assign(vector&& __x, true_type) noexcept
                      {
                	vector __tmp(get_allocator());
                	this->_M_impl._M_swap_data(__x._M_impl);
                	__tmp._M_impl._M_swap_data(__x._M_impl);
                	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
                      }
                
                      // Do move assignment when it might not be possible to move source
                      // object's memory, resulting in a linear-time operation.
                      void
                      _M_move_assign(vector&& __x, false_type)
                      {
                	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
                	  _M_move_assign(std::move(__x), true_type());
                	else
                	  {
                	    // The rvalue's allocator cannot be moved and is not equal,
                	    // so we need to individually move each element.
                	    this->_M_assign_aux(std::make_move_iterator(__x.begin()),
                			        std::make_move_iterator(__x.end()),
                				std::random_access_iterator_tag());
                	    __x.clear();
                	  }
                      }
                #endif
                
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                #if __cplusplus >= 201103L
                      template<typename _Ptr>
                	typename std::pointer_traits<_Ptr>::element_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? nullptr : std::__to_address(__ptr); }
                #else
                      template<typename _Up>
                	_Up*
                	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
                	{ return __ptr; }
                
                      template<typename _Ptr>
                	value_type*
                	_M_data_ptr(_Ptr __ptr)
                	{ return empty() ? (value_type*)0 : __ptr.operator->(); }
                
                      template<typename _Ptr>
                	const value_type*
                	_M_data_ptr(_Ptr __ptr) const
                	{ return empty() ? (const value_type*)0 : __ptr.operator->(); }
                #endif
                    };
                
                #if __cpp_deduction_guides >= 201606
                  template<typename _InputIterator, typename _ValT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_ValT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> vector<_ValT, _Allocator>;
                #endif
                
                  /**
                   *  @brief  Vector equality comparison.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff the size and elements of the vectors are equal.
                   *
                   *  This is an equivalence relation.  It is linear in the size of the
                   *  vectors.  Vectors are considered equivalent if their sizes are equal,
                   *  and if corresponding elements compare equal.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return (__x.size() == __y.size()
                	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
                
                #if __cpp_lib_three_way_comparison
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A `vector`.
                   *  @param  __y  A `vector` of the same type as `__x`.
                   *  @return  A value indicating whether `__x` is less than, equal to,
                   *           greater than, or incomparable with `__y`.
                   *
                   *  See `std::lexicographical_compare_three_way()` for how the determination
                   *  is made. This operator is used to synthesize relational operators like
                   *  `<` and `>=` etc.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline __detail::__synth3way_t<_Tp>
                    operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    {
                      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),
                						    __y.begin(), __y.end(),
                						    __detail::__synth3way);
                    }
                #else
                  /**
                   *  @brief  Vector ordering relation.
                   *  @param  __x  A %vector.
                   *  @param  __y  A %vector of the same type as @a __x.
                   *  @return  True iff @a __x is lexicographically less than @a __y.
                   *
                   *  This is a total ordering relation.  It is linear in the size of the
                   *  vectors.  The elements must be comparable with @c <.
                   *
                   *  See std::lexicographical_compare() for how the determination is made.
                  */
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return std::lexicographical_compare(__x.begin(), __x.end(),
                					  __y.begin(), __y.end()); }
                
                  /// Based on operator==
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x == __y); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return __y < __x; }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__y < __x); }
                
                  /// Based on operator<
                  template<typename _Tp, typename _Alloc>
                    inline bool
                    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
                    { return !(__x < __y); }
                #endif // three-way comparison
                
                  /// See std::vector::swap().
                  template<typename _Tp, typename _Alloc>
                    inline void
                    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
                    { __x.swap(__y); }
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // vector into a variant, but only if move assignment cannot throw.
                    template<typename _Tp, typename _Alloc>
                      struct _Never_valueless_alt<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      : std::is_nothrow_move_assignable<_GLIBCXX_STD_C::vector<_Tp, _Alloc>>
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif /* _STL_VECTOR_H */


Top 10 Lines:

     Line      Count

     1043     514090
      918     378787
      276     368337
      109     230040
      280     211562
       97     193964
      350     169970
      829     160184
      343     116284
     1776     113879

Execution Summary:

       50   Executable lines in this file
       50   Lines executed
   100.00   Percent of the file executed

  4135478   Total number of line executions
 82709.56   Average executions per line


*** File /usr/include/SFML/Graphics/Sprite.hpp:
                ////////////////////////////////////////////////////////////
                //
                // SFML - Simple and Fast Multimedia Library
                // Copyright (C) 2007-2018 Laurent Gomila (laurent@sfml-dev.org)
                //
                // This software is provided 'as-is', without any express or implied warranty.
                // In no event will the authors be held liable for any damages arising from the use of this software.
                //
                // Permission is granted to anyone to use this software for any purpose,
                // including commercial applications, and to alter it and redistribute it freely,
                // subject to the following restrictions:
                //
                // 1. The origin of this software must not be misrepresented;
                //    you must not claim that you wrote the original software.
                //    If you use this software in a product, an acknowledgment
                //    in the product documentation would be appreciated but is not required.
                //
                // 2. Altered source versions must be plainly marked as such,
                //    and must not be misrepresented as being the original software.
                //
                // 3. This notice may not be removed or altered from any source distribution.
                //
                ////////////////////////////////////////////////////////////
                
                #ifndef SFML_SPRITE_HPP
                #define SFML_SPRITE_HPP
                
                ////////////////////////////////////////////////////////////
                // Headers
                ////////////////////////////////////////////////////////////
                #include <SFML/Graphics/Export.hpp>
                #include <SFML/Graphics/Drawable.hpp>
                #include <SFML/Graphics/Transformable.hpp>
                #include <SFML/Graphics/Vertex.hpp>
                #include <SFML/Graphics/Rect.hpp>
                
                
                namespace sf
                {
                class Texture;
                
                ////////////////////////////////////////////////////////////
                /// \brief Drawable representation of a texture, with its
                ///        own transformations, color, etc.
                ///
                ////////////////////////////////////////////////////////////
       90116 -> class SFML_GRAPHICS_API Sprite : public Drawable, public Transformable
                {
                public:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Default constructor
                    ///
                    /// Creates an empty sprite with no source texture.
                    ///
                    ////////////////////////////////////////////////////////////
                    Sprite();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct the sprite from a source texture
                    ///
                    /// \param texture Source texture
                    ///
                    /// \see setTexture
                    ///
                    ////////////////////////////////////////////////////////////
                    explicit Sprite(const Texture& texture);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Construct the sprite from a sub-rectangle of a source texture
                    ///
                    /// \param texture   Source texture
                    /// \param rectangle Sub-rectangle of the texture to assign to the sprite
                    ///
                    /// \see setTexture, setTextureRect
                    ///
                    ////////////////////////////////////////////////////////////
                    Sprite(const Texture& texture, const IntRect& rectangle);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Change the source texture of the sprite
                    ///
                    /// The \a texture argument refers to a texture that must
                    /// exist as long as the sprite uses it. Indeed, the sprite
                    /// doesn't store its own copy of the texture, but rather keeps
                    /// a pointer to the one that you passed to this function.
                    /// If the source texture is destroyed and the sprite tries to
                    /// use it, the behavior is undefined.
                    /// If \a resetRect is true, the TextureRect property of
                    /// the sprite is automatically adjusted to the size of the new
                    /// texture. If it is false, the texture rect is left unchanged.
                    ///
                    /// \param texture   New texture
                    /// \param resetRect Should the texture rect be reset to the size of the new texture?
                    ///
                    /// \see getTexture, setTextureRect
                    ///
                    ////////////////////////////////////////////////////////////
                    void setTexture(const Texture& texture, bool resetRect = false);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the sub-rectangle of the texture that the sprite will display
                    ///
                    /// The texture rect is useful when you don't want to display
                    /// the whole texture, but rather a part of it.
                    /// By default, the texture rect covers the entire texture.
                    ///
                    /// \param rectangle Rectangle defining the region of the texture to display
                    ///
                    /// \see getTextureRect, setTexture
                    ///
                    ////////////////////////////////////////////////////////////
                    void setTextureRect(const IntRect& rectangle);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Set the global color of the sprite
                    ///
                    /// This color is modulated (multiplied) with the sprite's
                    /// texture. It can be used to colorize the sprite, or change
                    /// its global opacity.
                    /// By default, the sprite's color is opaque white.
                    ///
                    /// \param color New color of the sprite
                    ///
                    /// \see getColor
                    ///
                    ////////////////////////////////////////////////////////////
                    void setColor(const Color& color);
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the source texture of the sprite
                    ///
                    /// If the sprite has no source texture, a NULL pointer is returned.
                    /// The returned pointer is const, which means that you can't
                    /// modify the texture when you retrieve it with this function.
                    ///
                    /// \return Pointer to the sprite's texture
                    ///
                    /// \see setTexture
                    ///
                    ////////////////////////////////////////////////////////////
                    const Texture* getTexture() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the sub-rectangle of the texture displayed by the sprite
                    ///
                    /// \return Texture rectangle of the sprite
                    ///
                    /// \see setTextureRect
                    ///
                    ////////////////////////////////////////////////////////////
                    const IntRect& getTextureRect() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the global color of the sprite
                    ///
                    /// \return Global color of the sprite
                    ///
                    /// \see setColor
                    ///
                    ////////////////////////////////////////////////////////////
                    const Color& getColor() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the local bounding rectangle of the entity
                    ///
                    /// The returned rectangle is in local coordinates, which means
                    /// that it ignores the transformations (translation, rotation,
                    /// scale, ...) that are applied to the entity.
                    /// In other words, this function returns the bounds of the
                    /// entity in the entity's coordinate system.
                    ///
                    /// \return Local bounding rectangle of the entity
                    ///
                    ////////////////////////////////////////////////////////////
                    FloatRect getLocalBounds() const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Get the global bounding rectangle of the entity
                    ///
                    /// The returned rectangle is in global coordinates, which means
                    /// that it takes into account the transformations (translation,
                    /// rotation, scale, ...) that are applied to the entity.
                    /// In other words, this function returns the bounds of the
                    /// sprite in the global 2D world's coordinate system.
                    ///
                    /// \return Global bounding rectangle of the entity
                    ///
                    ////////////////////////////////////////////////////////////
                    FloatRect getGlobalBounds() const;
                
                private:
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Draw the sprite to a render target
                    ///
                    /// \param target Render target to draw to
                    /// \param states Current render states
                    ///
                    ////////////////////////////////////////////////////////////
                    virtual void draw(RenderTarget& target, RenderStates states) const;
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Update the vertices' positions
                    ///
                    ////////////////////////////////////////////////////////////
                    void updatePositions();
                
                    ////////////////////////////////////////////////////////////
                    /// \brief Update the vertices' texture coordinates
                    ///
                    ////////////////////////////////////////////////////////////
                    void updateTexCoords();
                
                    ////////////////////////////////////////////////////////////
                    // Member data
                    ////////////////////////////////////////////////////////////
                    Vertex         m_vertices[4]; ///< Vertices defining the sprite's geometry
                    const Texture* m_texture;     ///< Texture of the sprite
                    IntRect        m_textureRect; ///< Rectangle defining the area of the source texture to display
                };
                
                } // namespace sf
                
                
                #endif // SFML_SPRITE_HPP
                
                
                ////////////////////////////////////////////////////////////
                /// \class sf::Sprite
                /// \ingroup graphics
                ///
                /// sf::Sprite is a drawable class that allows to easily display
                /// a texture (or a part of it) on a render target.
                ///
                /// It inherits all the functions from sf::Transformable:
                /// position, rotation, scale, origin. It also adds sprite-specific
                /// properties such as the texture to use, the part of it to display,
                /// and some convenience functions to change the overall color of the
                /// sprite, or to get its bounding rectangle.
                ///
                /// sf::Sprite works in combination with the sf::Texture class, which
                /// loads and provides the pixel data of a given texture.
                ///
                /// The separation of sf::Sprite and sf::Texture allows more flexibility
                /// and better performances: indeed a sf::Texture is a heavy resource,
                /// and any operation on it is slow (often too slow for real-time
                /// applications). On the other side, a sf::Sprite is a lightweight
                /// object which can use the pixel data of a sf::Texture and draw
                /// it with its own transformation/color/blending attributes.
                ///
                /// It is important to note that the sf::Sprite instance doesn't
                /// copy the texture that it uses, it only keeps a reference to it.
                /// Thus, a sf::Texture must not be destroyed while it is
                /// used by a sf::Sprite (i.e. never write a function that
                /// uses a local sf::Texture instance for creating a sprite).
                ///
                /// See also the note on coordinates and undistorted rendering in sf::Transformable.
                ///
                /// Usage example:
                /// \code
                /// // Declare and load a texture
                /// sf::Texture texture;
                /// texture.loadFromFile("texture.png");
                ///
                /// // Create a sprite
                /// sf::Sprite sprite;
                /// sprite.setTexture(texture);
                /// sprite.setTextureRect(sf::IntRect(10, 10, 50, 30));
                /// sprite.setColor(sf::Color(255, 255, 255, 200));
                /// sprite.setPosition(100, 25);
                ///
                /// // Draw it
                /// window.draw(sprite);
                /// \endcode
                ///
                /// \see sf::Texture, sf::Transformable
                ///
                ////////////////////////////////////////////////////////////


Top 10 Lines:

     Line      Count

       47      90116

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

    90116   Total number of line executions
 90116.00   Average executions per line


*** File /usr/include/c++/11/bits/basic_string.h:
                // Components for manipulating sequences of characters -*- C++ -*-
                
                // Copyright (C) 1997-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file bits/basic_string.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{string}
                 */
                
                //
                // ISO C++ 14882: 21 Strings library
                //
                
                #ifndef _BASIC_STRING_H
                #define _BASIC_STRING_H 1
                
                #pragma GCC system_header
                
                #include <ext/atomicity.h>
                #include <ext/alloc_traits.h>
                #include <debug/debug.h>
                
                #if __cplusplus >= 201103L
                #include <initializer_list>
                #endif
                
                #if __cplusplus >= 201703L
                # include <string_view>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                #ifdef __cpp_lib_is_constant_evaluated
                // Support P1032R1 in C++20 (but not P0980R1 yet).
                # define __cpp_lib_constexpr_string 201811L
                #elif __cplusplus >= 201703L
                // Support P0426R1 changes to char_traits in C++17.
                # define __cpp_lib_constexpr_string 201611L
                #elif __cplusplus > 201703L
                #endif
                
                #if _GLIBCXX_USE_CXX11_ABI
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _Char_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
                
                      // Types:
                    public:
                      typedef _Traits					traits_type;
                      typedef typename _Traits::char_type		value_type;
                      typedef _Char_alloc_type				allocator_type;
                      typedef typename _Alloc_traits::size_type		size_type;
                      typedef typename _Alloc_traits::difference_type	difference_type;
                      typedef typename _Alloc_traits::reference		reference;
                      typedef typename _Alloc_traits::const_reference	const_reference;
                      typedef typename _Alloc_traits::pointer		pointer;
                      typedef typename _Alloc_traits::const_pointer	const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                							const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		reverse_iterator;
                
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    protected:
                      // type used for positions in insert, erase etc.
                #if __cplusplus < 201103L
                      typedef iterator __const_iterator;
                #else
                      typedef const_iterator __const_iterator;
                #endif
                
                    private:
                #if __cplusplus >= 201703L
                      // A helper type for avoiding boiler-plate.
                      typedef basic_string_view<_CharT, _Traits> __sv_type;
                
                      template<typename _Tp, typename _Res>
                	using _If_sv = enable_if_t<
                	  __and_<is_convertible<const _Tp&, __sv_type>,
                		 __not_<is_convertible<const _Tp*, const basic_string*>>,
                		 __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
                	  _Res>;
                
                      // Allows an implicit conversion to __sv_type.
                      static __sv_type
                      _S_to_string_view(__sv_type __svt) noexcept
                      { return __svt; }
                
                      // Wraps a string_view by explicit conversion and thus
                      // allows to add an internal constructor that does not
                      // participate in overload resolution when a string_view
                      // is provided.
                      struct __sv_wrapper
                      {
                	explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
                	__sv_type _M_sv;
                      };
                
                      /**
                       *  @brief  Only internally used: Construct string from a string view
                       *          wrapper.
                       *  @param  __svw  string view wrapper.
                       *  @param  __a  Allocator to use.
                       */
                      explicit
                      basic_string(__sv_wrapper __svw, const _Alloc& __a)
                      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                #endif
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
        1593 ->       struct _Alloc_hider : allocator_type // TODO check __is_final
                      {
                #if __cplusplus < 201103L
                	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
                	: allocator_type(__a), _M_p(__dat) { }
                #else
                	_Alloc_hider(pointer __dat, const _Alloc& __a)
                	: allocator_type(__a), _M_p(__dat) { }
                
                	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
                	: allocator_type(std::move(__a)), _M_p(__dat) { }
                #endif
                
                	pointer _M_p; // The actual data.
                      };
                
                      _Alloc_hider	_M_dataplus;
                      size_type		_M_string_length;
                
                      enum { _S_local_capacity = 15 / sizeof(_CharT) };
                
                      union
                      {
                	_CharT           _M_local_buf[_S_local_capacity + 1];
                	size_type        _M_allocated_capacity;
                      };
                
                      void
                      _M_data(pointer __p)
                      { _M_dataplus._M_p = __p; }
                
                      void
                      _M_length(size_type __length)
                      { _M_string_length = __length; }
                
                      pointer
        3186 ->       _M_data() const
                      { return _M_dataplus._M_p; }
                
                      pointer
                      _M_local_data()
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
                #else
                	return pointer(_M_local_buf);
                #endif
                      }
                
                      const_pointer
        1593 ->       _M_local_data() const
                      {
                #if __cplusplus >= 201103L
                	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
                #else
                	return const_pointer(_M_local_buf);
                #endif
                      }
                
                      void
                      _M_capacity(size_type __capacity)
                      { _M_allocated_capacity = __capacity; }
                
                      void
                      _M_set_length(size_type __n)
                      {
                	_M_length(__n);
                	traits_type::assign(_M_data()[__n], _CharT());
                      }
                
                      bool
        1593 ->       _M_is_local() const
                      { return _M_data() == _M_local_data(); }
                
                      // Create & Destroy
                      pointer
                      _M_create(size_type&, size_type);
                
                      void
        1593 ->       _M_dispose()
                      {
                	if (!_M_is_local())
                	  _M_destroy(_M_allocated_capacity);
                      }
                
                      void
        1593 ->       _M_destroy(size_type __size) throw()
                      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
                
                      // _M_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIterator is an integral type
                      template<typename _InIterator>
                        void
                        _M_construct_aux(_InIterator __beg, _InIterator __end,
                			 std::__false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          _M_construct(__beg, __end, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<typename _Integer>
                        void
                        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
                	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
                
                      void
                      _M_construct_aux_2(size_type __req, _CharT __c)
                      { _M_construct(__req, __c); }
                
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  _M_construct_aux(__beg, __end, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<typename _InIterator>
                        void
                        _M_construct(_InIterator __beg, _InIterator __end,
                		     std::input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<typename _FwdIterator>
                        void
                        _M_construct(_FwdIterator __beg, _FwdIterator __end,
                		     std::forward_iterator_tag);
                
                      void
                      _M_construct(size_type __req, _CharT __c);
                
                      allocator_type&
        1593 ->       _M_get_allocator()
                      { return _M_dataplus; }
                
                      const allocator_type&
                      _M_get_allocator() const
                      { return _M_dataplus; }
                
                    private:
                
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                      // The explicit instantiations in misc-inst.cc require this due to
                      // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=64063
                      template<typename _Tp, bool _Requires =
                	       !__are_same<_Tp, _CharT*>::__value
                	       && !__are_same<_Tp, const _CharT*>::__value
                	       && !__are_same<_Tp, iterator>::__value
                	       && !__are_same<_Tp, const_iterator>::__value>
                	struct __enable_if_not_native_iterator
                	{ typedef basic_string& __type; };
                      template<typename _Tp>
                	struct __enable_if_not_native_iterator<_Tp, false> { };
                #endif
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);
                      }
                
                      static void
                      _S_assign(_CharT* __d, size_type __n, _CharT __c)
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, (void)++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_assign(const basic_string&);
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
                		size_type __len2);
                
                      void
                      _M_erase(size_type __pos, size_type __n);
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                      _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)
                      : _M_dataplus(_M_local_data())
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_set_length(0); }
                
                      /**
                       *  @brief  Construct string with copy of value of @a __str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str)
                      : _M_dataplus(_M_local_data(),
                		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
                      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2583. no way to supply an allocator for basic_string(str, pos)
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, npos));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n)
                      : _M_dataplus(_M_local_data())
                      {
                	const _CharT* __start = __str._M_data()
                	  + __str._M_check(__pos, "basic_string::basic_string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __start
                	  = __str._M_data() + __str._M_check(__pos, "string::string");
                	_M_construct(__start, __start + __str._M_limit(__pos, __n));
                      }
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__s, __s + __n); }
                
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3076. basic_string CTAD ambiguity
                      template<typename = _RequireAllocator<_Alloc>>
                #endif
        4563 ->       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	const _CharT* __end = __s ? __s + traits_type::length(__s)
                	  // We just need a non-null pointer here to get an exception:
                	  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
                	_M_construct(__s, __end, random_access_iterator_tag());
                      }
                
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3076. basic_string CTAD ambiguity
                      template<typename = _RequireAllocator<_Alloc>>
                #endif
         956 ->       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string(basic_string&& __str) noexcept
                      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	  }
                	else
                	  {
                	    _M_data(__str._M_data());
                	    _M_capacity(__str._M_allocated_capacity);
                	  }
                
                	// Must use _M_length() here not _M_set_length() because
                	// basic_stringbuf relies on writing into unallocated capacity so
                	// we mess up the contents if we put a '\0' in the string.
                	_M_length(__str.length());
                	__str._M_data(__str._M_local_data());
                	__str._M_set_length(0);
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__l.begin(), __l.end()); }
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(_M_local_data(), __a)
                      { _M_construct(__str.begin(), __str.end()); }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      noexcept(_Alloc_traits::_S_always_equal())
                      : _M_dataplus(_M_local_data(), __a)
                      {
                	if (__str._M_is_local())
                	  {
                	    traits_type::copy(_M_local_buf, __str._M_local_buf,
                			      _S_local_capacity + 1);
                	    _M_length(__str.length());
                	    __str._M_set_length(0);
                	  }
                	else if (_Alloc_traits::_S_always_equal()
                	    || __str.get_allocator() == __a)
                	  {
                	    _M_data(__str._M_data());
                	    _M_length(__str.length());
                	    _M_capacity(__str._M_allocated_capacity);
                	    __str._M_data(__str._M_local_buf);
                	    __str._M_set_length(0);
                	  }
                	else
                	  _M_construct(__str.begin(), __str.end());
                      }
                
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cplusplus >= 201103L
                      template<typename _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<typename _InputIterator>
                #endif
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc())
                	: _M_dataplus(_M_local_data(), __a)
                	{ _M_construct(__beg, __end); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Construct string from a substring of a string_view.
                       *  @param  __t   Source object convertible to string view.
                       *  @param  __pos The index of the first character to copy from __t.
                       *  @param  __n   The number of characters to copy from __t.
                       *  @param  __a   Allocator to use.
                       */
                      template<typename _Tp,
                	       typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>
                	basic_string(const _Tp& __t, size_type __pos, size_type __n,
                		     const _Alloc& __a = _Alloc())
                	: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }
                
                      /**
                       *  @brief  Construct string from a string_view.
                       *  @param  __t  Source object convertible to string view.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	explicit
                	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
                	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
                #endif // C++17
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
        1593 ->       ~basic_string()
                      { _M_dispose(); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      {
                	return this->assign(__str);
                      }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s)
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c)
                      {
                	this->assign(1, __c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2063. Contradictory requirements for string move assignment
                      basic_string&
                      operator=(basic_string&& __str)
                      noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
                	    && !_Alloc_traits::_S_always_equal()
                	    && _M_get_allocator() != __str._M_get_allocator())
                	  {
                	    // Destroy existing storage before replacing allocator.
                	    _M_destroy(_M_allocated_capacity);
                	    _M_data(_M_local_data());
                	    _M_set_length(0);
                	  }
                	// Replace allocator if POCMA is true.
                	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
                
                	if (__str._M_is_local())
                	  {
                	    // We've always got room for a short string, just copy it
                	    // (unless this is a self-move, because that would violate the
                	    // char_traits::copy precondition that the ranges don't overlap).
                	    if (__builtin_expect(std::__addressof(__str) != this, true))
                	      {
                		if (__str.size())
                		  this->_S_copy(_M_data(), __str._M_data(), __str.size());
                		_M_set_length(__str.size());
                	      }
                	  }
                	else if (_Alloc_traits::_S_propagate_on_move_assign()
                	    || _Alloc_traits::_S_always_equal()
                	    || _M_get_allocator() == __str._M_get_allocator())
                	  {
                	    // Just move the allocated pointer, our allocator can free it.
                	    pointer __data = nullptr;
                	    size_type __capacity;
                	    if (!_M_is_local())
                	      {
                		if (_Alloc_traits::_S_always_equal())
                		  {
                		    // __str can reuse our existing storage.
                		    __data = _M_data();
                		    __capacity = _M_allocated_capacity;
                		  }
                		else // __str can't use it, so free it.
                		  _M_destroy(_M_allocated_capacity);
                	      }
                
                	    _M_data(__str._M_data());
                	    _M_length(__str.length());
                	    _M_capacity(__str._M_allocated_capacity);
                	    if (__data)
                	      {
                		__str._M_data(__data);
                		__str._M_capacity(__capacity);
                	      }
                	    else
                	      __str._M_data(__str._M_local_buf);
                	  }
                	else // Need to do a deep copy
                	  assign(__str);
                	__str.clear();
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value to string constructed from a string_view.
                       *  @param  __svt  An object convertible to string_view.
                       */
                     template<typename _Tp>
                       _If_sv<_Tp, basic_string&>
                       operator=(const _Tp& __svt)
                       { return this->assign(__svt); }
                
                      /**
                       *  @brief  Convert to a string_view.
                       *  @return A string_view.
                       */
                      operator __sv_type() const noexcept
                      { return __sv_type(data(), size()); }
                #endif // C++17
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.
                       */
                      iterator
                      begin() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.
                       */
                      iterator
                      end() _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.
                       */
                      reverse_iterator
                      rbegin() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.
                       */
                      reverse_iterator
                      rend() _GLIBCXX_NOEXCEPT
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_string_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() noexcept
                      { reserve(); }
                #pragma GCC diagnostic pop
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      {
                	return _M_is_local() ? size_type(_S_local_capacity)
                	                     : _M_allocated_capacity;
                      }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg);
                
                      /**
                       *  Equivalent to shrink_to_fit().
                       */
                #if __cplusplus > 201703L
                      [[deprecated("use shrink_to_fit() instead")]]
                #endif
                      void
                      reserve();
                
                      /**
                       *  Erases the string, making it empty.
                       */
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      { _M_set_length(0); }
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_assert(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	__glibcxx_assert(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front() noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back() noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      {
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt  An object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator+=(const _Tp& __svt)
                	{ return this->append(__svt); }
                #endif // C++17
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str)
                      { return _M_append(__str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return _M_append(__str._M_data()
                			 + __str._M_check(__pos, "basic_string::append"),
                			 __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	const size_type __n = traits_type::length(__s);
                	_M_check_length(size_type(0), __n, "basic_string::append");
                	return _M_append(__s, __n);
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c)
                      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(end(), end(), __first, __last); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt  An object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        append(const _Tp& __svt)
                        {
                          __sv_type __sv = __svt;
                          return this->append(__sv.data(), __sv.size());
                        }
                
                      /**
                       *  @brief  Append a range of characters from a string_view.
                       *  @param __svt  An object convertible to string_view to be appended from.
                       *  @param __pos The position in the string_view to append from.
                       *  @param __n   The number of characters to append from the string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return _M_append(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      {
                	const size_type __size = this->size();
                	if (__size + 1 > this->capacity())
                	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
                	traits_type::assign(this->_M_data()[__size], __c);
                	this->_M_set_length(__size + 1);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str)
                      {
                #if __cplusplus >= 201103L
                	if (_Alloc_traits::_S_propagate_on_copy_assign())
                	  {
                	    if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
                		&& _M_get_allocator() != __str._M_get_allocator())
                	      {
                		// Propagating allocator cannot free existing storage so must
                		// deallocate it before replacing current allocator.
                		if (__str.size() <= _S_local_capacity)
                		  {
                		    _M_destroy(_M_allocated_capacity);
                		    _M_data(_M_local_data());
                		    _M_set_length(0);
                		  }
                		else
                		  {
                		    const auto __len = __str.size();
                		    auto __alloc = __str._M_get_allocator();
                		    // If this allocation throws there are no effects:
                		    auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
                		    _M_destroy(_M_allocated_capacity);
                		    _M_data(__ptr);
                		    _M_capacity(__len);
                		    _M_set_length(__len);
                		  }
                	      }
                	    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
                	  }
                #endif
                	this->_M_assign(__str);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      noexcept(_Alloc_traits::_S_nothrow_move())
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 2063. Contradictory requirements for string move assignment
                	return *this = std::move(__str);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return _M_replace(size_type(0), this->size(), __str._M_data()
                			  + __str._M_check(__pos, "basic_string::assign"),
                			  __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n)
                      {
                	__glibcxx_requires_string_len(__s, __n);
                	return _M_replace(size_type(0), this->size(), __s, __n);
                      }
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return _M_replace(size_type(0), this->size(), __s,
                			  traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                #else
                      template<class _InputIterator>
                #endif
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(begin(), end(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value from a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->assign(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Set value from a range of characters in a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @param __pos  The position in the string_view to assign from.
                       *  @param __n  The number of characters to assign.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return _M_replace(size_type(0), this->size(),
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(const_iterator __p, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	this->replace(__p, __p, __n, __c);
                	return iterator(this->_M_data() + __pos);
                      }
                #else
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Const_iterator referencing location in string to
                       *              insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @return  Iterator referencing the first inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [beg,end).  If adding characters
                       *  causes the length to exceed max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                	iterator
                        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	  const size_type __pos = __p - begin();
                	  this->replace(__p, __p, __beg, __end);
                	  return iterator(this->_M_data() + __pos);
                	}
                #else
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                #endif
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      iterator
                      insert(const_iterator __p, initializer_list<_CharT> __l)
                      { return this->insert(__p, __l.begin(), __l.end()); }
                
                #ifdef _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // See PR libstdc++/83328
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	this->insert(__p - begin(), __l.begin(), __l.size());
                      }
                #endif
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1 Position in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->replace(__pos1, size_type(0),
                			     __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __str   The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n = npos)
                      { return this->replace(__pos1, size_type(0), __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::insert"),
                			     __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Position in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n)
                      { return this->replace(__pos, size_type(0), __s, __n); }
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Position in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, size_type(0), __s,
                			     traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(__const_iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= begin() && __p <= end());
                	const size_type __pos = __p - begin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	return iterator(_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos  Position in string to insert at.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->insert(__pos, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos1, const _Tp& __svt,
                	       size_type __pos2, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, size_type(0),
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
                	      std::__sv_limit(__sv.size(), __pos2, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      {
                	_M_check(__pos, "basic_string::erase");
                	if (__n == npos)
                	  this->_M_set_length(__pos);
                	else if (__n != 0)
                	  this->_M_erase(__pos, _M_limit(__pos, __n));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= begin()
                				 && __position < end());
                	const size_type __pos = __position - begin();
                	this->_M_erase(__pos, size_type(1));
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(__const_iterator __first, __const_iterator __last)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
                				 && __last <= end());
                        const size_type __pos = __first - begin();
                	if (__last == end())
                	  this->_M_set_length(__pos);
                	else
                	  this->_M_erase(__pos, __last - __first);
                	return iterator(this->_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() noexcept
                      {
                	__glibcxx_assert(!empty());
                	_M_erase(size() - 1, 1);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2)
                      {
                	__glibcxx_requires_string_len(__s, __n2);
                	return _M_replace(_M_check(__pos, "basic_string::replace"),
                			  _M_limit(__pos, __n1), __s, __n2);
                      }
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
                	      _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                #if __cplusplus >= 201103L
                      template<class _InputIterator,
                	       typename = std::_RequireInputIter<_InputIterator>>
                        basic_string&
                        replace(const_iterator __i1, const_iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
                					   std::__false_type());
                	}
                #else
                      template<class _InputIterator>
                #ifdef _GLIBCXX_DISAMBIGUATE_REPLACE_INST
                        typename __enable_if_not_native_iterator<_InputIterator>::__type
                #else
                        basic_string&
                #endif
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				   && __i2 <= end());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                #endif
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(__const_iterator __i1, __const_iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(begin() <= __i1 && __i1 <= __i2
                				 && __i2 <= end());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - begin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(const_iterator __i1, const_iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos  The position to replace at.
                       *  @param __n    The number of characters to replace.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos, size_type __n, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos, __n, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos1  The position to replace at.
                       *  @param __n1    The number of characters to replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  The position in the string_view to insert from.
                       *  @param __n2    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, __n1,
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
                	      std::__sv_limit(__sv.size(), __pos2, __n2));
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __i1    An iterator referencing the start position
                          to replace at.
                       *  @param __i2    An iterator referencing the end position
                          for the replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__i1 - begin(), __i2 - __i1, __sv);
                	}
                #endif // C++17
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _Integer __n, _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(const_iterator __i1, const_iterator __i2,
                			    _InputIterator __k1, _InputIterator __k2,
                			    __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
                		 const size_type __len2);
                
                      basic_string&
                      _M_append(const _CharT* __s, size_type __n);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s) _GLIBCXX_NOEXCEPT;
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a pointer to internal data.  It is undefined to modify
                       *  the contents through the returned pointer. To get a pointer that
                       *  allows modifying the contents use @c &str[0] instead,
                       *  (or in C++17 the non-const @c str.data() overload).
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Return non-const pointer to contents.
                       *
                       *  This is a pointer to the character sequence held by the string.
                       *  Modifying the characters in the sequence is allowed.
                      */
                      _CharT*
                      data() noexcept
                      { return _M_data(); }
                #endif
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_get_allocator(); }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	rfind(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->rfind(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character of a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character not in a string_view.
                       *  @param __svt  A object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const _GLIBCXX_NOEXCEPT;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __svt An object convertible to string_view to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  const size_type __size = this->size();
                	  const size_type __osize = __sv.size();
                	  const size_type __len = std::min(__size, __osize);
                
                	  int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                	  if (!__r)
                	    __r = _S_compare(__size, __osize);
                	  return __r;
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos  A position in the string to start comparing from.
                       *  @param __n  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos, size_type __n, const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this).substr(__pos, __n).compare(__sv);
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos1  A position in the string to start comparing from.
                       *  @param __n1  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @param __pos2  A position in the string_view to start comparing from.
                       *  @param __n2  The number of characters to compare.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this)
                	    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                
                #if __cplusplus > 201703L
                      bool
                      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                #endif // C++20
                
                #if __cplusplus > 202002L
                      bool
                      contains(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                
                      bool
                      contains(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                
                      bool
                      contains(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                #endif // C++23
                
                      // Allow basic_stringbuf::__xfer_bufptrs to call _M_length:
                      template<typename, typename, typename> friend class basic_stringbuf;
                    };
                _GLIBCXX_END_NAMESPACE_CXX11
                #else  // !_GLIBCXX_USE_CXX11_ABI
                  // Reference-counted COW string implentation
                
                  /**
                   *  @class basic_string basic_string.h <string>
                   *  @brief  Managing sequences of characters and character-like objects.
                   *
                   *  @ingroup strings
                   *  @ingroup sequences
                   *
                   *  @tparam _CharT  Type of character
                   *  @tparam _Traits  Traits for character type, defaults to
                   *                   char_traits<_CharT>.
                   *  @tparam _Alloc  Allocator type, defaults to allocator<_CharT>.
                   *
                   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
                   *  <a href="tables.html#66">reversible container</a>, and a
                   *  <a href="tables.html#67">sequence</a>.  Of the
                   *  <a href="tables.html#68">optional sequence requirements</a>, only
                   *  @c push_back, @c at, and @c %array access are supported.
                   *
                   *  @doctodo
                   *
                   *
                   *  Documentation?  What's that?
                   *  Nathan Myers <ncm@cantrip.org>.
                   *
                   *  A string looks like this:
                   *
                   *  @code
                   *                                        [_Rep]
                   *                                        _M_length
                   *   [basic_string<char_type>]            _M_capacity
                   *   _M_dataplus                          _M_refcount
                   *   _M_p ---------------->               unnamed array of char_type
                   *  @endcode
                   *
                   *  Where the _M_p points to the first character in the string, and
                   *  you cast it to a pointer-to-_Rep and subtract 1 to get a
                   *  pointer to the header.
                   *
                   *  This approach has the enormous advantage that a string object
                   *  requires only one allocation.  All the ugliness is confined
                   *  within a single %pair of inline functions, which each compile to
                   *  a single @a add instruction: _Rep::_M_data(), and
                   *  string::_M_rep(); and the allocation function which gets a
                   *  block of raw bytes and with room enough and constructs a _Rep
                   *  object at the front.
                   *
                   *  The reason you want _M_data pointing to the character %array and
                   *  not the _Rep is so that the debugger can see the string
                   *  contents. (Probably we should add a non-inline member to get
                   *  the _Rep for the debugger to use, so users can check the actual
                   *  string length.)
                   *
                   *  Note that the _Rep object is a POD so that you can have a
                   *  static <em>empty string</em> _Rep object already @a constructed before
                   *  static constructors have run.  The reference-count encoding is
                   *  chosen so that a 0 indicates one reference, so you never try to
                   *  destroy the empty-string _Rep object.
                   *
                   *  All but the last paragraph is considered pretty conventional
                   *  for a C++ string implementation.
                  */
                  // 21.3  Template class basic_string
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    class basic_string
                    {
                      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	rebind<_CharT>::other _CharT_alloc_type;
                      typedef __gnu_cxx::__alloc_traits<_CharT_alloc_type> _CharT_alloc_traits;
                
                      // Types:
                    public:
                      typedef _Traits					    traits_type;
                      typedef typename _Traits::char_type		    value_type;
                      typedef _Alloc					    allocator_type;
                      typedef typename _CharT_alloc_traits::size_type	    size_type;
                      typedef typename _CharT_alloc_traits::difference_type difference_type;
                #if __cplusplus < 201103L
                      typedef typename _CharT_alloc_type::reference	    reference;
                      typedef typename _CharT_alloc_type::const_reference   const_reference;
                #else
                      typedef value_type&				    reference;
                      typedef const value_type&				    const_reference;
                #endif
                      typedef typename _CharT_alloc_traits::pointer	    pointer;
                      typedef typename _CharT_alloc_traits::const_pointer   const_pointer;
                      typedef __gnu_cxx::__normal_iterator<pointer, basic_string>  iterator;
                      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                                            const_iterator;
                      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
                      typedef std::reverse_iterator<iterator>		    reverse_iterator;
                
                    protected:
                      // type used for positions in insert, erase etc.
                      typedef iterator __const_iterator;
                
                    private:
                      // _Rep: string representation
                      //   Invariants:
                      //   1. String really contains _M_length + 1 characters: due to 21.3.4
                      //      must be kept null-terminated.
                      //   2. _M_capacity >= _M_length
                      //      Allocated memory is always (_M_capacity + 1) * sizeof(_CharT).
                      //   3. _M_refcount has three states:
                      //      -1: leaked, one reference, no ref-copies allowed, non-const.
                      //       0: one reference, non-const.
                      //     n>0: n + 1 references, operations require a lock, const.
                      //   4. All fields==0 is an empty string, given the extra storage
                      //      beyond-the-end for a null terminator; thus, the shared
                      //      empty string representation needs no constructor.
                
                      struct _Rep_base
                      {
                	size_type		_M_length;
                	size_type		_M_capacity;
                	_Atomic_word		_M_refcount;
                      };
                
                      struct _Rep : _Rep_base
                      {
                	// Types:
                	typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
                	  rebind<char>::other _Raw_bytes_alloc;
                
                	// (Public) Data members:
                
                	// The maximum number of individual char_type elements of an
                	// individual string is determined by _S_max_size. This is the
                	// value that will be returned by max_size().  (Whereas npos
                	// is the maximum number of bytes the allocator can allocate.)
                	// If one was to divvy up the theoretical largest size string,
                	// with a terminating character and m _CharT elements, it'd
                	// look like this:
                	// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)
                	// Solving for m:
                	// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1
                	// In addition, this implementation quarters this amount.
                	static const size_type	_S_max_size;
                	static const _CharT	_S_terminal;
                
                	// The following storage is init'd to 0 by the linker, resulting
                        // (carefully) in an empty string with one reference.
                        static size_type _S_empty_rep_storage[];
                
                        static _Rep&
                        _S_empty_rep() _GLIBCXX_NOEXCEPT
                        { 
                	  // NB: Mild hack to avoid strict-aliasing warnings.  Note that
                	  // _S_empty_rep_storage is never modified and the punning should
                	  // be reasonably safe in this case.
                	  void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
                	  return *reinterpret_cast<_Rep*>(__p);
                	}
                
                        bool
                	_M_is_leaked() const _GLIBCXX_NOEXCEPT
                        {
                #if defined(__GTHREADS)
                          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,
                          // so we need to use an atomic load. However, _M_is_leaked
                          // predicate does not change concurrently (i.e. the string is either
                          // leaked or not), so a relaxed load is enough.
                          return __atomic_load_n(&this->_M_refcount, __ATOMIC_RELAXED) < 0;
                #else
                          return this->_M_refcount < 0;
                #endif
                        }
                
                        bool
                	_M_is_shared() const _GLIBCXX_NOEXCEPT
                	{
                #if defined(__GTHREADS)
                          // _M_refcount is mutated concurrently by _M_refcopy/_M_dispose,
                          // so we need to use an atomic load. Another thread can drop last
                          // but one reference concurrently with this check, so we need this
                          // load to be acquire to synchronize with release fetch_and_add in
                          // _M_dispose.
                          return __atomic_load_n(&this->_M_refcount, __ATOMIC_ACQUIRE) > 0;
                #else
                          return this->_M_refcount > 0;
                #endif
                        }
                
                        void
                	_M_set_leaked() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = -1; }
                
                        void
                	_M_set_sharable() _GLIBCXX_NOEXCEPT
                        { this->_M_refcount = 0; }
                
                	void
                	_M_set_length_and_sharable(size_type __n) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      this->_M_set_sharable();  // One reference.
                	      this->_M_length = __n;
                	      traits_type::assign(this->_M_refdata()[__n], _S_terminal);
                	      // grrr. (per 21.3.4)
                	      // You cannot leave those LWG people alone for a second.
                	    }
                	}
                
                	_CharT*
                	_M_refdata() throw()
                	{ return reinterpret_cast<_CharT*>(this + 1); }
                
                	_CharT*
                	_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
                	{
                	  return (!_M_is_leaked() && __alloc1 == __alloc2)
                	          ? _M_refcopy() : _M_clone(__alloc1);
                	}
                
                	// Create & Destroy
                	static _Rep*
                	_S_create(size_type, size_type, const _Alloc&);
                
                	void
                	_M_dispose(const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                	    {
                	      // Be race-detector-friendly.  For more info see bits/c++config.
                	      _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&this->_M_refcount);
                              // Decrement of _M_refcount is acq_rel, because:
                              // - all but last decrements need to release to synchronize with
                              //   the last decrement that will delete the object.
                              // - the last decrement needs to acquire to synchronize with
                              //   all the previous decrements.
                              // - last but one decrement needs to release to synchronize with
                              //   the acquire load in _M_is_shared that will conclude that
                              //   the object is not shared anymore.
                	      if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
                							 -1) <= 0)
                		{
                		  _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&this->_M_refcount);
                		  _M_destroy(__a);
                		}
                	    }
                	}  // XXX MT
                
                	void
                	_M_destroy(const _Alloc&) throw();
                
                	_CharT*
                	_M_refcopy() throw()
                	{
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	  if (__builtin_expect(this != &_S_empty_rep(), false))
                #endif
                            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
                	  return _M_refdata();
                	}  // XXX MT
                
                	_CharT*
                	_M_clone(const _Alloc&, size_type __res = 0);
                      };
                
                      // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
                      struct _Alloc_hider : _Alloc
                      {
                	_Alloc_hider(_CharT* __dat, const _Alloc& __a) _GLIBCXX_NOEXCEPT
                	: _Alloc(__a), _M_p(__dat) { }
                
                	_CharT* _M_p; // The actual data.
                      };
                
                    public:
                      // Data Members (public):
                      // NB: This is an unsigned type, and thus represents the maximum
                      // size that the allocator can hold.
                      ///  Value returned by various member functions when they fail.
                      static const size_type	npos = static_cast<size_type>(-1);
                
                    private:
                      // Data Members (private):
                      mutable _Alloc_hider	_M_dataplus;
                
                      _CharT*
                      _M_data() const _GLIBCXX_NOEXCEPT
                      { return  _M_dataplus._M_p; }
                
                      _CharT*
                      _M_data(_CharT* __p) _GLIBCXX_NOEXCEPT
                      { return (_M_dataplus._M_p = __p); }
                
                      _Rep*
                      _M_rep() const _GLIBCXX_NOEXCEPT
                      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
                
                      // For the internal use we have functions similar to `begin'/`end'
                      // but they do not call _M_leak.
                      iterator
                      _M_ibegin() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data()); }
                
                      iterator
                      _M_iend() const _GLIBCXX_NOEXCEPT
                      { return iterator(_M_data() + this->size()); }
                
                      void
                      _M_leak()    // for use in begin() & non-const op[]
                      {
                	if (!_M_rep()->_M_is_leaked())
                	  _M_leak_hard();
                      }
                
                      size_type
                      _M_check(size_type __pos, const char* __s) const
                      {
                	if (__pos > this->size())
                	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
                				       "this->size() (which is %zu)"),
                				   __s, __pos, this->size());
                	return __pos;
                      }
                
                      void
                      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
                      {
                	if (this->max_size() - (this->size() - __n1) < __n2)
                	  __throw_length_error(__N(__s));
                      }
                
                      // NB: _M_limit doesn't check for a bad __pos value.
                      size_type
                      _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
                      {
                	const bool __testoff =  __off < this->size() - __pos;
                	return __testoff ? __off : this->size() - __pos;
                      }
                
                      // True if _Rep and source do not overlap.
                      bool
                      _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
                      {
                	return (less<const _CharT*>()(__s, _M_data())
                		|| less<const _CharT*>()(_M_data() + this->size(), __s));
                      }
                
                      // When __n = 1 way faster than the general multichar
                      // traits_type::copy/move/assign.
                      static void
                      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::copy(__d, __s, __n);
                      }
                
                      static void
                      _M_move(_CharT* __d, const _CharT* __s, size_type __n) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, *__s);
                	else
                	  traits_type::move(__d, __s, __n);	  
                      }
                
                      static void
                      _M_assign(_CharT* __d, size_type __n, _CharT __c) _GLIBCXX_NOEXCEPT
                      {
                	if (__n == 1)
                	  traits_type::assign(*__d, __c);
                	else
                	  traits_type::assign(__d, __n, __c);	  
                      }
                
                      // _S_copy_chars is a separate template to permit specialization
                      // to optimize for the common case of pointers as iterators.
                      template<class _Iterator>
                        static void
                        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
                        {
                	  for (; __k1 != __k2; ++__k1, (void)++__p)
                	    traits_type::assign(*__p, *__k1); // These types are off.
                	}
                
                      static void
                      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
                      _GLIBCXX_NOEXCEPT
                      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
                
                      static void
                      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static void
                      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
                      _GLIBCXX_NOEXCEPT
                      { _M_copy(__p, __k1, __k2 - __k1); }
                
                      static int
                      _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
                      {
                	const difference_type __d = difference_type(__n1 - __n2);
                
                	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
                	  return __gnu_cxx::__numeric_traits<int>::__max;
                	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
                	  return __gnu_cxx::__numeric_traits<int>::__min;
                	else
                	  return int(__d);
                      }
                
                      void
                      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
                
                      void
                      _M_leak_hard();
                
                      static _Rep&
                      _S_empty_rep() _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_empty_rep(); }
                
                #if __cplusplus >= 201703L
                      // A helper type for avoiding boiler-plate.
                      typedef basic_string_view<_CharT, _Traits> __sv_type;
                
                      template<typename _Tp, typename _Res>
                	using _If_sv = enable_if_t<
                	  __and_<is_convertible<const _Tp&, __sv_type>,
                		 __not_<is_convertible<const _Tp*, const basic_string*>>,
                		 __not_<is_convertible<const _Tp&, const _CharT*>>>::value,
                	  _Res>;
                
                      // Allows an implicit conversion to __sv_type.
                      static __sv_type
                      _S_to_string_view(__sv_type __svt) noexcept
                      { return __svt; }
                
                      // Wraps a string_view by explicit conversion and thus
                      // allows to add an internal constructor that does not
                      // participate in overload resolution when a string_view
                      // is provided.
                      struct __sv_wrapper
                      {
                	explicit __sv_wrapper(__sv_type __sv) noexcept : _M_sv(__sv) { }
                	__sv_type _M_sv;
                      };
                
                      /**
                       *  @brief  Only internally used: Construct string from a string view
                       *          wrapper.
                       *  @param  __svw  string view wrapper.
                       *  @param  __a  Allocator to use.
                       */
                      explicit
                      basic_string(__sv_wrapper __svw, const _Alloc& __a)
                      : basic_string(__svw._M_sv.data(), __svw._M_sv.size(), __a) { }
                #endif
                
                    public:
                      // Construct/copy/destroy:
                      // NB: We overload ctors in some cases instead of using default
                      // arguments, per 17.4.4.4 para. 2 item 2.
                
                      /**
                       *  @brief  Default constructor creates an empty string.
                       */
                      basic_string()
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      _GLIBCXX_NOEXCEPT
                      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc())
                #else
                      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc())
                #endif
                      { }
                
                      /**
                       *  @brief  Construct an empty string using allocator @a a.
                       */
                      explicit
                      basic_string(const _Alloc& __a)
                      : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
                      { }
                
                      // NB: per LWG issue 42, semantics different from IS:
                      /**
                       *  @brief  Construct string with copy of value of @a str.
                       *  @param  __str  Source string.
                       */
                      basic_string(const basic_string& __str)
                      : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
                					    __str.get_allocator()),
                		    __str.get_allocator())
                      { }
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2583. no way to supply an allocator for basic_string(str, pos)
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   const _Alloc& __a = _Alloc());
                
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n);
                      /**
                       *  @brief  Construct string as copy of a substring.
                       *  @param  __str  Source string.
                       *  @param  __pos  Index of first character to copy from.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use.
                       */
                      basic_string(const basic_string& __str, size_type __pos,
                		   size_type __n, const _Alloc& __a);
                
                      /**
                       *  @brief  Construct string initialized by a character %array.
                       *  @param  __s  Source character %array.
                       *  @param  __n  Number of characters to copy.
                       *  @param  __a  Allocator to use (default is default allocator).
                       *
                       *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
                       *  has no special meaning.
                       */
                      basic_string(const _CharT* __s, size_type __n,
                		   const _Alloc& __a = _Alloc())
                      : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
                      { }
                
                      /**
                       *  @brief  Construct string as copy of a C string.
                       *  @param  __s  Source C string.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3076. basic_string CTAD ambiguity
                      template<typename = _RequireAllocator<_Alloc>>
                #endif
                      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
                				 __s + npos, __a), __a)
                      { }
                
                      /**
                       *  @brief  Construct string as multiple characters.
                       *  @param  __n  Number of characters.
                       *  @param  __c  Character to use.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_S_construct(__n, __c, __a), __a)
                      { }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move construct string.
                       *  @param  __str  Source string.
                       *
                       *  The newly-created string contains the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string(basic_string&& __str)
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      noexcept // FIXME C++11: should always be noexcept.
                #endif
                      : _M_dataplus(std::move(__str._M_dataplus))
                      {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	__str._M_data(_S_empty_rep()._M_refdata());
                #else
                	__str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
                #endif
                      }
                
                      /**
                       *  @brief  Construct string from an initializer %list.
                       *  @param  __l  std::initializer_list of characters.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
                      : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
                      { }
                
                      basic_string(const basic_string& __str, const _Alloc& __a)
                      : _M_dataplus(__str._M_rep()->_M_grab(__a, __str.get_allocator()), __a)
                      { }
                
                      basic_string(basic_string&& __str, const _Alloc& __a)
                      : _M_dataplus(__str._M_data(), __a)
                      {
                	if (__a == __str.get_allocator())
                	  {
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                	    __str._M_data(_S_empty_rep()._M_refdata());
                #else
                	    __str._M_data(_S_construct(size_type(), _CharT(), __a));
                #endif
                	  }
                	else
                	  _M_dataplus._M_p = _S_construct(__str.begin(), __str.end(), __a);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Construct string as copy of a range.
                       *  @param  __beg  Start of range.
                       *  @param  __end  End of range.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<class _InputIterator>
                        basic_string(_InputIterator __beg, _InputIterator __end,
                		     const _Alloc& __a = _Alloc())
                	: _M_dataplus(_S_construct(__beg, __end, __a), __a)
                	{ }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Construct string from a substring of a string_view.
                       *  @param  __t   Source object convertible to string view.
                       *  @param  __pos The index of the first character to copy from __t.
                       *  @param  __n   The number of characters to copy from __t.
                       *  @param  __a   Allocator to use.
                       */
                      template<typename _Tp,
                	       typename = enable_if_t<is_convertible_v<const _Tp&, __sv_type>>>
                	basic_string(const _Tp& __t, size_type __pos, size_type __n,
                		     const _Alloc& __a = _Alloc())
                	: basic_string(_S_to_string_view(__t).substr(__pos, __n), __a) { }
                
                      /**
                       *  @brief  Construct string from a string_view.
                       *  @param  __t  Source object convertible to string view.
                       *  @param  __a  Allocator to use (default is default allocator).
                       */
                      template<typename _Tp, typename = _If_sv<_Tp, void>>
                	explicit
                	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
                	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
                #endif // C++17
                
                      /**
                       *  @brief  Destroy the string instance.
                       */
                      ~basic_string() _GLIBCXX_NOEXCEPT
                      { _M_rep()->_M_dispose(this->get_allocator()); }
                
                      /**
                       *  @brief  Assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       */
                      basic_string&
                      operator=(const basic_string& __str)
                      { return this->assign(__str); }
                
                      /**
                       *  @brief  Copy contents of @a s into this string.
                       *  @param  __s  Source null-terminated string.
                       */
                      basic_string&
                      operator=(const _CharT* __s) 
                      { return this->assign(__s); }
                
                      /**
                       *  @brief  Set value to string of length 1.
                       *  @param  __c  Source character.
                       *
                       *  Assigning to a character makes this string length 1 and
                       *  (*this)[0] == @a c.
                       */
                      basic_string&
                      operator=(_CharT __c) 
                      { 
                	this->assign(1, __c); 
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Move assign the value of @a str to this string.
                       *  @param  __str  Source string.
                       *
                       *  The contents of @a str are moved into this string (without copying).
                       *  @a str is a valid, but unspecified string.
                       */
                      basic_string&
                      operator=(basic_string&& __str)
                      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value)
                      {
                	// NB: DR 1204.
                	this->swap(__str);
                	return *this;
                      }
                
                      /**
                       *  @brief  Set value to string constructed from initializer %list.
                       *  @param  __l  std::initializer_list.
                       */
                      basic_string&
                      operator=(initializer_list<_CharT> __l)
                      {
                	this->assign(__l.begin(), __l.size());
                	return *this;
                      }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value to string constructed from a string_view.
                       *  @param  __svt An object convertible to  string_view.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator=(const _Tp& __svt)
                	{ return this->assign(__svt); }
                
                      /**
                       *  @brief  Convert to a string_view.
                       *  @return A string_view.
                       */
                      operator __sv_type() const noexcept
                      { return __sv_type(data(), size()); }
                #endif // C++17
                
                      // Iterators:
                      /**
                       *  Returns a read/write iterator that points to the first character in
                       *  the %string.  Unshares the string.
                       */
                      iterator
                      begin() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      begin() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data()); }
                
                      /**
                       *  Returns a read/write iterator that points one past the last
                       *  character in the %string.  Unshares the string.
                       */
                      iterator
                      end() // FIXME C++11: should be noexcept.
                      {
                	_M_leak();
                	return iterator(_M_data() + this->size());
                      }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      end() const _GLIBCXX_NOEXCEPT
                      { return const_iterator(_M_data() + this->size()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to the last
                       *  character in the %string.  Iteration is done in reverse element
                       *  order.  Unshares the string.
                       */
                      reverse_iterator
                      rbegin() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      rbegin() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read/write reverse iterator that points to one before the
                       *  first character in the %string.  Iteration is done in reverse
                       *  element order.  Unshares the string.
                       */
                      reverse_iterator
                      rend() // FIXME C++11: should be noexcept.
                      { return reverse_iterator(this->begin()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      rend() const _GLIBCXX_NOEXCEPT
                      { return const_reverse_iterator(this->begin()); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read-only (constant) iterator that points to the first
                       *  character in the %string.
                       */
                      const_iterator
                      cbegin() const noexcept
                      { return const_iterator(this->_M_data()); }
                
                      /**
                       *  Returns a read-only (constant) iterator that points one past the
                       *  last character in the %string.
                       */
                      const_iterator
                      cend() const noexcept
                      { return const_iterator(this->_M_data() + this->size()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to the last character in the %string.  Iteration is done in
                       *  reverse element order.
                       */
                      const_reverse_iterator
                      crbegin() const noexcept
                      { return const_reverse_iterator(this->end()); }
                
                      /**
                       *  Returns a read-only (constant) reverse iterator that points
                       *  to one before the first character in the %string.  Iteration
                       *  is done in reverse element order.
                       */
                      const_reverse_iterator
                      crend() const noexcept
                      { return const_reverse_iterator(this->begin()); }
                #endif
                
                    public:
                      // Capacity:
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      size() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the number of characters in the string, not including any
                      ///  null-termination.
                      size_type
                      length() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_length; }
                
                      ///  Returns the size() of the largest possible %string.
                      size_type
                      max_size() const _GLIBCXX_NOEXCEPT
                      { return _Rep::_S_max_size; }
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *  @param  __c  Character to fill any new elements.
                       *
                       *  This function will %resize the %string to the specified
                       *  number of characters.  If the number is smaller than the
                       *  %string's current size the %string is truncated, otherwise
                       *  the %string is extended and new elements are %set to @a __c.
                       */
                      void
                      resize(size_type __n, _CharT __c);
                
                      /**
                       *  @brief  Resizes the %string to the specified number of characters.
                       *  @param  __n  Number of characters the %string should contain.
                       *
                       *  This function will resize the %string to the specified length.  If
                       *  the new size is smaller than the %string's current size the %string
                       *  is truncated, otherwise the %string is extended and new characters
                       *  are default-constructed.  For basic types such as char, this means
                       *  setting them to 0.
                       */
                      void
                      resize(size_type __n)
                      { this->resize(__n, _CharT()); }
                
                #if __cplusplus >= 201103L
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
                      ///  A non-binding request to reduce capacity() to size().
                      void
                      shrink_to_fit() noexcept
                      { reserve(); }
                #pragma GCC diagnostic pop
                #endif
                
                      /**
                       *  Returns the total number of characters that the %string can hold
                       *  before needing to allocate more memory.
                       */
                      size_type
                      capacity() const _GLIBCXX_NOEXCEPT
                      { return _M_rep()->_M_capacity; }
                
                      /**
                       *  @brief  Attempt to preallocate enough memory for specified number of
                       *          characters.
                       *  @param  __res_arg  Number of characters required.
                       *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
                       *
                       *  This function attempts to reserve enough memory for the
                       *  %string to hold the specified number of characters.  If the
                       *  number requested is more than max_size(), length_error is
                       *  thrown.
                       *
                       *  The advantage of this function is that if optimal code is a
                       *  necessity and the user can determine the string length that will be
                       *  required, the user can reserve the memory in %advance, and thus
                       *  prevent a possible reallocation of memory and copying of %string
                       *  data.
                       */
                      void
                      reserve(size_type __res_arg);
                
                      /// Equivalent to shrink_to_fit().
                #if __cplusplus > 201703L
                      [[deprecated("use shrink_to_fit() instead")]]
                #endif
                      void
                      reserve();
                
                      /**
                       *  Erases the string, making it empty.
                       */
                #if _GLIBCXX_FULLY_DYNAMIC_STRING == 0
                      void
                      clear() _GLIBCXX_NOEXCEPT
                      {
                	if (_M_rep()->_M_is_shared())
                	  {
                	    _M_rep()->_M_dispose(this->get_allocator());
                	    _M_data(_S_empty_rep()._M_refdata());
                	  }
                	else
                	  _M_rep()->_M_set_length_and_sharable(0);
                      }
                #else
                      // PR 56166: this should not throw.
                      void
                      clear()
                      { _M_mutate(0, this->size(), 0); }
                #endif
                
                      /**
                       *  Returns true if the %string is empty.  Equivalent to 
                       *  <code>*this == ""</code>.
                       */
                      _GLIBCXX_NODISCARD bool
                      empty() const _GLIBCXX_NOEXCEPT
                      { return this->size() == 0; }
                
                      // Element access:
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read-only (constant) reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)
                       */
                      const_reference
                      operator[] (size_type __pos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_assert(__pos <= size());
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Subscript access to the data contained in the %string.
                       *  @param  __pos  The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *
                       *  This operator allows for easy, array-style, data access.
                       *  Note that data access with this operator is unchecked and
                       *  out_of_range lookups are not defined. (For checked lookups
                       *  see at().)  Unshares the string.
                       */
                      reference
                      operator[](size_type __pos)
                      {
                        // Allow pos == size() both in C++98 mode, as v3 extension,
                	// and in C++11 mode.
                	__glibcxx_assert(__pos <= size());
                        // In pedantic mode be strict in C++98 mode.
                	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
                	_M_leak();
                	return _M_data()[__pos];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read-only (const) reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.
                       */
                      const_reference
                      at(size_type __n) const
                      {
                	if (__n >= this->size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	return _M_data()[__n];
                      }
                
                      /**
                       *  @brief  Provides access to the data contained in the %string.
                       *  @param __n The index of the character to access.
                       *  @return  Read/write reference to the character.
                       *  @throw  std::out_of_range  If @a n is an invalid index.
                       *
                       *  This function provides for safer data access.  The parameter is
                       *  first checked that it is in the range of the string.  The function
                       *  throws out_of_range if the check fails.  Success results in
                       *  unsharing the string.
                       */
                      reference
                      at(size_type __n)
                      {
                	if (__n >= size())
                	  __throw_out_of_range_fmt(__N("basic_string::at: __n "
                				       "(which is %zu) >= this->size() "
                				       "(which is %zu)"),
                				   __n, this->size());
                	_M_leak();
                	return _M_data()[__n];
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  Returns a read/write reference to the data at the first
                       *  element of the %string.
                       */
                      reference
                      front()
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the first
                       *  element of the %string.
                       */
                      const_reference
                      front() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](0);
                      }
                
                      /**
                       *  Returns a read/write reference to the data at the last
                       *  element of the %string.
                       */
                      reference
                      back()
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                
                      /**
                       *  Returns a read-only (constant) reference to the data at the
                       *  last element of the %string.
                       */
                      const_reference
                      back() const noexcept
                      {
                	__glibcxx_assert(!empty());
                	return operator[](this->size() - 1);
                      }
                #endif
                
                      // Modifiers:
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const basic_string& __str)
                      { return this->append(__str); }
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(const _CharT* __s)
                      { return this->append(__s); }
                
                      /**
                       *  @brief  Append a character.
                       *  @param __c  The character to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(_CharT __c)
                      { 
                	this->push_back(__c);
                	return *this;
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to be appended.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      operator+=(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt The object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	operator+=(const _Tp& __svt)
                	{ return this->append(__svt); }
                #endif // C++17
                
                      /**
                       *  @brief  Append a string to this string.
                       *  @param __str  The string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const basic_string& __str);
                
                      /**
                       *  @brief  Append a substring.
                       *  @param __str  The string to append.
                       *  @param __pos  Index of the first character of str to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a __pos is not a valid index.
                       *
                       *  This function appends @a __n characters from @a __str
                       *  starting at @a __pos to this string.  If @a __n is is larger
                       *  than the number of available characters in @a __str, the
                       *  remainder of @a __str is appended.
                       */
                      basic_string&
                      append(const basic_string& __str, size_type __pos, size_type __n = npos);
                
                      /**
                       *  @brief  Append a C substring.
                       *  @param __s  The C string to append.
                       *  @param __n  The number of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Append a C string.
                       *  @param __s  The C string to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->append(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Append multiple characters.
                       *  @param __n  The number of characters to append.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  Appends __n copies of __c to this string.
                       */
                      basic_string&
                      append(size_type __n, _CharT __c);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Append an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to append.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      append(initializer_list<_CharT> __l)
                      { return this->append(__l.begin(), __l.size()); }
                #endif // C++11
                
                      /**
                       *  @brief  Append a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Appends characters in the range [__first,__last) to this string.
                       */
                      template<class _InputIterator>
                        basic_string&
                        append(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Append a string_view.
                       *  @param __svt The object convertible to string_view to be appended.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->append(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Append a range of characters from a string_view.
                       *  @param __svt The object convertible to string_view to be appended
                       *               from.
                       *  @param __pos The position in the string_view to append from.
                       *  @param __n   The number of characters to append from the string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                	append(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return append(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::append"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Append a single character.
                       *  @param __c  Character to append.
                       */
                      void
                      push_back(_CharT __c)
                      { 
                	const size_type __len = 1 + this->size();
                	if (__len > this->capacity() || _M_rep()->_M_is_shared())
                	  this->reserve(__len);
                	traits_type::assign(_M_data()[this->size()], __c);
                	_M_rep()->_M_set_length_and_sharable(__len);
                      }
                
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(const basic_string& __str);
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to contents of another string.
                       *  @param  __str  Source string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets this string to the exact contents of @a __str.
                       *  @a __str is a valid, but unspecified string.
                       */
                      basic_string&
                      assign(basic_string&& __str)
                      noexcept(allocator_traits<_Alloc>::is_always_equal::value)
                      {
                	this->swap(__str);
                	return *this;
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Set value to a substring of a string.
                       *  @param __str  The string to use.
                       *  @param __pos  Index of the first character of str.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range if @a pos is not a valid index.
                       *
                       *  This function sets this string to the substring of @a __str
                       *  consisting of @a __n characters at @a __pos.  If @a __n is
                       *  is larger than the number of available characters in @a
                       *  __str, the remainder of @a __str is used.
                       */
                      basic_string&
                      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
                      { return this->assign(__str._M_data()
                			    + __str._M_check(__pos, "basic_string::assign"),
                			    __str._M_limit(__pos, __n)); }
                
                      /**
                       *  @brief  Set value to a C substring.
                       *  @param __s  The C string to use.
                       *  @param __n  Number of characters to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the first @a __n
                       *  characters of @a __s.  If @a __n is is larger than the number of
                       *  available characters in @a __s, the remainder of @a __s is used.
                       */
                      basic_string&
                      assign(const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Set value to contents of a C string.
                       *  @param __s  The C string to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to the value of @a __s.
                       *  The data is copied, so there is no dependence on @a __s once the
                       *  function returns.
                       */
                      basic_string&
                      assign(const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->assign(__s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Set value to multiple characters.
                       *  @param __n  Length of the resulting string.
                       *  @param __c  The character to use.
                       *  @return  Reference to this string.
                       *
                       *  This function sets the value of this string to @a __n copies of
                       *  character @a __c.
                       */
                      basic_string&
                      assign(size_type __n, _CharT __c)
                      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
                
                      /**
                       *  @brief  Set value to a range of characters.
                       *  @param __first  Iterator referencing the first character to append.
                       *  @param __last  Iterator marking the end of the range.
                       *  @return  Reference to this string.
                       *
                       *  Sets value of string to characters in the range [__first,__last).
                      */
                      template<class _InputIterator>
                        basic_string&
                        assign(_InputIterator __first, _InputIterator __last)
                        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Set value to an initializer_list of characters.
                       *  @param __l  The initializer_list of characters to assign.
                       *  @return  Reference to this string.
                       */
                      basic_string&
                      assign(initializer_list<_CharT> __l)
                      { return this->assign(__l.begin(), __l.size()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Set value from a string_view.
                       *  @param __svt The source object convertible to string_view.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	assign(const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->assign(__sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Set value from a range of characters in a string_view.
                       *  @param __svt  The source object convertible to string_view.
                       *  @param __pos  The position in the string_view to assign from.
                       *  @param __n  The number of characters to assign.
                       *  @return  Reference to this string.
                       */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        assign(const _Tp& __svt, size_type __pos, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return assign(__sv.data()
                	      + std::__sv_check(__sv.size(), __pos, "basic_string::assign"),
                	      std::__sv_limit(__sv.size(), __pos, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts @a __n copies of character @a __c starting at the
                       *  position referenced by iterator @a __p.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      void
                      insert(iterator __p, size_type __n, _CharT __c)
                      {	this->replace(__p, __p, __n, __c);  }
                
                      /**
                       *  @brief  Insert a range of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __beg  Start of range.
                       *  @param __end  End of range.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts characters in range [__beg,__end).  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      template<class _InputIterator>
                        void
                        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
                        { this->replace(__p, __p, __beg, __end); }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Insert an initializer_list of characters.
                       *  @param __p  Iterator referencing location in string to insert at.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       */
                      void
                      insert(iterator __p, initializer_list<_CharT> __l)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Insert value of a string.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __str  The string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts value of @a __str starting at @a __pos1.  If adding
                       *  characters causes the length to exceed max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str)
                      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
                
                      /**
                       *  @brief  Insert a substring.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __str  The string to insert.
                       *  @param __pos2  Start of characters in str to insert.
                       *  @param __n  Number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos1 > size() or
                       *  @a __pos2 > @a str.size().
                       *
                       *  Starting at @a pos1, insert @a __n character of @a __str
                       *  beginning with @a __pos2.  If adding characters causes the
                       *  length to exceed max_size(), length_error is thrown.  If @a
                       *  __pos1 is beyond the end of this string or @a __pos2 is
                       *  beyond the end of @a __str, out_of_range is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos1, const basic_string& __str,
                	     size_type __pos2, size_type __n = npos)
                      { return this->insert(__pos1, __str._M_data()
                			    + __str._M_check(__pos2, "basic_string::insert"),
                			    __str._M_limit(__pos2, __n)); }
                
                      /**
                       *  @brief  Insert a C substring.
                       *  @param __pos  Position in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @param __n  The number of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a __n characters of @a __s starting at @a
                       *  __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos is beyond
                       *  end(), out_of_range is thrown.  The value of the string
                       *  doesn't change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s, size_type __n);
                
                      /**
                       *  @brief  Insert a C string.
                       *  @param __pos  Position in string to insert at.
                       *  @param __s  The C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts the first @a n characters of @a __s starting at @a __pos.  If
                       *  adding characters causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __pos is beyond end(), out_of_range is
                       *  thrown.  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      insert(size_type __pos, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->insert(__pos, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Insert multiple characters.
                       *  @param __pos  Index in string to insert at.
                       *  @param __n  Number of characters to insert
                       *  @param __c  The character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *  @throw  std::out_of_range  If @a __pos is beyond the end of this
                       *  string.
                       *
                       *  Inserts @a __n copies of character @a __c starting at index
                       *  @a __pos.  If adding characters causes the length to exceed
                       *  max_size(), length_error is thrown.  If @a __pos > length(),
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      insert(size_type __pos, size_type __n, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
                			      size_type(0), __n, __c); }
                
                      /**
                       *  @brief  Insert one character.
                       *  @param __p  Iterator referencing position in string to insert at.
                       *  @param __c  The character to insert.
                       *  @return  Iterator referencing newly inserted char.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Inserts character @a __c at position referenced by @a __p.
                       *  If adding character causes the length to exceed max_size(),
                       *  length_error is thrown.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      iterator
                      insert(iterator __p, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());
                	const size_type __pos = __p - _M_ibegin();
                	_M_replace_aux(__pos, size_type(0), size_type(1), __c);
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos  Position in string to insert at.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	insert(size_type __pos, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->insert(__pos, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Insert a string_view.
                       *  @param __pos1  Position in string to insert at.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  Position in string_view to insert from.
                       *  @param __n    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        insert(size_type __pos1, const _Tp& __svt,
                	       size_type __pos2, size_type __n = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, size_type(0), __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::insert"),
                	      std::__sv_limit(__sv.size(), __pos2, __n));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Remove characters.
                       *  @param __pos  Index of first character to remove (default 0).
                       *  @param __n  Number of characters to remove (default remainder).
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *
                       *  Removes @a __n characters from this string starting at @a
                       *  __pos.  The length of the string is reduced by @a __n.  If
                       *  there are < @a __n characters to remove, the remainder of
                       *  the string is truncated.  If @a __p is beyond end of string,
                       *  out_of_range is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      erase(size_type __pos = 0, size_type __n = npos)
                      { 
                	_M_mutate(_M_check(__pos, "basic_string::erase"),
                		  _M_limit(__pos, __n), size_type(0));
                	return *this;
                      }
                
                      /**
                       *  @brief  Remove one character.
                       *  @param __position  Iterator referencing the character to remove.
                       *  @return  iterator referencing same location after removal.
                       *
                       *  Removes the character at @a __position from this string. The value
                       *  of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __position)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin()
                				 && __position < _M_iend());
                	const size_type __pos = __position - _M_ibegin();
                	_M_mutate(__pos, size_type(1), size_type(0));
                	_M_rep()->_M_set_leaked();
                	return iterator(_M_data() + __pos);
                      }
                
                      /**
                       *  @brief  Remove a range of characters.
                       *  @param __first  Iterator referencing the first character to remove.
                       *  @param __last  Iterator referencing the end of the range.
                       *  @return  Iterator referencing location of first after removal.
                       *
                       *  Removes the characters in the range [first,last) from this string.
                       *  The value of the string doesn't change if an error is thrown.
                      */
                      iterator
                      erase(iterator __first, iterator __last);
                 
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Remove the last character.
                       *
                       *  The string must be non-empty.
                       */
                      void
                      pop_back() // FIXME C++11: should be noexcept.
                      {
                	__glibcxx_assert(!empty());
                	erase(size() - 1, 1);
                      }
                #endif // C++11
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos is beyond the end of this
                       *  string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos+__n) from
                       *  this string.  In place, the value of @a __str is inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of the result exceeds max_size(), length_error
                       *  is thrown.  The value of the string doesn't change if an
                       *  error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n, const basic_string& __str)
                      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace characters with value from another string.
                       *  @param __pos1  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __str  String to insert.
                       *  @param __pos2  Index of first character of str to use.
                       *  @param __n2  Number of characters from str to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos1 > size() or @a __pos2 >
                       *  __str.size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos1,__pos1 + n) from this
                       *  string.  In place, the value of @a __str is inserted.  If @a __pos is
                       *  beyond end of string, out_of_range is thrown.  If the length of the
                       *  result exceeds max_size(), length_error is thrown.  The value of the
                       *  string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos)
                      { return this->replace(__pos1, __n1, __str._M_data()
                			     + __str._M_check(__pos2, "basic_string::replace"),
                			     __str._M_limit(__pos2, __n2)); }
                
                      /**
                       *  @brief  Replace characters with value of a C substring.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @param __n2  Number of characters from @a s to use.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos1 > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the first @a __n2 characters of
                       *  @a __s are inserted, or all of @a __s if @a __n2 is too large.  If
                       *  @a __pos is beyond end of string, out_of_range is thrown.  If
                       *  the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2);
                
                      /**
                       *  @brief  Replace characters with value of a C string.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __s  C string to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__pos,__pos + __n1)
                       *  from this string.  In place, the characters of @a __s are
                       *  inserted.  If @a __pos is beyond end of string, out_of_range
                       *  is thrown.  If the length of result exceeds max_size(),
                       *  length_error is thrown.  The value of the string doesn't
                       *  change if an error is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__pos, __n1, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace characters with multiple characters.
                       *  @param __pos  Index of first character to replace.
                       *  @param __n1  Number of characters to be replaced.
                       *  @param __n2  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::out_of_range  If @a __pos > size().
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [pos,pos + n1) from this
                       *  string.  In place, @a __n2 copies of @a __c are inserted.
                       *  If @a __pos is beyond end of string, out_of_range is thrown.
                       *  If the length of result exceeds max_size(), length_error is
                       *  thrown.  The value of the string doesn't change if an error
                       *  is thrown.
                      */
                      basic_string&
                      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
                      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
                			      _M_limit(__pos, __n1), __n2, __c); }
                
                      /**
                       *  @brief  Replace range of characters with string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __str  String value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the value of @a __str is inserted.  If the length of result
                       *  exceeds max_size(), length_error is thrown.  The value of
                       *  the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const basic_string& __str)
                      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
                
                      /**
                       *  @brief  Replace range of characters with C substring.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @param __n  Number of characters from s to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the first @a __n characters of @a __s are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
                      }
                
                      /**
                       *  @brief  Replace range of characters with C string.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __s  C string value to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  the characters of @a __s are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, const _CharT* __s)
                      {
                	__glibcxx_requires_string(__s);
                	return this->replace(__i1, __i2, __s, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Replace range of characters with multiple characters
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __n  Number of characters to insert.
                       *  @param __c  Character to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  @a __n copies of @a __c are inserted.  If the length of
                       *  result exceeds max_size(), length_error is thrown.  The
                       *  value of the string doesn't change if an error is thrown.
                      */
                      basic_string&
                      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
                      }
                
                      /**
                       *  @brief  Replace range of characters with range.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __k1  Iterator referencing start of range to insert.
                       *  @param __k2  Iterator referencing end of range to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      template<class _InputIterator>
                        basic_string&
                        replace(iterator __i1, iterator __i2,
                		_InputIterator __k1, _InputIterator __k2)
                        {
                	  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				   && __i2 <= _M_iend());
                	  __glibcxx_requires_valid_range(__k1, __k2);
                	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
                	  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
                	}
                
                      // Specializations for the common case of pointer and iterator:
                      // useful to avoid the overhead of temporary buffering in _M_replace.
                      basic_string&
                      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const _CharT* __k1, const _CharT* __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1, __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                      basic_string&
                      replace(iterator __i1, iterator __i2,
                	      const_iterator __k1, const_iterator __k2)
                      {
                	_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2
                				 && __i2 <= _M_iend());
                	__glibcxx_requires_valid_range(__k1, __k2);
                	return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
                			     __k1.base(), __k2 - __k1);
                      }
                
                #if __cplusplus >= 201103L
                      /**
                       *  @brief  Replace range of characters with initializer_list.
                       *  @param __i1  Iterator referencing start of range to replace.
                       *  @param __i2  Iterator referencing end of range to replace.
                       *  @param __l  The initializer_list of characters to insert.
                       *  @return  Reference to this string.
                       *  @throw  std::length_error  If new length exceeds @c max_size().
                       *
                       *  Removes the characters in the range [__i1,__i2).  In place,
                       *  characters in the range [__k1,__k2) are inserted.  If the
                       *  length of result exceeds max_size(), length_error is thrown.
                       *  The value of the string doesn't change if an error is
                       *  thrown.
                      */
                      basic_string& replace(iterator __i1, iterator __i2,
                			    initializer_list<_CharT> __l)
                      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
                #endif // C++11
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos  The position to replace at.
                       *  @param __n    The number of characters to replace.
                       *  @param __svt  The object convertible to string_view to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(size_type __pos, size_type __n, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos, __n, __sv.data(), __sv.size());
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __pos1  The position to replace at.
                       *  @param __n1    The number of characters to replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @param __pos2  The position in the string_view to insert from.
                       *  @param __n2    The number of characters to insert.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                        _If_sv<_Tp, basic_string&>
                        replace(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__pos1, __n1,
                	      __sv.data()
                	      + std::__sv_check(__sv.size(), __pos2, "basic_string::replace"),
                	      std::__sv_limit(__sv.size(), __pos2, __n2));
                	}
                
                      /**
                       *  @brief  Replace range of characters with string_view.
                       *  @param __i1    An iterator referencing the start position
                          to replace at.
                       *  @param __i2    An iterator referencing the end position
                          for the replace.
                       *  @param __svt   The object convertible to string_view to insert from.
                       *  @return  Reference to this string.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, basic_string&>
                	replace(const_iterator __i1, const_iterator __i2, const _Tp& __svt)
                	{
                	  __sv_type __sv = __svt;
                	  return this->replace(__i1 - begin(), __i2 - __i1, __sv);
                	}
                #endif // C++17
                
                    private:
                      template<class _Integer>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
                			    _Integer __val, __true_type)
                        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
                
                      template<class _InputIterator>
                	basic_string&
                	_M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
                			    _InputIterator __k2, __false_type);
                
                      basic_string&
                      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
                		     _CharT __c);
                
                      basic_string&
                      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
                		      size_type __n2);
                
                      // _S_construct_aux is used to implement the 21.3.1 para 15 which
                      // requires special behaviour if _InIter is an integral type
                      template<class _InIterator>
                        static _CharT*
                        _S_construct_aux(_InIterator __beg, _InIterator __end,
                			 const _Alloc& __a, __false_type)
                	{
                          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
                          return _S_construct(__beg, __end, __a, _Tag());
                	}
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 438. Ambiguity in the "do the right thing" clause
                      template<class _Integer>
                        static _CharT*
                        _S_construct_aux(_Integer __beg, _Integer __end,
                			 const _Alloc& __a, __true_type)
                        { return _S_construct_aux_2(static_cast<size_type>(__beg),
                				    __end, __a); }
                
                      static _CharT*
                      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
                      { return _S_construct(__req, __c, __a); }
                
                      template<class _InIterator>
                        static _CharT*
                        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
                	{
                	  typedef typename std::__is_integer<_InIterator>::__type _Integral;
                	  return _S_construct_aux(__beg, __end, __a, _Integral());
                        }
                
                      // For Input Iterators, used in istreambuf_iterators, etc.
                      template<class _InIterator>
                        static _CharT*
                         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
                		      input_iterator_tag);
                
                      // For forward_iterators up to random_access_iterators, used for
                      // string::iterator, _CharT*, etc.
                      template<class _FwdIterator>
                        static _CharT*
                        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
                		     forward_iterator_tag);
                
                      static _CharT*
                      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
                
                    public:
                
                      /**
                       *  @brief  Copy substring into C string.
                       *  @param __s  C string to copy value into.
                       *  @param __n  Number of characters to copy.
                       *  @param __pos  Index of first character to copy.
                       *  @return  Number of characters actually copied
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Copies up to @a __n characters starting at @a __pos into the
                       *  C string @a __s.  If @a __pos is %greater than size(),
                       *  out_of_range is thrown.
                      */
                      size_type
                      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
                
                      /**
                       *  @brief  Swap contents with another string.
                       *  @param __s  String to swap with.
                       *
                       *  Exchanges the contents of this string with that of @a __s in constant
                       *  time.
                      */
                      void
                      swap(basic_string& __s)
                      _GLIBCXX_NOEXCEPT_IF(allocator_traits<_Alloc>::is_always_equal::value);
                
                      // String operations:
                      /**
                       *  @brief  Return const pointer to null-terminated contents.
                       *
                       *  This is a handle to internal data.  Do not modify or dire things may
                       *  happen.
                      */
                      const _CharT*
                      c_str() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                      /**
                       *  @brief  Return const pointer to contents.
                       *
                       *  This is a pointer to internal data.  It is undefined to modify
                       *  the contents through the returned pointer. To get a pointer that
                       *  allows modifying the contents use @c &str[0] instead,
                       *  (or in C++17 the non-const @c str.data() overload).
                      */
                      const _CharT*
                      data() const _GLIBCXX_NOEXCEPT
                      { return _M_data(); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Return non-const pointer to contents.
                       *
                       *  This is a pointer to the character sequence held by the string.
                       *  Modifying the characters in the sequence is allowed.
                      */
                      _CharT*
                      data() noexcept
                      {
                	_M_leak();
                	return _M_data();
                      }
                #endif
                
                      /**
                       *  @brief  Return copy of allocator used to construct this string.
                      */
                      allocator_type
                      get_allocator() const _GLIBCXX_NOEXCEPT
                      { return _M_dataplus; }
                
                      /**
                       *  @brief  Find position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from @a s to search for.
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for value of @a __str within
                       *  this string.  If found, returns the index where it begins.  If not
                       *  found, returns npos.
                      */
                      size_type
                      find(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the value of @a
                       *  __s within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      find(const _CharT* __s, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of start of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a string.
                       *  @param __str  String to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for value of @a
                       *  __str within this string.  If found, returns the index where
                       *  it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->rfind(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a C substring.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of start of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the first @a
                       *  __n characters in @a __s within this string.  If found,
                       *  returns the index where it begins.  If not found, returns
                       *  npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a C string.
                       *  @param __s  C string to locate.
                       *  @param __pos  Index of character to start search at (default end).
                       *  @return  Index of start of  last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for the value of
                       *  @a __s within this string.  If found, returns the index
                       *  where it begins.  If not found, returns npos.
                      */
                      size_type
                      rfind(const _CharT* __s, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->rfind(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      rfind(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a string_view.
                       *  @param __svt  The object convertible to string_view to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of start of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	rfind(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->rfind(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_first_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character of C substring.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character of C string.
                       *  @param __s  String containing characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for the character
                       *  @a __c within this string.  If found, returns the index
                       *  where it was found.  If not found, returns npos.
                       *
                       *  Note: equivalent to find(__c, __pos).
                      */
                      size_type
                      find_first_of(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT
                      { return this->find(__c, __pos); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character of a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __str  String containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character of C substring.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to search for.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  first @a __n characters of @a __s within this string.  If
                       *  found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
                      _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find last position of a character of C string.
                       *  @param __s  C string containing characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for one of the
                       *  characters of @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_last_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a character.
                       *  @param __c  Character to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for @a __c within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                       *
                       *  Note: equivalent to rfind(__c, __pos).
                      */
                      size_type
                      find_last_of(_CharT __c, size_type __pos = npos) const _GLIBCXX_NOEXCEPT
                      { return this->rfind(__c, __pos); }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character of string.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to locate.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                      */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not contained
                       *  in @a __str within this string.  If found, returns the index where it
                       *  was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from.
                       *  @param __n  Number of characters from __s to consider.
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in the first @a __n characters of @a __s within
                       *  this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos,
                			size_type __n) const _GLIBCXX_NOEXCEPT;
                
                      /**
                       *  @brief  Find position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character not
                       *  contained in @a __s within this string.  If found, returns
                       *  the index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_first_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       *
                       *  Starting from @a __pos, searches forward for a character
                       *  other than @a __c within this string.  If found, returns the
                       *  index where it was found.  If not found, returns npos.
                      */
                      size_type
                      find_first_not_of(_CharT __c, size_type __pos = 0) const
                      _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search from (default 0).
                       *  @return  Index of first occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_first_not_of(const _Tp& __svt, size_type __pos = 0) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_first_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Find last position of a character not in string.
                       *  @param __str  String containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __str within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
                
                      /**
                       *  @brief  Find last position of a character not in C substring.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from.
                       *  @param __n  Number of characters from s to consider.
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character not
                       *  contained in the first @a __n characters of @a __s within this string.
                       *  If found, returns the index where it was found.  If not found,
                       *  returns npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos,
                		       size_type __n) const _GLIBCXX_NOEXCEPT;
                      /**
                       *  @brief  Find last position of a character not in C string.
                       *  @param __s  C string containing characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character
                       *  not contained in @a __s within this string.  If found,
                       *  returns the index where it was found.  If not found, returns
                       *  npos.
                      */
                      size_type
                      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT
                      {
                	__glibcxx_requires_string(__s);
                	return this->find_last_not_of(__s, __pos, traits_type::length(__s));
                      }
                
                      /**
                       *  @brief  Find last position of a different character.
                       *  @param __c  Character to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       *
                       *  Starting from @a __pos, searches backward for a character other than
                       *  @a __c within this string.  If found, returns the index where it was
                       *  found.  If not found, returns npos.
                      */
                      size_type
                      find_last_not_of(_CharT __c, size_type __pos = npos) const
                      _GLIBCXX_NOEXCEPT;
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Find last position of a character not in a string_view.
                       *  @param __svt  An object convertible to string_view containing
                       *                characters to avoid.
                       *  @param __pos  Index of character to search back from (default end).
                       *  @return  Index of last occurrence.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, size_type>
                	find_last_not_of(const _Tp& __svt, size_type __pos = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return this->find_last_not_of(__sv.data(), __pos, __sv.size());
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Get a substring.
                       *  @param __pos  Index of first character (default 0).
                       *  @param __n  Number of characters in substring (default remainder).
                       *  @return  The new string.
                       *  @throw  std::out_of_range  If __pos > size().
                       *
                       *  Construct and return a new string using the @a __n
                       *  characters starting at @a __pos.  If the string is too
                       *  short, use the remainder of the characters.  If @a __pos is
                       *  beyond the end of the string, out_of_range is thrown.
                      */
                      basic_string
                      substr(size_type __pos = 0, size_type __n = npos) const
                      { return basic_string(*this,
                			    _M_check(__pos, "basic_string::substr"), __n); }
                
                      /**
                       *  @brief  Compare to a string.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a
                       *  __str, 0 if their values are equivalent, or > 0 if this
                       *  string is ordered after @a __str.  Determines the effective
                       *  length rlen of the strings to compare as the smallest of
                       *  size() and str.size().  The function then compares the two
                       *  strings by calling traits::compare(data(), str.data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(const basic_string& __str) const
                      {
                	const size_type __size = this->size();
                	const size_type __osize = __str.size();
                	const size_type __len = std::min(__size, __osize);
                
                	int __r = traits_type::compare(_M_data(), __str.data(), __len);
                	if (!__r)
                	  __r = _S_compare(__size, __osize);
                	return __r;
                      }
                
                #if __cplusplus >= 201703L
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __svt An object convertible to string_view to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	   __sv_type __sv = __svt;
                	  const size_type __size = this->size();
                	  const size_type __osize = __sv.size();
                	  const size_type __len = std::min(__size, __osize);
                
                	  int __r = traits_type::compare(_M_data(), __sv.data(), __len);
                	  if (!__r)
                	    __r = _S_compare(__size, __osize);
                	  return __r;
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos  A position in the string to start comparing from.
                       *  @param __n  The number of characters to compare.
                       *  @param __svt  An object convertible to string_view to compare
                       *                against.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos, size_type __n, const _Tp& __svt) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this).substr(__pos, __n).compare(__sv);
                	}
                
                      /**
                       *  @brief  Compare to a string_view.
                       *  @param __pos1  A position in the string to start comparing from.
                       *  @param __n1  The number of characters to compare.
                       *  @param __svt   An object convertible to string_view to compare
                       *                 against.
                       *  @param __pos2  A position in the string_view to start comparing from.
                       *  @param __n2  The number of characters to compare.
                       *  @return  Integer < 0, 0, or > 0.
                       */
                      template<typename _Tp>
                	_If_sv<_Tp, int>
                	compare(size_type __pos1, size_type __n1, const _Tp& __svt,
                		size_type __pos2, size_type __n2 = npos) const
                	noexcept(is_same<_Tp, __sv_type>::value)
                	{
                	  __sv_type __sv = __svt;
                	  return __sv_type(*this)
                	    .substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
                	}
                #endif // C++17
                
                      /**
                       *  @brief  Compare substring to a string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n characters
                       *  starting at @a __pos.  Returns an integer < 0 if the
                       *  substring is ordered before @a __str, 0 if their values are
                       *  equivalent, or > 0 if the substring is ordered after @a
                       *  __str.  Determines the effective length rlen of the strings
                       *  to compare as the smallest of the length of the substring
                       *  and @a __str.size().  The function then compares the two
                       *  strings by calling
                       *  traits::compare(substring.data(),str.data(),rlen).  If the
                       *  result of the comparison is nonzero returns it, otherwise
                       *  the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n, const basic_string& __str) const;
                
                      /**
                       *  @brief  Compare substring to a substring.
                       *  @param __pos1  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __str  String to compare against.
                       *  @param __pos2  Index of first character of substring of str.
                       *  @param __n2  Number of characters in substring of str.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos1.  Form the substring of @a
                       *  __str from the @a __n2 characters starting at @a __pos2.
                       *  Returns an integer < 0 if this substring is ordered before
                       *  the substring of @a __str, 0 if their values are equivalent,
                       *  or > 0 if this substring is ordered after the substring of
                       *  @a __str.  Determines the effective length rlen of the
                       *  strings to compare as the smallest of the lengths of the
                       *  substrings.  The function then compares the two strings by
                       *  calling
                       *  traits::compare(substring.data(),str.substr(pos2,n2).data(),rlen).
                       *  If the result of the comparison is nonzero returns it,
                       *  otherwise the shorter one is ordered first.
                      */
                      int
                      compare(size_type __pos1, size_type __n1, const basic_string& __str,
                	      size_type __pos2, size_type __n2 = npos) const;
                
                      /**
                       *  @brief  Compare to a C string.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Returns an integer < 0 if this string is ordered before @a __s, 0 if
                       *  their values are equivalent, or > 0 if this string is ordered after
                       *  @a __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of size() and the length of a string
                       *  constructed from @a __s.  The function then compares the two strings
                       *  by calling traits::compare(data(),s,rlen).  If the result of the
                       *  comparison is nonzero returns it, otherwise the shorter one is
                       *  ordered first.
                      */
                      int
                      compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT;
                
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 5 String::compare specification questionable
                      /**
                       *  @brief  Compare substring to a C string.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  C string to compare against.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a pos.  Returns an integer < 0 if
                       *  the substring is ordered before @a __s, 0 if their values
                       *  are equivalent, or > 0 if the substring is ordered after @a
                       *  __s.  Determines the effective length rlen of the strings to
                       *  compare as the smallest of the length of the substring and
                       *  the length of a string constructed from @a __s.  The
                       *  function then compares the two string by calling
                       *  traits::compare(substring.data(),__s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
                
                      /**
                       *  @brief  Compare substring against a character %array.
                       *  @param __pos  Index of first character of substring.
                       *  @param __n1  Number of characters in substring.
                       *  @param __s  character %array to compare against.
                       *  @param __n2  Number of characters of s.
                       *  @return  Integer < 0, 0, or > 0.
                       *
                       *  Form the substring of this string from the @a __n1
                       *  characters starting at @a __pos.  Form a string from the
                       *  first @a __n2 characters of @a __s.  Returns an integer < 0
                       *  if this substring is ordered before the string from @a __s,
                       *  0 if their values are equivalent, or > 0 if this substring
                       *  is ordered after the string from @a __s.  Determines the
                       *  effective length rlen of the strings to compare as the
                       *  smallest of the length of the substring and @a __n2.  The
                       *  function then compares the two strings by calling
                       *  traits::compare(substring.data(),s,rlen).  If the result of
                       *  the comparison is nonzero returns it, otherwise the shorter
                       *  one is ordered first.
                       *
                       *  NB: s must have at least n2 characters, &apos;\\0&apos; has
                       *  no special meaning.
                      */
                      int
                      compare(size_type __pos, size_type __n1, const _CharT* __s,
                	      size_type __n2) const;
                
                #if __cplusplus > 201703L
                      bool
                      starts_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      starts_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).starts_with(__x); }
                
                      bool
                      ends_with(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                
                      bool
                      ends_with(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).ends_with(__x); }
                #endif // C++20
                
                #if __cplusplus > 202011L
                      bool
                      contains(basic_string_view<_CharT, _Traits> __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                
                      bool
                      contains(_CharT __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                
                      bool
                      contains(const _CharT* __x) const noexcept
                      { return __sv_type(this->data(), this->size()).contains(__x); }
                #endif // C++23
                
                # ifdef _GLIBCXX_TM_TS_INTERNAL
                      friend void
                      ::_txnal_cow_string_C1_for_exceptions(void* that, const char* s,
                					    void* exc);
                      friend const char*
                      ::_txnal_cow_string_c_str(const void *that);
                      friend void
                      ::_txnal_cow_string_D1(void *that);
                      friend void
                      ::_txnal_cow_string_D1_commit(void *that);
                # endif
                  };
                #endif  // !_GLIBCXX_USE_CXX11_ABI
                
                #if __cpp_deduction_guides >= 201606
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                  template<typename _InputIterator, typename _CharT
                	     = typename iterator_traits<_InputIterator>::value_type,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireInputIter<_InputIterator>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(_InputIterator, _InputIterator, _Allocator = _Allocator())
                      -> basic_string<_CharT, char_traits<_CharT>, _Allocator>;
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 3075. basic_string needs deduction guides from basic_string_view
                  template<typename _CharT, typename _Traits,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(basic_string_view<_CharT, _Traits>, const _Allocator& = _Allocator())
                      -> basic_string<_CharT, _Traits, _Allocator>;
                
                  template<typename _CharT, typename _Traits,
                	   typename _Allocator = allocator<_CharT>,
                	   typename = _RequireAllocator<_Allocator>>
                    basic_string(basic_string_view<_CharT, _Traits>,
                		 typename basic_string<_CharT, _Traits, _Allocator>::size_type,
                		 typename basic_string<_CharT, _Traits, _Allocator>::size_type,
                		 const _Allocator& = _Allocator())
                      -> basic_string<_CharT, _Traits, _Allocator>;
                _GLIBCXX_END_NAMESPACE_CXX11
                #endif
                
                  // operator+
                  /**
                   *  @brief  Concatenate two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate C string and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with value of @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(const _CharT* __lhs,
                	      const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate character and string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_string<_CharT,_Traits,_Alloc>
                    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
                
                  /**
                   *  @brief  Concatenate string and C string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    {
                      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
                      __str.append(__rhs);
                      return __str;
                    }
                
                  /**
                   *  @brief  Concatenate string and character.
                   *  @param __lhs  First string.
                   *  @param __rhs  Last string.
                   *  @return  New string with @a __lhs followed by @a __rhs.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
                    {
                      typedef basic_string<_CharT, _Traits, _Alloc>	__string_type;
                      typedef typename __string_type::size_type		__size_type;
                      __string_type __str(__lhs);
                      __str.append(__size_type(1), __rhs);
                      return __str;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    {
                #if _GLIBCXX_USE_CXX11_ABI
                      using _Alloc_traits = allocator_traits<_Alloc>;
                      bool __use_rhs = false;
                      if _GLIBCXX17_CONSTEXPR (typename _Alloc_traits::is_always_equal{})
                	__use_rhs = true;
                      else if (__lhs.get_allocator() == __rhs.get_allocator())
                	__use_rhs = true;
                      if (__use_rhs)
                #endif
                	{
                	  const auto __size = __lhs.size() + __rhs.size();
                	  if (__size > __lhs.capacity() && __size <= __rhs.capacity())
                	    return std::move(__rhs.insert(0, __lhs));
                	}
                      return std::move(__lhs.append(__rhs));
                    }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
         956 ->     operator+(const _CharT* __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(_CharT __lhs,
                	      basic_string<_CharT, _Traits, _Alloc>&& __rhs)
                    { return std::move(__rhs.insert(0, 1, __lhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
         160 ->     operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      const _CharT* __rhs)
                    { return std::move(__lhs.append(__rhs)); }
                
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_string<_CharT, _Traits, _Alloc>
                    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
                	      _CharT __rhs)
                    { return std::move(__lhs.append(1, __rhs)); }
                #endif
                
                  // operator ==
                  /**
                   *  @brief  Test equivalence of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) == 0; }
                
                  template<typename _CharT>
                    inline
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
                    operator==(const basic_string<_CharT>& __lhs,
                	       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT
                    { return (__lhs.size() == __rhs.size()
                	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
                						    __lhs.size())); }
                
                  /**
                   *  @brief  Test equivalence of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) == 0; }
                
                #if __cpp_lib_three_way_comparison
                  /**
                   *  @brief  Three-way comparison of a string and a C string.
                   *  @param __lhs  A string.
                   *  @param __rhs  A null-terminated string.
                   *  @return  A value indicating whether `__lhs` is less than, equal to,
                   *	       greater than, or incomparable with `__rhs`.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                		const basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept
                    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
                    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
                
                  /**
                   *  @brief  Three-way comparison of a string and a C string.
                   *  @param __lhs  A string.
                   *  @param __rhs  A null-terminated string.
                   *  @return  A value indicating whether `__lhs` is less than, equal to,
                   *	       greater than, or incomparable with `__rhs`.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline auto
                    operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                		const _CharT* __rhs) noexcept
                    -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
                    { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
                #else
                  /**
                   *  @brief  Test equivalence of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) == 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator==(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) == 0; }
                
                  // operator !=
                  /**
                   *  @brief  Test difference of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of C string and string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __rhs.compare(@a __lhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return !(__lhs == __rhs); }
                
                  /**
                   *  @brief  Test difference of string and C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs.compare(@a __rhs) != 0.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return !(__lhs == __rhs); }
                
                  // operator <
                  /**
                   *  @brief  Test if string precedes string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if string precedes C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) < 0; }
                
                  /**
                   *  @brief  Test if C string precedes string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs precedes @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) > 0; }
                
                  // operator >
                  /**
                   *  @brief  Test if string follows string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if string follows C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	      const _CharT* __rhs)
                    { return __lhs.compare(__rhs) > 0; }
                
                  /**
                   *  @brief  Test if C string follows string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs follows @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>(const _CharT* __lhs,
                	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) < 0; }
                
                  // operator <=
                  /**
                   *  @brief  Test if string doesn't follow string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if string doesn't follow C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) <= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't follow string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't follow @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator<=(const _CharT* __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) >= 0; }
                
                  // operator >=
                  /**
                   *  @brief  Test if string doesn't precede string.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if string doesn't precede C string.
                   *  @param __lhs  String.
                   *  @param __rhs  C string.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	       const _CharT* __rhs)
                    { return __lhs.compare(__rhs) >= 0; }
                
                  /**
                   *  @brief  Test if C string doesn't precede string.
                   *  @param __lhs  C string.
                   *  @param __rhs  String.
                   *  @return  True if @a __lhs doesn't precede @a __rhs.  False otherwise.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline bool
                    operator>=(const _CharT* __lhs,
                	     const basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    { return __rhs.compare(__lhs) <= 0; }
                #endif // three-way comparison
                
                  /**
                   *  @brief  Swap contents of two strings.
                   *  @param __lhs  First string.
                   *  @param __rhs  Second string.
                   *
                   *  Exchanges the contents of @a __lhs and @a __rhs in constant time.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline void
                    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
                	 basic_string<_CharT, _Traits, _Alloc>& __rhs)
                    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))
                    { __lhs.swap(__rhs); }
                
                
                  /**
                   *  @brief  Read stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until whitespace is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  If is.width() is non-zero, that is the limit on the
                   *  number of characters stored into @a __str.  Any previous
                   *  contents of @a __str are erased.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    operator>>(basic_istream<_CharT, _Traits>& __is,
                	       basic_string<_CharT, _Traits, _Alloc>& __str);
                
                  template<>
                    basic_istream<char>&
                    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
                
                  /**
                   *  @brief  Write string to a stream.
                   *  @param __os  Output stream.
                   *  @param __str  String to write out.
                   *  @return  Reference to the output stream.
                   *
                   *  Output characters of @a __str into os following the same rules as for
                   *  writing a C string.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_ostream<_CharT, _Traits>&
                    operator<<(basic_ostream<_CharT, _Traits>& __os,
                	       const basic_string<_CharT, _Traits, _Alloc>& __str)
                    {
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 586. string inserter not a formatted function
                      return __ostream_insert(__os, __str.data(), __str.size());
                    }
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @param __delim  Character marking end of line.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from @a __is into @a __str until @a __delim is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  @a __delim is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
                
                  /**
                   *  @brief  Read a line from stream into a string.
                   *  @param __is  Input stream.
                   *  @param __str  Buffer to store into.
                   *  @return  Reference to the input stream.
                   *
                   *  Stores characters from is into @a __str until &apos;\n&apos; is
                   *  found, the end of the stream is encountered, or str.max_size()
                   *  is reached.  Any previous contents of @a __str are erased.  If
                   *  end of line is encountered, it is extracted but not stored into
                   *  @a __str.
                   */
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str, __is.widen('\n')); }
                
                #if __cplusplus >= 201103L
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
                    { return std::getline(__is, __str, __delim); }
                
                  /// Read a line from an rvalue stream into a string.
                  template<typename _CharT, typename _Traits, typename _Alloc>
                    inline basic_istream<_CharT, _Traits>&
                    getline(basic_istream<_CharT, _Traits>&& __is,
                	    basic_string<_CharT, _Traits, _Alloc>& __str)
                    { return std::getline(__is, __str); }
                #endif
                
                  template<>
                    basic_istream<char>&
                    getline(basic_istream<char>& __in, basic_string<char>& __str,
                	    char __delim);
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  template<>
                    basic_istream<wchar_t>&
                    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
                	    wchar_t __delim);
                #endif  
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #if __cplusplus >= 201103L
                
                #include <ext/string_conversions.h>
                #include <bits/charconv.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                _GLIBCXX_BEGIN_NAMESPACE_CXX11
                
                #if _GLIBCXX_USE_C99_STDLIB
                  // 21.4 Numeric Conversions [string.conversions].
                  inline int
                  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long
                  stol(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: strtof vs strtod.
                  inline float
                  stof(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const string& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
                #endif // _GLIBCXX_USE_C99_STDLIB
                
                  // DR 1261. Insufficent overloads for to_string / to_wstring
                
                  inline string
                  to_string(int __val)
         955 ->   {
                    const bool __neg = __val < 0;
                    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
                    const auto __len = __detail::__to_chars_len(__uval);
                    string __str(__neg + __len, '-');
                    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
                    return __str;
                  }
                
                  inline string
                  to_string(unsigned __val)
           1 ->   {
                    string __str(__detail::__to_chars_len(__val), '\0');
                    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
                    return __str;
                  }
                
                  inline string
                  to_string(long __val)
                  {
                    const bool __neg = __val < 0;
                    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
                    const auto __len = __detail::__to_chars_len(__uval);
                    string __str(__neg + __len, '-');
                    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
                    return __str;
                  }
                
                  inline string
                  to_string(unsigned long __val)
                  {
                    string __str(__detail::__to_chars_len(__val), '\0');
                    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
                    return __str;
                  }
                
                  inline string
                  to_string(long long __val)
                  {
                    const bool __neg = __val < 0;
                    const unsigned long long __uval
                      = __neg ? (unsigned long long)~__val + 1ull : __val;
                    const auto __len = __detail::__to_chars_len(__uval);
                    string __str(__neg + __len, '-');
                    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
                    return __str;
                  }
                
                  inline string
                  to_string(unsigned long long __val)
                  {
                    string __str(__detail::__to_chars_len(__val), '\0');
                    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
                    return __str;
                  }
                
                #if _GLIBCXX_USE_C99_STDIO
                  // NB: (v)snprintf vs sprintf.
                
                  inline string
                  to_string(float __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%f", __val);
                  }
                
                  inline string
                  to_string(long double __val)
                  {
                    const int __n = 
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
                					   "%Lf", __val);
                  }
                #endif // _GLIBCXX_USE_C99_STDIO
                
                #if defined(_GLIBCXX_USE_WCHAR_T) && _GLIBCXX_USE_C99_WCHAR
                  inline int 
                  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
                					__idx, __base); }
                
                  inline long 
                  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long
                  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
                			     __idx, __base); }
                
                  inline long long
                  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
                			     __idx, __base); }
                
                  inline unsigned long long
                  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
                  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
                			     __idx, __base); }
                
                  // NB: wcstof vs wcstod.
                  inline float
                  stof(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
                
                  inline double
                  stod(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
                
                  inline long double
                  stold(const wstring& __str, size_t* __idx = 0)
                  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
                
                #ifndef _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                  // DR 1261.
                  inline wstring
                  to_wstring(int __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
                					    L"%d", __val); }
                
                  inline wstring
                  to_wstring(unsigned __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned),
                					    L"%u", __val); }
                
                  inline wstring
                  to_wstring(long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
                					    L"%ld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long),
                					    L"%lu", __val); }
                
                  inline wstring
                  to_wstring(long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(long long),
                					    L"%lld", __val); }
                
                  inline wstring
                  to_wstring(unsigned long long __val)
                  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
                					    4 * sizeof(unsigned long long),
                					    L"%llu", __val); }
                
                  inline wstring
                  to_wstring(float __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%f", __val);
                  }
                
                  inline wstring
                  to_wstring(long double __val)
                  {
                    const int __n =
                      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
                    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
                					    L"%Lf", __val);
                  }
                #endif // _GLIBCXX_HAVE_BROKEN_VSWPRINTF
                #endif // _GLIBCXX_USE_WCHAR_T && _GLIBCXX_USE_C99_WCHAR
                
                _GLIBCXX_END_NAMESPACE_CXX11
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #endif /* C++11 */
                
                #if __cplusplus >= 201103L
                
                #include <bits/functional_hash.h>
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // DR 1182.
                
                #ifndef _GLIBCXX_COMPATIBILITY_CXX0X
                  /// std::hash specialization for string.
                  template<>
                    struct hash<string>
                    : public __hash_base<size_t, string>
                    {
                      size_t
                      operator()(const string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<string>> : std::false_type
                    { };
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                  /// std::hash specialization for wstring.
                  template<>
                    struct hash<wstring>
                    : public __hash_base<size_t, wstring>
                    {
                      size_t
                      operator()(const wstring& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(wchar_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<wstring>> : std::false_type
                    { };
                #endif
                #endif /* _GLIBCXX_COMPATIBILITY_CXX0X */
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                  /// std::hash specialization for u8string.
                  template<>
                    struct hash<u8string>
                    : public __hash_base<size_t, u8string>
                    {
                      size_t
                      operator()(const u8string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char8_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u8string>> : std::false_type
                    { };
                #endif
                
                  /// std::hash specialization for u16string.
                  template<>
                    struct hash<u16string>
                    : public __hash_base<size_t, u16string>
                    {
                      size_t
                      operator()(const u16string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char16_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u16string>> : std::false_type
                    { };
                
                  /// std::hash specialization for u32string.
                  template<>
                    struct hash<u32string>
                    : public __hash_base<size_t, u32string>
                    {
                      size_t
                      operator()(const u32string& __s) const noexcept
                      { return std::_Hash_impl::hash(__s.data(),
                                                     __s.length() * sizeof(char32_t)); }
                    };
                
                  template<>
                    struct __is_fast_hash<hash<u32string>> : std::false_type
                    { };
                
                #if __cplusplus >= 201402L
                
                #define __cpp_lib_string_udls 201304
                
                  inline namespace literals
                  {
                  inline namespace string_literals
                  {
                #pragma GCC diagnostic push
                #pragma GCC diagnostic ignored "-Wliteral-suffix"
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char>
                    operator""s(const char* __str, size_t __len)
                    { return basic_string<char>{__str, __len}; }
                
                #ifdef _GLIBCXX_USE_WCHAR_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<wchar_t>
                    operator""s(const wchar_t* __str, size_t __len)
                    { return basic_string<wchar_t>{__str, __len}; }
                #endif
                
                #ifdef _GLIBCXX_USE_CHAR8_T
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char8_t>
                    operator""s(const char8_t* __str, size_t __len)
                    { return basic_string<char8_t>{__str, __len}; }
                #endif
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char16_t>
                    operator""s(const char16_t* __str, size_t __len)
                    { return basic_string<char16_t>{__str, __len}; }
                
                    _GLIBCXX_DEFAULT_ABI_TAG
                    inline basic_string<char32_t>
                    operator""s(const char32_t* __str, size_t __len)
                    { return basic_string<char32_t>{__str, __len}; }
                
                #pragma GCC diagnostic pop
                  } // inline namespace string_literals
                  } // inline namespace literals
                
                #if __cplusplus >= 201703L
                  namespace __detail::__variant
                  {
                    template<typename> struct _Never_valueless_alt; // see <variant>
                
                    // Provide the strong exception-safety guarantee when emplacing a
                    // basic_string into a variant, but only if moving the string cannot throw.
                    template<typename _Tp, typename _Traits, typename _Alloc>
                      struct _Never_valueless_alt<std::basic_string<_Tp, _Traits, _Alloc>>
                      : __and_<
                	is_nothrow_move_constructible<std::basic_string<_Tp, _Traits, _Alloc>>,
                	is_nothrow_move_assignable<std::basic_string<_Tp, _Traits, _Alloc>>
                	>::type
                      { };
                  }  // namespace __detail::__variant
                #endif // C++17
                #endif // C++14
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++11
                
                #endif /* _BASIC_STRING_H */


Top 10 Lines:

     Line      Count

      533       4563
      194       3186
      158       1593
      208       1593
      229       1593
      237       1593
      244       1593
      294       1593
      671       1593
      553        956

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

    21928   Total number of line executions
  1566.29   Average executions per line


*** File /usr/include/c++/11/bits/stl_iterator.h:
                // Iterators -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_iterator.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{iterator}
                 *
                 *  This file implements reverse_iterator, back_insert_iterator,
                 *  front_insert_iterator, insert_iterator, __normal_iterator, and their
                 *  supporting functions and overloaded operators.
                 */
                
                #ifndef _STL_ITERATOR_H
                #define _STL_ITERATOR_H 1
                
                #include <bits/cpp_type_traits.h>
                #include <bits/stl_iterator_base_types.h>
                #include <ext/type_traits.h>
                #include <bits/move.h>
                #include <bits/ptr_traits.h>
                
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                
                #if __cplusplus > 201703L
                # define __cpp_lib_array_constexpr 201811L
                # define __cpp_lib_constexpr_iterator 201811L
                #elif __cplusplus == 201703L
                # define __cpp_lib_array_constexpr 201803L
                #endif
                
                #if __cplusplus >= 202002L
                # include <compare>
                # include <new>
                # include <bits/exception_defines.h>
                # include <bits/iterator_concepts.h>
                # include <bits/stl_construct.h>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                #if __cpp_lib_concepts
                  namespace __detail
                  {
                    // Weaken iterator_category _Cat to _Limit if it is derived from that,
                    // otherwise use _Otherwise.
                    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
                      using __clamp_iter_cat
                	= conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
                  }
                #endif
                
                  // 24.4.1 Reverse iterators
                  /**
                   *  Bidirectional and random access iterators have corresponding reverse
                   *  %iterator adaptors that iterate through the data structure in the
                   *  opposite direction.  They have the same signatures as the corresponding
                   *  iterators.  The fundamental relation between a reverse %iterator and its
                   *  corresponding %iterator @c i is established by the identity:
                   *  @code
                   *      &*(reverse_iterator(i)) == &*(i - 1)
                   *  @endcode
                   *
                   *  <em>This mapping is dictated by the fact that while there is always a
                   *  pointer past the end of an array, there might not be a valid pointer
                   *  before the beginning of an array.</em> [24.4.1]/1,2
                   *
                   *  Reverse iterators can be tricky and surprising at first.  Their
                   *  semantics make sense, however, and the trickiness is a side effect of
                   *  the requirement that the iterators must be safe.
                  */
                  template<typename _Iterator>
                    class reverse_iterator
                    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                		      typename iterator_traits<_Iterator>::value_type,
                		      typename iterator_traits<_Iterator>::difference_type,
                		      typename iterator_traits<_Iterator>::pointer,
                                      typename iterator_traits<_Iterator>::reference>
                    {
                      template<typename _Iter>
                	friend class reverse_iterator;
                
                #if __cpp_lib_concepts
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
                      template<typename _Iter>
                	static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
                	    && convertible_to<const _Iter&, _Iterator>;
                #endif
                
                    protected:
                      _Iterator current;
                
                      typedef iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::pointer		pointer;
                #if ! __cpp_lib_concepts
                      typedef typename __traits_type::difference_type	difference_type;
                      typedef typename __traits_type::reference		reference;
                #else
                      using iterator_concept
                	= conditional_t<random_access_iterator<_Iterator>,
                			random_access_iterator_tag,
                			bidirectional_iterator_tag>;
                      using iterator_category
                	= __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
                				     random_access_iterator_tag>;
                      using value_type = iter_value_t<_Iterator>;
                      using difference_type = iter_difference_t<_Iterator>;
                      using reference = iter_reference_t<_Iterator>;
                #endif
                
                      /**
                       *  The default constructor value-initializes member @p current.
                       *  If it is a pointer, that means it is zero-initialized.
                      */
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 235 No specification of default ctor for reverse_iterator
                      // 1012. reverse_iterator default ctor should value initialize
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator() : current() { }
                
                      /**
                       *  This %iterator will move in the opposite direction that @p x does.
                      */
                      explicit _GLIBCXX17_CONSTEXPR
                      reverse_iterator(iterator_type __x) : current(__x) { }
                
                      /**
                       *  The copy constructor is normal.
                      */
                      _GLIBCXX17_CONSTEXPR
                      reverse_iterator(const reverse_iterator& __x)
                      : current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      reverse_iterator& operator=(const reverse_iterator&) = default;
                #endif
                
                      /**
                       *  A %reverse_iterator across other types can be copied if the
                       *  underlying %iterator can be converted to the type of @c current.
                      */
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                #endif
                	_GLIBCXX17_CONSTEXPR
                        reverse_iterator(const reverse_iterator<_Iter>& __x)
                	: current(__x.current) { }
                
                #if __cplusplus >= 201103L
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                	  && assignable_from<_Iterator&, const _Iter&>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	reverse_iterator&
                	operator=(const reverse_iterator<_Iter>& __x)
                	{
                	  current = __x.current;
                	  return *this;
                	}
                #endif
                
                      /**
                       *  @return  @c current, the %iterator used for underlying work.
                      */
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return current; }
                
                      /**
                       *  @return  A reference to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                       *
                       *  @warning This implementation requires that for an iterator of the
                       *           underlying iterator type, @c x, a reference obtained by
                       *           @c *x remains valid after @c x has been modified or
                       *           destroyed. This is a bug: http://gcc.gnu.org/PR51823
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                      {
                	_Iterator __tmp = current;
                	return *--__tmp;
                      }
                
                      /**
                       *  @return  A pointer to the value at @c --current
                       *
                       *  This requires that @c --current is dereferenceable.
                      */
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                #if __cplusplus > 201703L && __cpp_concepts >= 201907L
                      requires is_pointer_v<_Iterator>
                	|| requires(const _Iterator __i) { __i.operator->(); }
                #endif
                      {
                	// _GLIBCXX_RESOLVE_LIB_DEFECTS
                	// 1052. operator-> should also support smart pointers
                	_Iterator __tmp = current;
                	--__tmp;
                	return _S_to_pointer(__tmp);
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator++()
                      {
                	--current;
                	return *this;
                      }
                
                      /**
                       *  @return  The original value of @c *this
                       *
                       *  Decrements the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator++(int)
                      {
                	reverse_iterator __tmp = *this;
                	--current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator--()
                      {
                	++current;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator with the previous value of @c *this
                       *
                       *  Increments the underlying iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator--(int)
                      {
                	reverse_iterator __tmp = *this;
                	++current;
                	return __tmp;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator+(difference_type __n) const
                      { return reverse_iterator(current - __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator backwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator+=(difference_type __n)
                      {
                	current -= __n;
                	return *this;
                      }
                
                      /**
                       *  @return  A reverse_iterator that refers to @c current - @a __n
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator
                      operator-(difference_type __n) const
                      { return reverse_iterator(current + __n); }
                
                      /**
                       *  @return  *this
                       *
                       *  Moves the underlying iterator forwards @a __n steps.
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reverse_iterator&
                      operator-=(difference_type __n)
                      {
                	current += __n;
                	return *this;
                      }
                
                      /**
                       *  @return  The value at @c current - @a __n - 1
                       *
                       *  The underlying iterator must be a Random Access Iterator.
                      */
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                      { return *(*this + __n); }
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      friend constexpr iter_rvalue_reference_t<_Iterator>
                      iter_move(const reverse_iterator& __i)
                      noexcept(is_nothrow_copy_constructible_v<_Iterator>
                	       && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
                      {
                	auto __tmp = __i.base();
                	return ranges::iter_move(--__tmp);
                      }
                
                      template<indirectly_swappable<_Iterator> _Iter2>
                	friend constexpr void
                	iter_swap(const reverse_iterator& __x,
                		  const reverse_iterator<_Iter2>& __y)
                	noexcept(is_nothrow_copy_constructible_v<_Iterator>
                		 && is_nothrow_copy_constructible_v<_Iter2>
                		 && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
                					       --std::declval<_Iter2&>())))
                	{
                	  auto __xtmp = __x.base();
                	  auto __ytmp = __y.base();
                	  ranges::iter_swap(--__xtmp, --__ytmp);
                	}
                #endif
                
                    private:
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR _Tp*
                	_S_to_pointer(_Tp* __p)
                        { return __p; }
                
                      template<typename _Tp>
                	static _GLIBCXX17_CONSTEXPR pointer
                	_S_to_pointer(_Tp __t)
                        { return __t.operator->(); }
                    };
                
                  ///@{
                  /**
                   *  @param  __x  A %reverse_iterator.
                   *  @param  __y  A %reverse_iterator.
                   *  @return  A simple bool.
                   *
                   *  Reverse iterators forward comparisons to their underlying base()
                   *  iterators.
                   *
                  */
                #if __cplusplus <= 201703L || ! defined __cpp_lib_concepts
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() < __x.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 280. Comparison of reverse_iterator to const reverse_iterator.
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() > __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() != __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() >= __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    { return __x.base() <= __y.base(); }
                #else // C++20
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator==(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
                    { return __x.base() == __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator!=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
                    { return __x.base() != __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator<(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
                    { return __x.base() > __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator>(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator<=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
                    { return __x.base() >= __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    constexpr bool
                    operator>=(const reverse_iterator<_IteratorL>& __x,
                	       const reverse_iterator<_IteratorR>& __y)
                    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
                    { return __x.base() <= __y.base(); }
                
                  template<typename _IteratorL,
                	   three_way_comparable_with<_IteratorL> _IteratorR>
                    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
                    operator<=>(const reverse_iterator<_IteratorL>& __x,
                		const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() <=> __x.base(); }
                
                  // Additional, non-standard overloads to avoid ambiguities with greedy,
                  // unconstrained overloads in associated namespaces.
                
                  template<typename _Iterator>
                    constexpr bool
                    operator==(const reverse_iterator<_Iterator>& __x,
                	       const reverse_iterator<_Iterator>& __y)
                    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
                    { return __x.base() == __y.base(); }
                
                  template<three_way_comparable _Iterator>
                    constexpr compare_three_way_result_t<_Iterator, _Iterator>
                    operator<=>(const reverse_iterator<_Iterator>& __x,
                		const reverse_iterator<_Iterator>& __y)
                    { return __y.base() <=> __x.base(); }
                #endif // C++20
                  ///@}
                
                #if __cplusplus < 201103L
                  template<typename _Iterator>
                    inline typename reverse_iterator<_Iterator>::difference_type
                    operator-(const reverse_iterator<_Iterator>& __x,
                	      const reverse_iterator<_Iterator>& __y)
                    { return __y.base() - __x.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline typename reverse_iterator<_IteratorL>::difference_type
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    { return __y.base() - __x.base(); }
                #else
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 685. reverse_iterator/move_iterator difference has invalid signatures
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const reverse_iterator<_IteratorL>& __x,
                	      const reverse_iterator<_IteratorR>& __y)
                    -> decltype(__y.base() - __x.base())
                    { return __y.base() - __x.base(); }
                #endif
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
                	      const reverse_iterator<_Iterator>& __x)
                    { return reverse_iterator<_Iterator>(__x.base() - __n); }
                
                #if __cplusplus >= 201103L
                  // Same as C++14 make_reverse_iterator but used in C++11 mode too.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    __make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                # if __cplusplus >= 201402L
                #  define __cpp_lib_make_reverse_iterator 201402
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 2285. make_reverse_iterator
                  /// Generator function for reverse_iterator.
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR reverse_iterator<_Iterator>
                    make_reverse_iterator(_Iterator __i)
                    { return reverse_iterator<_Iterator>(__i); }
                
                #  if __cplusplus > 201703L && defined __cpp_lib_concepts
                  template<typename _Iterator1, typename _Iterator2>
                    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
                    inline constexpr bool
                    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
                			       reverse_iterator<_Iterator2>> = true;
                #  endif // C++20
                # endif // C++14
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __niter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
                    { return __make_reverse_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<reverse_iterator<_Iterator> >
                      : __is_move_iterator<_Iterator>
                    { };
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __miter_base(reverse_iterator<_Iterator> __it)
                    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
                    { return __make_reverse_iterator(__miter_base(__it.base())); }
                #endif // C++11
                
                  // 24.4.2.2.1 back_insert_iterator
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator appends it to the container using
                   *  push_back.
                   *
                   *  Tip:  Using the back_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class back_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                #if __cplusplus > 201703L
                      using difference_type = ptrdiff_t;
                
                      constexpr back_insert_iterator() noexcept : container(nullptr) { }
                #endif
                
                      /// The only way to create this %iterator is with a container.
                      explicit _GLIBCXX20_CONSTEXPR
                      back_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the end, if you like).  Assigning a value to the %iterator will
                       *  always append the value to the end of the container.
                      */
                #if __cplusplus < 201103L
                      back_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_back(__value);
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_back(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      back_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of back_insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating back_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline back_insert_iterator<_Container>
                    back_inserter(_Container& __x)
                    { return back_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator prepends it to the container using
                   *  push_front.
                   *
                   *  Tip:  Using the front_inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class front_insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                    protected:
                      _Container* container;
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                #if __cplusplus > 201703L
                      using difference_type = ptrdiff_t;
                
                      constexpr front_insert_iterator() noexcept : container(nullptr) { }
                #endif
                
                      /// The only way to create this %iterator is with a container.
                      explicit _GLIBCXX20_CONSTEXPR
                      front_insert_iterator(_Container& __x)
                      : container(std::__addressof(__x)) { }
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator doesn't really have a @a position in the
                       *  container (you can think of the position as being permanently at
                       *  the front, if you like).  Assigning a value to the %iterator will
                       *  always prepend the value to the front of the container.
                      */
                #if __cplusplus < 201103L
                      front_insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	container->push_front(__value);
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	container->push_front(std::move(__value));
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      front_insert_iterator
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param  __x  A container of arbitrary type.
                   *  @return  An instance of front_insert_iterator working on @p x.
                   *
                   *  This wrapper function helps in creating front_insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                  template<typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline front_insert_iterator<_Container>
                    front_inserter(_Container& __x)
                    { return front_insert_iterator<_Container>(__x); }
                
                  /**
                   *  @brief  Turns assignment into insertion.
                   *
                   *  These are output iterators, constructed from a container-of-T.
                   *  Assigning a T to the iterator inserts it in the container at the
                   *  %iterator's position, rather than overwriting the value at that
                   *  position.
                   *
                   *  (Sequences will actually insert a @e copy of the value before the
                   *  %iterator's position.)
                   *
                   *  Tip:  Using the inserter function to create these iterators can
                   *  save typing.
                  */
                  template<typename _Container>
                    class insert_iterator
                    : public iterator<output_iterator_tag, void, void, void, void>
                    {
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                      using _Iter = std::__detail::__range_iter_t<_Container>;
                
                    protected:
                      _Container* container = nullptr;
                      _Iter iter = _Iter();
                #else
                      typedef typename _Container::iterator		_Iter;
                
                    protected:
                      _Container* container;
                      _Iter iter;
                #endif
                
                    public:
                      /// A nested typedef for the type of whatever container you used.
                      typedef _Container          container_type;
                
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                      using difference_type = ptrdiff_t;
                
                      insert_iterator() = default;
                #endif
                
                      /**
                       *  The only way to create this %iterator is with a container and an
                       *  initial position (a normal %iterator into the container).
                      */
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator(_Container& __x, _Iter __i)
                      : container(std::__addressof(__x)), iter(__i) {}
                
                      /**
                       *  @param  __value  An instance of whatever type
                       *                 container_type::const_reference is; presumably a
                       *                 reference-to-const T for container<T>.
                       *  @return  This %iterator, for chained operations.
                       *
                       *  This kind of %iterator maintains its own position in the
                       *  container.  Assigning a value to the %iterator will insert the
                       *  value into the container at the place before the %iterator.
                       *
                       *  The position is maintained such that subsequent assignments will
                       *  insert values immediately after one another.  For example,
                       *  @code
                       *     // vector v contains A and Z
                       *
                       *     insert_iterator i (v, ++v.begin());
                       *     i = 1;
                       *     i = 2;
                       *     i = 3;
                       *
                       *     // vector v contains A, 1, 2, 3, and Z
                       *  @endcode
                      */
                #if __cplusplus < 201103L
                      insert_iterator&
                      operator=(typename _Container::const_reference __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                #else
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator=(const typename _Container::value_type& __value)
                      {
                	iter = container->insert(iter, __value);
                	++iter;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator=(typename _Container::value_type&& __value)
                      {
                	iter = container->insert(iter, std::move(__value));
                	++iter;
                	return *this;
                      }
                #endif
                
                      /// Simply returns *this.
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator*()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator++()
                      { return *this; }
                
                      /// Simply returns *this.  (This %iterator does not @a move.)
                      _GLIBCXX20_CONSTEXPR
                      insert_iterator&
                      operator++(int)
                      { return *this; }
                    };
                
                  /**
                   *  @param __x  A container of arbitrary type.
                   *  @param __i  An iterator into the container.
                   *  @return  An instance of insert_iterator working on @p __x.
                   *
                   *  This wrapper function helps in creating insert_iterator instances.
                   *  Typing the name of the %iterator requires knowing the precise full
                   *  type of the container, which can be tedious and impedes generic
                   *  programming.  Using this function lets you take advantage of automatic
                   *  template parameter deduction, making the compiler match the correct
                   *  types for you.
                  */
                #if __cplusplus > 201703L && defined __cpp_lib_concepts
                  template<typename _Container>
                    constexpr insert_iterator<_Container>
                    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
                    { return insert_iterator<_Container>(__x, __i); }
                #else
                  template<typename _Container>
                    inline insert_iterator<_Container>
                    inserter(_Container& __x, typename _Container::iterator __i)
                    { return insert_iterator<_Container>(__x, __i); }
                #endif
                
                  /// @} group iterators
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace __gnu_cxx _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  // This iterator adapter is @a normal in the sense that it does not
                  // change the semantics of any of the operators of its iterator
                  // parameter.  Its primary purpose is to convert an iterator that is
                  // not a class, e.g. a pointer, into an iterator that is a class.
                  // The _Container parameter exists solely so that different containers
                  // using this template can instantiate different types, even if the
                  // _Iterator parameter is the same.
                  template<typename _Iterator, typename _Container>
                    class __normal_iterator
                    {
                    protected:
                      _Iterator _M_current;
                
                      typedef std::iterator_traits<_Iterator>		__traits_type;
                
                    public:
                      typedef _Iterator					iterator_type;
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type 	difference_type;
                      typedef typename __traits_type::reference 	reference;
                      typedef typename __traits_type::pointer   	pointer;
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      using iterator_concept = std::__detail::__iter_concept<_Iterator>;
                #endif
                
                      _GLIBCXX_CONSTEXPR __normal_iterator() _GLIBCXX_NOEXCEPT
                      : _M_current(_Iterator()) { }
                
                      explicit _GLIBCXX20_CONSTEXPR
      451676 ->       __normal_iterator(const _Iterator& __i) _GLIBCXX_NOEXCEPT
                      : _M_current(__i) { }
                
                      // Allow iterator to const_iterator conversion
                      template<typename _Iter>
                        _GLIBCXX20_CONSTEXPR
        3699 ->         __normal_iterator(const __normal_iterator<_Iter,
                			  typename __enable_if<
                      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
                		      _Container>::__type>& __i) _GLIBCXX_NOEXCEPT
                        : _M_current(__i.base()) { }
                
                      // Forward iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      reference
      284204 ->       operator*() const _GLIBCXX_NOEXCEPT
                      { return *_M_current; }
                
                      _GLIBCXX20_CONSTEXPR
                      pointer
                      operator->() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
      219203 ->       operator++() _GLIBCXX_NOEXCEPT
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
                      operator++(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current++); }
                
                      // Bidirectional iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
       ##### ->       operator--() _GLIBCXX_NOEXCEPT
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
                      operator--(int) _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current--); }
                
                      // Random access iterator requirements
                      _GLIBCXX20_CONSTEXPR
                      reference
                      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return _M_current[__n]; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
                      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current += __n; return *this; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
        9842 ->       operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current + __n); }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator&
                      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
                      { _M_current -= __n; return *this; }
                
                      _GLIBCXX20_CONSTEXPR
                      __normal_iterator
       64239 ->       operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
                      { return __normal_iterator(_M_current - __n); }
                
                      _GLIBCXX20_CONSTEXPR
                      const _Iterator&
      876223 ->       base() const _GLIBCXX_NOEXCEPT
                      { return _M_current; }
                    };
                
                  // Note: In what follows, the left- and right-hand-side iterators are
                  // allowed to vary in types (conceptually in cv-qualification) so that
                  // comparison between cv-qualified and non-cv-qualified iterators be
                  // valid.  However, the greedy and unfriendly operators in std::rel_ops
                  // will make overload resolution ambiguous (when in scope) if we don't
                  // provide overloads whose operands are of the same type.  Can someone
                  // remind me what generic programming is about? -- Gaby
                
                #if __cpp_lib_three_way_comparison
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    requires requires (_IteratorL __lhs, _IteratorR __rhs)
                    { { __lhs == __rhs } -> std::convertible_to<bool>; }
                    constexpr bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    noexcept(noexcept(__lhs.base() == __rhs.base()))
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
                    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                		const __normal_iterator<_IteratorR, _Container>& __rhs)
                    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
                    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
                
                  template<typename _Iterator, typename _Container>
                    constexpr bool
                    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    noexcept(noexcept(__lhs.base() == __rhs.base()))
                    requires requires {
                      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
                    }
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    constexpr std::__detail::__synth3way_t<_Iterator>
                    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
                		const __normal_iterator<_Iterator, _Container>& __rhs)
                    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
                    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
                #else
                   // Forward iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
         750 ->     operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() == __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
      313744 ->     operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() != __rhs.base(); }
                
                  // Random access iterator requirements
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
       ##### ->     operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() < __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() > __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() <= __rhs.base(); }
                
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                    inline bool
                    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	       const __normal_iterator<_IteratorR, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
                	       const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() >= __rhs.base(); }
                #endif // three-way comparison
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // According to the resolution of DR179 not only the various comparison
                  // operators but also operator- must accept mixed iterator/const_iterator
                  // parameters.
                  template<typename _IteratorL, typename _IteratorR, typename _Container>
                #if __cplusplus >= 201103L
                    // DR 685.
                    _GLIBCXX20_CONSTEXPR
                    inline auto
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
                    -> decltype(__lhs.base() - __rhs.base())
                #else
                    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
                    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
                	      const __normal_iterator<_IteratorR, _Container>& __rhs)
                #endif
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline typename __normal_iterator<_Iterator, _Container>::difference_type
       62708 ->     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
                	      const __normal_iterator<_Iterator, _Container>& __rhs)
                    _GLIBCXX_NOEXCEPT
                    { return __lhs.base() - __rhs.base(); }
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    inline __normal_iterator<_Iterator, _Container>
                    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
                	      __n, const __normal_iterator<_Iterator, _Container>& __i)
                    _GLIBCXX_NOEXCEPT
                    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  template<typename _Iterator, typename _Container>
                    _GLIBCXX20_CONSTEXPR
                    _Iterator
        3492 ->     __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it.base(); }
                
                #if __cplusplus >= 201103L
                  /**
                   * @addtogroup iterators
                   * @{
                   */
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                  template<semiregular _Sent>
                    class move_sentinel
                    {
                    public:
                      constexpr
                      move_sentinel()
                      noexcept(is_nothrow_default_constructible_v<_Sent>)
                      : _M_last() { }
                
                      constexpr explicit
                      move_sentinel(_Sent __s)
                      noexcept(is_nothrow_move_constructible_v<_Sent>)
                      : _M_last(std::move(__s)) { }
                
                      template<typename _S2> requires convertible_to<const _S2&, _Sent>
                	constexpr
                	move_sentinel(const move_sentinel<_S2>& __s)
                	noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
                	: _M_last(__s.base())
                	{ }
                
                      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
                	constexpr move_sentinel&
                	operator=(const move_sentinel<_S2>& __s)
                	noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
                	{
                	  _M_last = __s.base();
                	  return *this;
                	}
                
                      constexpr _Sent
                      base() const
                      noexcept(is_nothrow_copy_constructible_v<_Sent>)
                      { return _M_last; }
                
                    private:
                      _Sent _M_last;
                    };
                #endif // C++20
                
                  namespace __detail
                  {
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    template<typename _Iterator>
                      struct __move_iter_cat
                      { };
                
                    template<typename _Iterator>
                      requires requires { typename iterator_traits<_Iterator>::iterator_category; }
                      struct __move_iter_cat<_Iterator>
                      {
                	using iterator_category
                	  = __clamp_iter_cat<typename iterator_traits<_Iterator>::iterator_category,
                			     random_access_iterator_tag>;
                      };
                #endif
                  }
                
                  // 24.4.3  Move iterators
                  /**
                   *  Class template move_iterator is an iterator adapter with the same
                   *  behavior as the underlying iterator except that its dereference
                   *  operator implicitly converts the value returned by the underlying
                   *  iterator's dereference operator to an rvalue reference.  Some
                   *  generic algorithms can be called with move iterators to replace
                   *  copying with moving.
                   */
                  template<typename _Iterator>
                    class move_iterator
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      : public __detail::__move_iter_cat<_Iterator>
                #endif
                    {
                      _Iterator _M_current;
                
                      using __traits_type = iterator_traits<_Iterator>;
                #if ! (__cplusplus > 201703L && __cpp_lib_concepts)
                      using __base_ref = typename __traits_type::reference;
                #endif
                
                      template<typename _Iter2>
                	friend class move_iterator;
                
                #if __cpp_lib_concepts
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 3435. three_way_comparable_with<reverse_iterator<int*>, [...]>
                      template<typename _Iter2>
                	static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
                	    && convertible_to<const _Iter2&, _Iterator>;
                #endif
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      static auto
                      _S_iter_concept()
                      {
                	if constexpr (random_access_iterator<_Iterator>)
                	  return random_access_iterator_tag{};
                	else if constexpr (bidirectional_iterator<_Iterator>)
                	  return bidirectional_iterator_tag{};
                	else if constexpr (forward_iterator<_Iterator>)
                	  return forward_iterator_tag{};
                	else
                	  return input_iterator_tag{};
                      }
                #endif
                
                    public:
                      using iterator_type = _Iterator;
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      // This is P2520R0, a C++23 change, but we treat it as a DR against C++20.
                # define __cpp_lib_move_iterator_concept 202207L
                      using iterator_concept = decltype(_S_iter_concept());
                
                      // iterator_category defined in __move_iter_cat
                      using value_type = iter_value_t<_Iterator>;
                      using difference_type = iter_difference_t<_Iterator>;
                      using pointer = _Iterator;
                      using reference = iter_rvalue_reference_t<_Iterator>;
                #else
                      typedef typename __traits_type::iterator_category iterator_category;
                      typedef typename __traits_type::value_type  	value_type;
                      typedef typename __traits_type::difference_type	difference_type;
                      // NB: DR 680.
                      typedef _Iterator					pointer;
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 2106. move_iterator wrapping iterators returning prvalues
                      typedef typename conditional<is_reference<__base_ref>::value,
                			 typename remove_reference<__base_ref>::type&&,
                			 __base_ref>::type		reference;
                #endif
                
                      _GLIBCXX17_CONSTEXPR
                      move_iterator()
                      : _M_current() { }
                
                      explicit _GLIBCXX17_CONSTEXPR
                      move_iterator(iterator_type __i)
                      : _M_current(std::move(__i)) { }
                
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	move_iterator(const move_iterator<_Iter>& __i)
                	: _M_current(__i._M_current) { }
                
                      template<typename _Iter>
                #if __cpp_lib_concepts
                	requires __convertible<_Iter>
                	  && assignable_from<_Iterator&, const _Iter&>
                #endif
                	_GLIBCXX17_CONSTEXPR
                	move_iterator& operator=(const move_iterator<_Iter>& __i)
                	{
                	  _M_current = __i._M_current;
                	  return *this;
                	}
                
                #if __cplusplus <= 201703L
                      _GLIBCXX17_CONSTEXPR iterator_type
                      base() const
                      { return _M_current; }
                #else
                      constexpr const iterator_type&
                      base() const & noexcept
                      { return _M_current; }
                
                      constexpr iterator_type
                      base() &&
                      { return std::move(_M_current); }
                #endif
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator*() const
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      { return ranges::iter_move(_M_current); }
                #else
                      { return static_cast<reference>(*_M_current); }
                #endif
                
                      _GLIBCXX17_CONSTEXPR pointer
                      operator->() const
                      { return _M_current; }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator++()
                      {
                	++_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator++(int)
                      {
                	move_iterator __tmp = *this;
                	++_M_current;
                	return __tmp;
                      }
                
                #if __cpp_lib_concepts
                      constexpr void
                      operator++(int) requires (!forward_iterator<_Iterator>)
                      { ++_M_current; }
                #endif
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator--()
                      {
                	--_M_current;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator--(int)
                      {
                	move_iterator __tmp = *this;
                	--_M_current;
                	return __tmp;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator+(difference_type __n) const
                      { return move_iterator(_M_current + __n); }
                
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator+=(difference_type __n)
                      {
                	_M_current += __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR move_iterator
                      operator-(difference_type __n) const
                      { return move_iterator(_M_current - __n); }
                    
                      _GLIBCXX17_CONSTEXPR move_iterator&
                      operator-=(difference_type __n)
                      { 
                	_M_current -= __n;
                	return *this;
                      }
                
                      _GLIBCXX17_CONSTEXPR reference
                      operator[](difference_type __n) const
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      { return ranges::iter_move(_M_current + __n); }
                #else
                      { return std::move(_M_current[__n]); }
                #endif
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                      template<sentinel_for<_Iterator> _Sent>
                	friend constexpr bool
                	operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
                	{ return __x.base() == __y.base(); }
                
                      template<sized_sentinel_for<_Iterator> _Sent>
                	friend constexpr iter_difference_t<_Iterator>
                	operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
                	{ return __x.base() - __y.base(); }
                
                      template<sized_sentinel_for<_Iterator> _Sent>
                	friend constexpr iter_difference_t<_Iterator>
                	operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
                	{ return __x.base() - __y.base(); }
                
                      friend constexpr iter_rvalue_reference_t<_Iterator>
                      iter_move(const move_iterator& __i)
                      noexcept(noexcept(ranges::iter_move(__i._M_current)))
                      { return ranges::iter_move(__i._M_current); }
                
                      template<indirectly_swappable<_Iterator> _Iter2>
                	friend constexpr void
                	iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
                	noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
                	{ return ranges::iter_swap(__x._M_current, __y._M_current); }
                #endif // C++20
                    };
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
                #endif
                    { return __x.base() == __y.base(); }
                
                #if __cpp_lib_three_way_comparison
                  template<typename _IteratorL,
                	   three_way_comparable_with<_IteratorL> _IteratorR>
                    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
                    operator<=>(const move_iterator<_IteratorL>& __x,
                		const move_iterator<_IteratorR>& __y)
                    { return __x.base() <=> __y.base(); }
                #else
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                    { return !(__x == __y); }
                #endif
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                #endif
                    { return __x.base() < __y.base(); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }
                #endif
                    { return !(__y < __x); }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }
                #endif
                    { return __y < __x; }
                
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_IteratorL>& __x,
                	       const move_iterator<_IteratorR>& __y)
                #if __cplusplus > 201703L && __cpp_lib_concepts
                    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
                #endif
                    { return !(__x < __y); }
                
                  // Note: See __normal_iterator operators note from Gaby to understand
                  // why we have these extra overloads for some move_iterator operators.
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator==(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return __x.base() == __y.base(); }
                
                #if __cpp_lib_three_way_comparison
                  template<three_way_comparable _Iterator>
                    constexpr compare_three_way_result_t<_Iterator>
                    operator<=>(const move_iterator<_Iterator>& __x,
                		const move_iterator<_Iterator>& __y)
                    { return __x.base() <=> __y.base(); }
                #else
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator!=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x == __y); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __x.base() < __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator<=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__y < __x); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>(const move_iterator<_Iterator>& __x,
                	      const move_iterator<_Iterator>& __y)
                    { return __y < __x; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR bool
                    operator>=(const move_iterator<_Iterator>& __x,
                	       const move_iterator<_Iterator>& __y)
                    { return !(__x < __y); }
                #endif // ! C++20
                
                  // DR 685.
                  template<typename _IteratorL, typename _IteratorR>
                    inline _GLIBCXX17_CONSTEXPR auto
                    operator-(const move_iterator<_IteratorL>& __x,
                	      const move_iterator<_IteratorR>& __y)
                    -> decltype(__x.base() - __y.base())
                    { return __x.base() - __y.base(); }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    operator+(typename move_iterator<_Iterator>::difference_type __n,
                	      const move_iterator<_Iterator>& __x)
                    { return __x + __n; }
                
                  template<typename _Iterator>
                    inline _GLIBCXX17_CONSTEXPR move_iterator<_Iterator>
                    make_move_iterator(_Iterator __i)
                    { return move_iterator<_Iterator>(std::move(__i)); }
                
                  template<typename _Iterator, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond
                      <typename iterator_traits<_Iterator>::value_type>::value,
                                _Iterator, move_iterator<_Iterator>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
                    __make_move_if_noexcept_iterator(_Iterator __i)
                    { return _ReturnType(__i); }
                
                  // Overload for pointers that matches std::move_if_noexcept more closely,
                  // returning a constant iterator when we don't want to move.
                  template<typename _Tp, typename _ReturnType
                    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
                			   const _Tp*, move_iterator<_Tp*>>::type>
                    inline _GLIBCXX17_CONSTEXPR _ReturnType
       18604 ->     __make_move_if_noexcept_iterator(_Tp* __i)
                    { return _ReturnType(__i); }
                
                #if __cplusplus > 201703L && __cpp_lib_concepts
                  // [iterators.common] Common iterators
                
                  namespace __detail
                  {
                    template<typename _It>
                      concept __common_iter_has_arrow = indirectly_readable<const _It>
                	&& (requires(const _It& __it) { __it.operator->(); }
                	    || is_reference_v<iter_reference_t<_It>>
                	    || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);
                
                    template<typename _It>
                      concept __common_iter_use_postfix_proxy
                	= (!requires (_It& __i) { { *__i++ } -> __can_reference; })
                	  && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
                	  && move_constructible<iter_value_t<_It>>;
                  } // namespace __detail
                
                  /// An iterator/sentinel adaptor for representing a non-common range.
                  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
                    requires (!same_as<_It, _Sent>) && copyable<_It>
                  class common_iterator
                  {
                    template<typename _Tp, typename _Up>
                      static constexpr bool
                      _S_noexcept1()
                      {
                	if constexpr (is_trivially_default_constructible_v<_Tp>)
                	  return is_nothrow_assignable_v<_Tp&, _Up>;
                	else
                	  return is_nothrow_constructible_v<_Tp, _Up>;
                      }
                
                    template<typename _It2, typename _Sent2>
                      static constexpr bool
                      _S_noexcept()
                      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }
                
                    class __arrow_proxy
                    {
                      iter_value_t<_It> _M_keep;
                
                      constexpr
                      __arrow_proxy(iter_reference_t<_It>&& __x)
                      : _M_keep(std::move(__x)) { }
                
                      friend class common_iterator;
                
                    public:
                      constexpr const iter_value_t<_It>*
                      operator->() const noexcept
                      { return std::__addressof(_M_keep); }
                    };
                
                    class __postfix_proxy
                    {
                      iter_value_t<_It> _M_keep;
                
                      constexpr
                      __postfix_proxy(iter_reference_t<_It>&& __x)
                      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }
                
                      friend class common_iterator;
                
                    public:
                      constexpr const iter_value_t<_It>&
                      operator*() const noexcept
                      { return _M_keep; }
                    };
                
                  public:
                    constexpr
                    common_iterator()
                    noexcept(is_nothrow_default_constructible_v<_It>)
                    requires default_initializable<_It>
                    : _M_it(), _M_index(0)
                    { }
                
                    constexpr
                    common_iterator(_It __i)
                    noexcept(is_nothrow_move_constructible_v<_It>)
                    : _M_it(std::move(__i)), _M_index(0)
                    { }
                
                    constexpr
                    common_iterator(_Sent __s)
                    noexcept(is_nothrow_move_constructible_v<_Sent>)
                    : _M_sent(std::move(__s)), _M_index(1)
                    { }
                
                    template<typename _It2, typename _Sent2>
                      requires convertible_to<const _It2&, _It>
                	&& convertible_to<const _Sent2&, _Sent>
                      constexpr
                      common_iterator(const common_iterator<_It2, _Sent2>& __x)
                      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
                      : _M_valueless(), _M_index(__x._M_index)
                      {
                	__glibcxx_assert(__x._M_has_value());
                	if (_M_index == 0)
                	  {
                	    if constexpr (is_trivially_default_constructible_v<_It>)
                	      _M_it = std::move(__x._M_it);
                	    else
                	      std::construct_at(std::__addressof(_M_it), __x._M_it);
                	  }
                	else if (_M_index == 1)
                	  {
                	    if constexpr (is_trivially_default_constructible_v<_Sent>)
                	      _M_sent = std::move(__x._M_sent);
                	    else
                	      std::construct_at(std::__addressof(_M_sent), __x._M_sent);
                	  }
                      }
                
                    constexpr
                    common_iterator(const common_iterator& __x)
                    noexcept(_S_noexcept<const _It&, const _Sent&>())
                    : _M_valueless(), _M_index(__x._M_index)
                    {
                      if (_M_index == 0)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_It>)
                	    _M_it = __x._M_it;
                	  else
                	    std::construct_at(std::__addressof(_M_it), __x._M_it);
                	}
                      else if (_M_index == 1)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_Sent>)
                	    _M_sent = __x._M_sent;
                	  else
                	    std::construct_at(std::__addressof(_M_sent), __x._M_sent);
                	}
                    }
                
                    constexpr
                    common_iterator(common_iterator&& __x)
                    noexcept(_S_noexcept<_It, _Sent>())
                    : _M_valueless(), _M_index(__x._M_index)
                    {
                      if (_M_index == 0)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_It>)
                	    _M_it = std::move(__x._M_it);
                	  else
                	    std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
                	}
                      else if (_M_index == 1)
                	{
                	  if constexpr (is_trivially_default_constructible_v<_Sent>)
                	    _M_sent = std::move(__x._M_sent);
                	  else
                	    std::construct_at(std::__addressof(_M_sent),
                			      std::move(__x._M_sent));
                	}
                    }
                
                    constexpr common_iterator&
                    operator=(const common_iterator&) = default;
                
                    constexpr common_iterator&
                    operator=(const common_iterator& __x)
                    noexcept(is_nothrow_copy_assignable_v<_It>
                	     && is_nothrow_copy_assignable_v<_Sent>
                	     && is_nothrow_copy_constructible_v<_It>
                	     && is_nothrow_copy_constructible_v<_Sent>)
                    requires (!is_trivially_copy_assignable_v<_It>
                		|| !is_trivially_copy_assignable_v<_Sent>)
                    {
                      _M_assign(__x);
                      return *this;
                    }
                
                    constexpr common_iterator&
                    operator=(common_iterator&&) = default;
                
                    constexpr common_iterator&
                    operator=(common_iterator&& __x)
                    noexcept(is_nothrow_move_assignable_v<_It>
                	     && is_nothrow_move_assignable_v<_Sent>
                	     && is_nothrow_move_constructible_v<_It>
                	     && is_nothrow_move_constructible_v<_Sent>)
                    requires (!is_trivially_move_assignable_v<_It>
                		|| !is_trivially_move_assignable_v<_Sent>)
                    {
                      _M_assign(std::move(__x));
                      return *this;
                    }
                
                    template<typename _It2, typename _Sent2>
                      requires convertible_to<const _It2&, _It>
                	&& convertible_to<const _Sent2&, _Sent>
                	&& assignable_from<_It&, const _It2&>
                	&& assignable_from<_Sent&, const _Sent2&>
                      constexpr common_iterator&
                      operator=(const common_iterator<_It2, _Sent2>& __x)
                      noexcept(is_nothrow_constructible_v<_It, const _It2&>
                	       && is_nothrow_constructible_v<_Sent, const _Sent2&>
                	       && is_nothrow_assignable_v<_It&, const _It2&>
                	       && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
                      {
                	__glibcxx_assert(__x._M_has_value());
                	_M_assign(__x);
                	return *this;
                      }
                
                    constexpr
                    ~common_iterator()
                    {
                      if (_M_index == 0)
                	_M_it.~_It();
                      else if (_M_index == 1)
                	_M_sent.~_Sent();
                    }
                
                    [[nodiscard]]
                    constexpr decltype(auto)
                    operator*()
                    {
                      __glibcxx_assert(_M_index == 0);
                      return *_M_it;
                    }
                
                    [[nodiscard]]
                    constexpr decltype(auto)
                    operator*() const requires __detail::__dereferenceable<const _It>
                    {
                      __glibcxx_assert(_M_index == 0);
                      return *_M_it;
                    }
                
                    [[nodiscard]]
                    constexpr auto
                    operator->() const requires __detail::__common_iter_has_arrow<_It>
                    {
                      __glibcxx_assert(_M_index == 0);
                      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
                	return _M_it;
                      else if constexpr (is_reference_v<iter_reference_t<_It>>)
                	{
                	  auto&& __tmp = *_M_it;
                	  return std::__addressof(__tmp);
                	}
                      else
                	return __arrow_proxy{*_M_it};
                    }
                
                    constexpr common_iterator&
                    operator++()
                    {
                      __glibcxx_assert(_M_index == 0);
                      ++_M_it;
                      return *this;
                    }
                
                    constexpr decltype(auto)
                    operator++(int)
                    {
                      __glibcxx_assert(_M_index == 0);
                      if constexpr (forward_iterator<_It>)
                	{
                	  common_iterator __tmp = *this;
                	  ++*this;
                	  return __tmp;
                	}
                      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
                	return _M_it++;
                      else
                	{
                	  __postfix_proxy __p(**this);
                	  ++*this;
                	  return __p;
                	}
                    }
                
                    template<typename _It2, sentinel_for<_It> _Sent2>
                      requires sentinel_for<_Sent, _It2>
                      friend constexpr bool
                      operator== [[nodiscard]] (const common_iterator& __x,
                				const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0000:
                	  case 0b0101:
                	    return true;
                	  case 0b0001:
                	    return __x._M_it == __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent == __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    template<typename _It2, sentinel_for<_It> _Sent2>
                      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
                      friend constexpr bool
                      operator== [[nodiscard]] (const common_iterator& __x,
                				const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0101:
                	    return true;
                	  case 0b0000:
                	    return __x._M_it == __y._M_it;
                	  case 0b0001:
                	    return __x._M_it == __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent == __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
                      requires sized_sentinel_for<_Sent, _It2>
                      friend constexpr iter_difference_t<_It2>
                      operator- [[nodiscard]] (const common_iterator& __x,
                			       const common_iterator<_It2, _Sent2>& __y)
                      {
                	switch(__x._M_index << 2 | __y._M_index)
                	  {
                	  case 0b0101:
                	    return 0;
                	  case 0b0000:
                	    return __x._M_it - __y._M_it;
                	  case 0b0001:
                	    return __x._M_it - __y._M_sent;
                	  case 0b0100:
                	    return __x._M_sent - __y._M_it;
                	  default:
                	    __glibcxx_assert(__x._M_has_value());
                	    __glibcxx_assert(__y._M_has_value());
                	    __builtin_unreachable();
                	  }
                      }
                
                    [[nodiscard]]
                    friend constexpr iter_rvalue_reference_t<_It>
                    iter_move(const common_iterator& __i)
                    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
                    requires input_iterator<_It>
                    {
                      __glibcxx_assert(__i._M_index == 0);
                      return ranges::iter_move(__i._M_it);
                    }
                
                    template<indirectly_swappable<_It> _It2, typename _Sent2>
                      friend constexpr void
                      iter_swap(const common_iterator& __x,
                		const common_iterator<_It2, _Sent2>& __y)
                      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
                					  std::declval<const _It2&>())))
                      {
                	__glibcxx_assert(__x._M_index == 0);
                	__glibcxx_assert(__y._M_index == 0);
                	return ranges::iter_swap(__x._M_it, __y._M_it);
                      }
                
                  private:
                    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
                      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
                      friend class common_iterator;
                
                    constexpr bool
                    _M_has_value() const noexcept { return _M_index != _S_valueless; }
                
                    template<typename _CIt>
                      constexpr void
                      _M_assign(_CIt&& __x)
                      {
                	if (_M_index == __x._M_index)
                	  {
                	    if (_M_index == 0)
                	      _M_it = std::forward<_CIt>(__x)._M_it;
                	    else if (_M_index == 1)
                	      _M_sent = std::forward<_CIt>(__x)._M_sent;
                	  }
                	else
                	  {
                	    if (_M_index == 0)
                	      _M_it.~_It();
                	    else if (_M_index == 1)
                	      _M_sent.~_Sent();
                	    _M_index = _S_valueless;
                
                	    if (__x._M_index == 0)
                	      std::construct_at(std::__addressof(_M_it),
                				std::forward<_CIt>(__x)._M_it);
                	    else if (__x._M_index == 1)
                	      std::construct_at(std::__addressof(_M_sent),
                				std::forward<_CIt>(__x)._M_sent);
                	    _M_index = __x._M_index;
                	  }
                      }
                
                    union
                    {
                      _It _M_it;
                      _Sent _M_sent;
                      unsigned char _M_valueless;
                    };
                    unsigned char _M_index; // 0 == _M_it, 1 == _M_sent, 2 == valueless
                
                    static constexpr unsigned char _S_valueless{2};
                  };
                
                  template<typename _It, typename _Sent>
                    struct incrementable_traits<common_iterator<_It, _Sent>>
                    {
                      using difference_type = iter_difference_t<_It>;
                    };
                
                  template<input_iterator _It, typename _Sent>
                    struct iterator_traits<common_iterator<_It, _Sent>>
                    {
                    private:
                      template<typename _Iter>
                	struct __ptr
                	{
                	  using type = void;
                	};
                
                      template<typename _Iter>
                	requires __detail::__common_iter_has_arrow<_Iter>
                	struct __ptr<_Iter>
                	{
                	  using _CIter = common_iterator<_Iter, _Sent>;
                	  using type = decltype(std::declval<const _CIter&>().operator->());
                	};
                
                      static auto
                      _S_iter_cat()
                      {
                	using _Traits = iterator_traits<_It>;
                	if constexpr (requires { requires derived_from<typename _Traits::iterator_category,
                						       forward_iterator_tag>; })
                	  return forward_iterator_tag{};
                	else
                	  return input_iterator_tag{};
                      }
                
                    public:
                      using iterator_concept = conditional_t<forward_iterator<_It>,
                	    forward_iterator_tag, input_iterator_tag>;
                      using iterator_category = decltype(_S_iter_cat());
                      using value_type = iter_value_t<_It>;
                      using difference_type = iter_difference_t<_It>;
                      using pointer = typename __ptr<_It>::type;
                      using reference = iter_reference_t<_It>;
                    };
                
                  // [iterators.counted] Counted iterators
                
                  namespace __detail
                  {
                    template<typename _It>
                      struct __counted_iter_value_type
                      { };
                
                    template<indirectly_readable _It>
                      struct __counted_iter_value_type<_It>
                      { using value_type = iter_value_t<_It>; };
                
                    template<typename _It>
                      struct __counted_iter_concept
                      { };
                
                    template<typename _It>
                      requires requires { typename _It::iterator_concept; }
                      struct __counted_iter_concept<_It>
                      { using iterator_concept = typename _It::iterator_concept; };
                
                    template<typename _It>
                      struct __counted_iter_cat
                      { };
                
                    template<typename _It>
                      requires requires { typename _It::iterator_category; }
                      struct __counted_iter_cat<_It>
                      { using iterator_category = typename _It::iterator_category; };
                  }
                
                  /// An iterator adaptor that keeps track of the distance to the end.
                  template<input_or_output_iterator _It>
                    class counted_iterator
                      : public __detail::__counted_iter_value_type<_It>,
                	public __detail::__counted_iter_concept<_It>,
                	public __detail::__counted_iter_cat<_It>
                    {
                    public:
                      using iterator_type = _It;
                      // value_type defined in __counted_iter_value_type
                      using difference_type = iter_difference_t<_It>;
                      // iterator_concept defined in __counted_iter_concept
                      // iterator_category defined in __counted_iter_cat
                
                      constexpr counted_iterator() requires default_initializable<_It> = default;
                
                      constexpr
                      counted_iterator(_It __i, iter_difference_t<_It> __n)
                      : _M_current(std::move(__i)), _M_length(__n)
                      { __glibcxx_assert(__n >= 0); }
                
                      template<typename _It2>
                	requires convertible_to<const _It2&, _It>
                	constexpr
                	counted_iterator(const counted_iterator<_It2>& __x)
                	: _M_current(__x._M_current), _M_length(__x._M_length)
                	{ }
                
                      template<typename _It2>
                	requires assignable_from<_It&, const _It2&>
                	constexpr counted_iterator&
                	operator=(const counted_iterator<_It2>& __x)
                	{
                	  _M_current = __x._M_current;
                	  _M_length = __x._M_length;
                	  return *this;
                	}
                
                      constexpr const _It&
                      base() const & noexcept
                      { return _M_current; }
                
                      constexpr _It
                      base() &&
                      noexcept(is_nothrow_move_constructible_v<_It>)
                      { return std::move(_M_current); }
                
                      constexpr iter_difference_t<_It>
                      count() const noexcept { return _M_length; }
                
                      constexpr decltype(auto)
                      operator*()
                      noexcept(noexcept(*_M_current))
                      {
                	__glibcxx_assert( _M_length > 0 );
                	return *_M_current;
                      }
                
                      constexpr decltype(auto)
                      operator*() const
                      noexcept(noexcept(*_M_current))
                      requires __detail::__dereferenceable<const _It>
                      {
                	__glibcxx_assert( _M_length > 0 );
                	return *_M_current;
                      }
                
                      constexpr auto
                      operator->() const noexcept
                      requires contiguous_iterator<_It>
                      { return std::to_address(_M_current); }
                
                      constexpr counted_iterator&
                      operator++()
                      {
                	__glibcxx_assert(_M_length > 0);
                	++_M_current;
                	--_M_length;
                	return *this;
                      }
                
                      constexpr decltype(auto)
                      operator++(int)
                      {
                	__glibcxx_assert(_M_length > 0);
                	--_M_length;
                	__try
                	  {
                	    return _M_current++;
                	  } __catch(...) {
                	    ++_M_length;
                	    __throw_exception_again;
                	  }
                      }
                
                      constexpr counted_iterator
                      operator++(int) requires forward_iterator<_It>
                      {
                	auto __tmp = *this;
                	++*this;
                	return __tmp;
                      }
                
                      constexpr counted_iterator&
                      operator--() requires bidirectional_iterator<_It>
                      {
                	--_M_current;
                	++_M_length;
                	return *this;
                      }
                
                      constexpr counted_iterator
                      operator--(int) requires bidirectional_iterator<_It>
                      {
                	auto __tmp = *this;
                	--*this;
                	return __tmp;
                      }
                
                      constexpr counted_iterator
                      operator+(iter_difference_t<_It> __n) const
                	requires random_access_iterator<_It>
                      { return counted_iterator(_M_current + __n, _M_length - __n); }
                
                      friend constexpr counted_iterator
                      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
                      requires random_access_iterator<_It>
                      { return __x + __n; }
                
                      constexpr counted_iterator&
                      operator+=(iter_difference_t<_It> __n)
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(__n <= _M_length);
                	_M_current += __n;
                	_M_length -= __n;
                	return *this;
                      }
                
                      constexpr counted_iterator
                      operator-(iter_difference_t<_It> __n) const
                      requires random_access_iterator<_It>
                      { return counted_iterator(_M_current - __n, _M_length + __n); }
                
                      template<common_with<_It> _It2>
                	friend constexpr iter_difference_t<_It2>
                	operator-(const counted_iterator& __x,
                		  const counted_iterator<_It2>& __y)
                	{ return __y._M_length - __x._M_length; }
                
                      friend constexpr iter_difference_t<_It>
                      operator-(const counted_iterator& __x, default_sentinel_t)
                      { return -__x._M_length; }
                
                      friend constexpr iter_difference_t<_It>
                      operator-(default_sentinel_t, const counted_iterator& __y)
                      { return __y._M_length; }
                
                      constexpr counted_iterator&
                      operator-=(iter_difference_t<_It> __n)
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(-__n <= _M_length);
                	_M_current -= __n;
                	_M_length += __n;
                	return *this;
                      }
                
                      constexpr decltype(auto)
                      operator[](iter_difference_t<_It> __n) const
                      noexcept(noexcept(_M_current[__n]))
                      requires random_access_iterator<_It>
                      {
                	__glibcxx_assert(__n < _M_length);
                	return _M_current[__n];
                      }
                
                      template<common_with<_It> _It2>
                	friend constexpr bool
                	operator==(const counted_iterator& __x,
                		   const counted_iterator<_It2>& __y)
                	{ return __x._M_length == __y._M_length; }
                
                      friend constexpr bool
                      operator==(const counted_iterator& __x, default_sentinel_t)
                      { return __x._M_length == 0; }
                
                      template<common_with<_It> _It2>
                	friend constexpr strong_ordering
                	operator<=>(const counted_iterator& __x,
                		    const counted_iterator<_It2>& __y)
                	{ return __y._M_length <=> __x._M_length; }
                
                      friend constexpr iter_rvalue_reference_t<_It>
                      iter_move(const counted_iterator& __i)
                      noexcept(noexcept(ranges::iter_move(__i._M_current)))
                      requires input_iterator<_It>
                      {
                	__glibcxx_assert( __i._M_length > 0 );
                	return ranges::iter_move(__i._M_current);
                      }
                
                      template<indirectly_swappable<_It> _It2>
                	friend constexpr void
                	iter_swap(const counted_iterator& __x,
                		  const counted_iterator<_It2>& __y)
                	noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
                	{
                	  __glibcxx_assert( __x._M_length > 0 && __y._M_length > 0 );
                	  ranges::iter_swap(__x._M_current, __y._M_current);
                	}
                
                    private:
                      template<input_or_output_iterator _It2> friend class counted_iterator;
                
                      _It _M_current = _It();
                      iter_difference_t<_It> _M_length = 0;
                    };
                
                  template<input_iterator _It>
                    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
                    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
                    {
                      using pointer = conditional_t<contiguous_iterator<_It>,
                				    add_pointer_t<iter_reference_t<_It>>,
                				    void>;
                    };
                #endif // C++20
                
                  /// @} group iterators
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __niter_base(move_iterator<_Iterator> __it)
                    -> decltype(make_move_iterator(__niter_base(__it.base())))
                    { return make_move_iterator(__niter_base(__it.base())); }
                
                  template<typename _Iterator>
                    struct __is_move_iterator<move_iterator<_Iterator> >
                    {
                      enum { __value = 1 };
                      typedef __true_type __type;
                    };
                
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    auto
                    __miter_base(move_iterator<_Iterator> __it)
                    -> decltype(__miter_base(__it.base()))
                    { return __miter_base(__it.base()); }
                
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) std::make_move_iterator(_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) \
                  std::__make_move_if_noexcept_iterator(_Iter)
                #else
                #define _GLIBCXX_MAKE_MOVE_ITERATOR(_Iter) (_Iter)
                #define _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(_Iter) (_Iter)
                #endif // C++11
                
                #if __cpp_deduction_guides >= 201606
                  // These helper traits are used for deduction guides
                  // of associative containers.
                  template<typename _InputIterator>
                    using __iter_key_t = remove_const_t<
                    typename iterator_traits<_InputIterator>::value_type::first_type>;
                
                  template<typename _InputIterator>
                    using __iter_val_t =
                    typename iterator_traits<_InputIterator>::value_type::second_type;
                
                  template<typename _T1, typename _T2>
                    struct pair;
                
                  template<typename _InputIterator>
                    using __iter_to_alloc_t =
                    pair<add_const_t<__iter_key_t<_InputIterator>>,
                	 __iter_val_t<_InputIterator>>;
                #endif // __cpp_deduction_guides
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace
                
                #ifdef _GLIBCXX_DEBUG
                # include <debug/stl_iterator.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

     1105     876223
     1027     451676
     1179     313744
     1042     284204
     1052     219203
     1100      64239
     1268      62708
     1723      18604
     1090       9842
     1033       3699

Execution Summary:

       14   Executable lines in this file
       14   Lines executed
   100.00   Percent of the file executed

  2308384   Total number of line executions
164884.57   Average executions per line


*** File /usr/include/c++/11/optional:
                // <optional> -*- C++ -*-
                
                // Copyright (C) 2013-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /** @file include/optional
                 *  This is a Standard C++ Library header.
                 */
                
                #ifndef _GLIBCXX_OPTIONAL
                #define _GLIBCXX_OPTIONAL 1
                
                #pragma GCC system_header
                
                #if __cplusplus >= 201703L
                
                #include <utility>
                #include <type_traits>
                #include <exception>
                #include <new>
                #include <initializer_list>
                #include <bits/enable_special_members.h>
                #include <bits/exception_defines.h>
                #include <bits/functional_hash.h>
                #include <bits/stl_construct.h> // _Construct
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /**
                   *  @addtogroup utilities
                   *  @{
                   */
                
                #if __cplusplus == 201703L
                # define __cpp_lib_optional 201606L
                #else
                # define __cpp_lib_optional 202106L
                #endif
                
                  template<typename _Tp>
                    class optional;
                
                  /// Tag type to disengage optional objects.
                  struct nullopt_t
                  {
                    // Do not user-declare default constructor at all for
                    // optional_value = {} syntax to work.
                    // nullopt_t() = delete;
                
                    // Used for constructing nullopt.
                    enum class _Construct { _Token };
                
                    // Must be constexpr for nullopt_t to be literal.
                    explicit constexpr nullopt_t(_Construct) noexcept { }
                  };
                
                  /// Tag to disengage optional objects.
                  inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };
                
                  /**
                   *  @brief Exception class thrown when a disengaged optional object is
                   *  dereferenced.
                   *  @ingroup exceptions
                   */
                  class bad_optional_access : public exception
                  {
                  public:
       ##### ->     bad_optional_access() = default;
       ##### ->     virtual ~bad_optional_access() = default;
                
       ##### ->     const char* what() const noexcept override
                    { return "bad optional access"; }
                  };
                
                  // XXX Does not belong here.
                  [[__noreturn__]] inline void
                  __throw_bad_optional_access()
       ##### ->   { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }
                
                  // This class template manages construction/destruction of
                  // the contained value for a std::optional.
                  template <typename _Tp>
                    struct _Optional_payload_base
                    {
                      using _Stored_type = remove_const_t<_Tp>;
                
        1110 ->       _Optional_payload_base() = default;
                      ~_Optional_payload_base() = default;
                
                      template<typename... _Args>
                	constexpr
        1110 -> 	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
                	: _M_payload(__tag, std::forward<_Args>(__args)...),
                	  _M_engaged(true)
                	{ }
                
                      template<typename _Up, typename... _Args>
                	constexpr
                	_Optional_payload_base(std::initializer_list<_Up> __il,
                			       _Args&&... __args)
                	: _M_payload(__il, std::forward<_Args>(__args)...),
                	  _M_engaged(true)
                	{ }
                
                      // Constructor used by _Optional_base copy constructor when the
                      // contained value is not trivially copy constructible.
                      constexpr
                      _Optional_payload_base(bool __engaged,
                			     const _Optional_payload_base& __other)
                      {
                	if (__other._M_engaged)
                	  this->_M_construct(__other._M_get());
                      }
                
                      // Constructor used by _Optional_base move constructor when the
                      // contained value is not trivially move constructible.
                      constexpr
                      _Optional_payload_base(bool __engaged,
                			     _Optional_payload_base&& __other)
                      {
                	if (__other._M_engaged)
                	  this->_M_construct(std::move(__other._M_get()));
                      }
                
                      // Copy constructor is only used to when the contained value is
                      // trivially copy constructible.
                      _Optional_payload_base(const _Optional_payload_base&) = default;
                
                      // Move constructor is only used to when the contained value is
                      // trivially copy constructible.
                      _Optional_payload_base(_Optional_payload_base&&) = default;
                
                      _Optional_payload_base&
                      operator=(const _Optional_payload_base&) = default;
                
                      _Optional_payload_base&
                      operator=(_Optional_payload_base&&) = default;
                
                      // used to perform non-trivial copy assignment.
                      constexpr void
                      _M_copy_assign(const _Optional_payload_base& __other)
                      {
                	if (this->_M_engaged && __other._M_engaged)
                	  this->_M_get() = __other._M_get();
                	else
                	  {
                	    if (__other._M_engaged)
                	      this->_M_construct(__other._M_get());
                	    else
                	      this->_M_reset();
                	  }
                      }
                
                      // used to perform non-trivial move assignment.
                      constexpr void
                      _M_move_assign(_Optional_payload_base&& __other)
                      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
                		       is_nothrow_move_assignable<_Tp>>)
                      {
                	if (this->_M_engaged && __other._M_engaged)
                	  this->_M_get() = std::move(__other._M_get());
                	else
                	  {
                	    if (__other._M_engaged)
                	      this->_M_construct(std::move(__other._M_get()));
                	    else
                	      this->_M_reset();
                	  }
                      }
                
                      struct _Empty_byte { };
                
                      template<typename _Up, bool = is_trivially_destructible_v<_Up>>
                	union _Storage
                	{
        1110 -> 	  constexpr _Storage() noexcept : _M_empty() { }
                
                	  template<typename... _Args>
                	    constexpr
        1110 -> 	    _Storage(in_place_t, _Args&&... __args)
                	    : _M_value(std::forward<_Args>(__args)...)
                	    { }
                
                	  template<typename _Vp, typename... _Args>
                	    constexpr
                	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
                	    : _M_value(__il, std::forward<_Args>(__args)...)
                	    { }
                
                	  _Empty_byte _M_empty;
                	  _Up _M_value;
                	};
                
                      template<typename _Up>
                	union _Storage<_Up, false>
                	{
                	  constexpr _Storage() noexcept : _M_empty() { }
                
                	  template<typename... _Args>
                	    constexpr
                	    _Storage(in_place_t, _Args&&... __args)
                	    : _M_value(std::forward<_Args>(__args)...)
                	    { }
                
                	  template<typename _Vp, typename... _Args>
                	    constexpr
                	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
                	    : _M_value(__il, std::forward<_Args>(__args)...)
                	    { }
                
                	  // User-provided destructor is needed when _Up has non-trivial dtor.
                	  _GLIBCXX20_CONSTEXPR ~_Storage() { }
                
                	  _Empty_byte _M_empty;
                	  _Up _M_value;
                	};
                
                      _Storage<_Stored_type> _M_payload;
                
                      bool _M_engaged = false;
                
                      template<typename... _Args>
                	constexpr void
                	_M_construct(_Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
                	{
                	  std::_Construct(std::__addressof(this->_M_payload._M_value),
                			  std::forward<_Args>(__args)...);
                	  this->_M_engaged = true;
                	}
                
                      constexpr void
                      _M_destroy() noexcept
                      {
                	_M_engaged = false;
                	_M_payload._M_value.~_Stored_type();
                      }
                
                      // The _M_get() operations have _M_engaged as a precondition.
                      // They exist to access the contained value with the appropriate
                      // const-qualification, because _M_payload has had the const removed.
                
                      constexpr _Tp&
        1249 ->       _M_get() noexcept
                      { return this->_M_payload._M_value; }
                
                      constexpr const _Tp&
                      _M_get() const noexcept
                      { return this->_M_payload._M_value; }
                
                      // _M_reset is a 'safe' operation with no precondition.
                      constexpr void
                      _M_reset() noexcept
                      {
                	if (this->_M_engaged)
                	  _M_destroy();
                      }
                    };
                
                  // Class template that manages the payload for optionals.
                  template <typename _Tp,
                	    bool /*_HasTrivialDestructor*/ =
                	      is_trivially_destructible_v<_Tp>,
                	    bool /*_HasTrivialCopy */ =
                	      is_trivially_copy_assignable_v<_Tp>
                	      && is_trivially_copy_constructible_v<_Tp>,
                	    bool /*_HasTrivialMove */ =
                	      is_trivially_move_assignable_v<_Tp>
                	      && is_trivially_move_constructible_v<_Tp>>
                    struct _Optional_payload;
                
                  // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
                  template <typename _Tp>
                    struct _Optional_payload<_Tp, true, true, true>
                    : _Optional_payload_base<_Tp>
                    {
        1110 ->       using _Optional_payload_base<_Tp>::_Optional_payload_base;
                
        1110 ->       _Optional_payload() = default;
                    };
                
                  // Payload for optionals with non-trivial copy construction/assignment.
                  template <typename _Tp>
                    struct _Optional_payload<_Tp, true, false, true>
                    : _Optional_payload_base<_Tp>
                    {
                      using _Optional_payload_base<_Tp>::_Optional_payload_base;
                
                      _Optional_payload() = default;
                      ~_Optional_payload() = default;
                      _Optional_payload(const _Optional_payload&) = default;
                      _Optional_payload(_Optional_payload&&) = default;
                      _Optional_payload& operator=(_Optional_payload&&) = default;
                
                      // Non-trivial copy assignment.
                      constexpr
                      _Optional_payload&
                      operator=(const _Optional_payload& __other)
                      {
                	this->_M_copy_assign(__other);
                	return *this;
                      }
                    };
                
                  // Payload for optionals with non-trivial move construction/assignment.
                  template <typename _Tp>
                    struct _Optional_payload<_Tp, true, true, false>
                    : _Optional_payload_base<_Tp>
                    {
                      using _Optional_payload_base<_Tp>::_Optional_payload_base;
                
                      _Optional_payload() = default;
                      ~_Optional_payload() = default;
                      _Optional_payload(const _Optional_payload&) = default;
                      _Optional_payload(_Optional_payload&&) = default;
                      _Optional_payload& operator=(const _Optional_payload&) = default;
                
                      // Non-trivial move assignment.
                      constexpr
                      _Optional_payload&
                      operator=(_Optional_payload&& __other)
                      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
                		       is_nothrow_move_assignable<_Tp>>)
                      {
                	this->_M_move_assign(std::move(__other));
                	return *this;
                      }
                    };
                
                  // Payload for optionals with non-trivial copy and move assignment.
                  template <typename _Tp>
                    struct _Optional_payload<_Tp, true, false, false>
                    : _Optional_payload_base<_Tp>
                    {
                      using _Optional_payload_base<_Tp>::_Optional_payload_base;
                
                      _Optional_payload() = default;
                      ~_Optional_payload() = default;
                      _Optional_payload(const _Optional_payload&) = default;
                      _Optional_payload(_Optional_payload&&) = default;
                
                      // Non-trivial copy assignment.
                      constexpr
                      _Optional_payload&
                      operator=(const _Optional_payload& __other)
                      {
                	this->_M_copy_assign(__other);
                	return *this;
                      }
                
                      // Non-trivial move assignment.
                      constexpr
                      _Optional_payload&
                      operator=(_Optional_payload&& __other)
                      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
                		       is_nothrow_move_assignable<_Tp>>)
                      {
                	this->_M_move_assign(std::move(__other));
                	return *this;
                      }
                    };
                
                  // Payload for optionals with non-trivial destructors.
                  template <typename _Tp, bool _Copy, bool _Move>
                    struct _Optional_payload<_Tp, false, _Copy, _Move>
                    : _Optional_payload<_Tp, true, false, false>
                    {
                      // Base class implements all the constructors and assignment operators:
                      using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
                      _Optional_payload() = default;
                      _Optional_payload(const _Optional_payload&) = default;
                      _Optional_payload(_Optional_payload&&) = default;
                      _Optional_payload& operator=(const _Optional_payload&) = default;
                      _Optional_payload& operator=(_Optional_payload&&) = default;
                
                      // Destructor needs to destroy the contained value:
                      _GLIBCXX20_CONSTEXPR ~_Optional_payload() { this->_M_reset(); }
                    };
                
                  // Common base class for _Optional_base<T> to avoid repeating these
                  // member functions in each specialization.
                  template<typename _Tp, typename _Dp>
                    class _Optional_base_impl
                    {
                    protected:
                      using _Stored_type = remove_const_t<_Tp>;
                
                      // The _M_construct operation has !_M_engaged as a precondition
                      // while _M_destruct has _M_engaged as a precondition.
                      template<typename... _Args>
                	constexpr void
                	_M_construct(_Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
                	{
                	  static_cast<_Dp*>(this)->_M_payload._M_construct(
                	    std::forward<_Args>(__args)...);
                	}
                
                      constexpr void
                      _M_destruct() noexcept
                      { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }
                
                      // _M_reset is a 'safe' operation with no precondition.
                      constexpr void
                      _M_reset() noexcept
                      { static_cast<_Dp*>(this)->_M_payload._M_reset(); }
                
        2498 ->       constexpr bool _M_is_engaged() const noexcept
                      { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }
                
                      // The _M_get operations have _M_engaged as a precondition.
                      constexpr _Tp&
        1249 ->       _M_get() noexcept
                      {
                	__glibcxx_assert(this->_M_is_engaged());
                	return static_cast<_Dp*>(this)->_M_payload._M_get();
                      }
                
                      constexpr const _Tp&
                      _M_get() const noexcept
                      {
                	__glibcxx_assert(this->_M_is_engaged());
                	return static_cast<const _Dp*>(this)->_M_payload._M_get();
                      }
                    };
                
                  /**
                    * @brief Class template that provides copy/move constructors of optional.
                    *
                    * Such a separate base class template is necessary in order to
                    * conditionally make copy/move constructors trivial.
                    *
                    * When the contained value is trivially copy/move constructible,
                    * the copy/move constructors of _Optional_base will invoke the
                    * trivial copy/move constructor of _Optional_payload. Otherwise,
                    * they will invoke _Optional_payload(bool, const _Optional_payload&)
                    * or _Optional_payload(bool, _Optional_payload&&) to initialize
                    * the contained value, if copying/moving an engaged optional.
                    *
                    * Whether the other special members are trivial is determined by the
                    * _Optional_payload<_Tp> specialization used for the _M_payload member.
                    *
                    * @see optional, _Enable_special_members
                    */
                  template<typename _Tp,
                	   bool = is_trivially_copy_constructible_v<_Tp>,
                	   bool = is_trivially_move_constructible_v<_Tp>>
                    struct _Optional_base
                    : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
                    {
                      // Constructors for disengaged optionals.
                      constexpr _Optional_base() = default;
                
                      // Constructors for engaged optionals.
                      template<typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t, _Args&&... __args)
                	: _M_payload(in_place, std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename _Up, typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp,
                					      initializer_list<_Up>&,
                					      _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t,
                		       initializer_list<_Up> __il,
                		       _Args&&... __args)
                	: _M_payload(in_place, __il, std::forward<_Args>(__args)...)
                	{ }
                
                      // Copy and move constructors.
                      constexpr
                      _Optional_base(const _Optional_base& __other)
                      : _M_payload(__other._M_payload._M_engaged, __other._M_payload)
                      { }
                
                      constexpr
                      _Optional_base(_Optional_base&& __other)
                      noexcept(is_nothrow_move_constructible_v<_Tp>)
                      : _M_payload(__other._M_payload._M_engaged,
                		   std::move(__other._M_payload))
                      { }
                
                      // Assignment operators.
                      _Optional_base& operator=(const _Optional_base&) = default;
                      _Optional_base& operator=(_Optional_base&&) = default;
                
                      _Optional_payload<_Tp> _M_payload;
                    };
                
                  template<typename _Tp>
                    struct _Optional_base<_Tp, false, true>
                    : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
                    {
                      // Constructors for disengaged optionals.
                      constexpr _Optional_base() = default;
                
                      // Constructors for engaged optionals.
                      template<typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t, _Args&&... __args)
                	: _M_payload(in_place, std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename _Up, typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp,
                					      initializer_list<_Up>&,
                					      _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t,
                		       initializer_list<_Up> __il,
                		       _Args... __args)
                	: _M_payload(in_place, __il, std::forward<_Args>(__args)...)
                	{ }
                
                      // Copy and move constructors.
                      constexpr _Optional_base(const _Optional_base& __other)
                      : _M_payload(__other._M_payload._M_engaged, __other._M_payload)
                      { }
                
                      constexpr _Optional_base(_Optional_base&& __other) = default;
                
                      // Assignment operators.
                      _Optional_base& operator=(const _Optional_base&) = default;
                      _Optional_base& operator=(_Optional_base&&) = default;
                
                      _Optional_payload<_Tp> _M_payload;
                    };
                
                  template<typename _Tp>
                    struct _Optional_base<_Tp, true, false>
                    : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
                    {
                      // Constructors for disengaged optionals.
                      constexpr _Optional_base() = default;
                
                      // Constructors for engaged optionals.
                      template<typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t, _Args&&... __args)
                	: _M_payload(in_place, std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename _Up, typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp,
                					      initializer_list<_Up>&,
                					      _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t,
                		       initializer_list<_Up> __il,
                		       _Args&&... __args)
                	: _M_payload(in_place, __il, std::forward<_Args>(__args)...)
                	{ }
                
                      // Copy and move constructors.
                      constexpr _Optional_base(const _Optional_base& __other) = default;
                
                      constexpr
                      _Optional_base(_Optional_base&& __other)
                      noexcept(is_nothrow_move_constructible_v<_Tp>)
                      : _M_payload(__other._M_payload._M_engaged,
                		   std::move(__other._M_payload))
                      { }
                
                      // Assignment operators.
                      _Optional_base& operator=(const _Optional_base&) = default;
                      _Optional_base& operator=(_Optional_base&&) = default;
                
                      _Optional_payload<_Tp> _M_payload;
                    };
                
                  template<typename _Tp>
                    struct _Optional_base<_Tp, true, true>
                    : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
                    {
                      // Constructors for disengaged optionals.
        1110 ->       constexpr _Optional_base() = default;
                
                      // Constructors for engaged optionals.
                      template<typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp, _Args...>, bool> = false>
                	constexpr explicit
        1110 -> 	_Optional_base(in_place_t, _Args&&... __args)
                	: _M_payload(in_place, std::forward<_Args>(__args)...)
                	{ }
                
                      template<typename _Up, typename... _Args,
                	       enable_if_t<is_constructible_v<_Tp,
                					      initializer_list<_Up>&,
                					      _Args...>, bool> = false>
                	constexpr explicit
                	_Optional_base(in_place_t,
                		       initializer_list<_Up> __il,
                		       _Args&&... __args)
                	: _M_payload(in_place, __il, std::forward<_Args>(__args)...)
                	{ }
                
                      // Copy and move constructors.
                      constexpr _Optional_base(const _Optional_base& __other) = default;
                      constexpr _Optional_base(_Optional_base&& __other) = default;
                
                      // Assignment operators.
                      _Optional_base& operator=(const _Optional_base&) = default;
                      _Optional_base& operator=(_Optional_base&&) = default;
                
                      _Optional_payload<_Tp> _M_payload;
                    };
                
                  template<typename _Tp>
                  class optional;
                
                  template<typename _Tp, typename _Up>
                    using __converts_from_optional =
                      __or_<is_constructible<_Tp, const optional<_Up>&>,
                	    is_constructible<_Tp, optional<_Up>&>,
                	    is_constructible<_Tp, const optional<_Up>&&>,
                	    is_constructible<_Tp, optional<_Up>&&>,
                	    is_convertible<const optional<_Up>&, _Tp>,
                	    is_convertible<optional<_Up>&, _Tp>,
                	    is_convertible<const optional<_Up>&&, _Tp>,
                	    is_convertible<optional<_Up>&&, _Tp>>;
                
                  template<typename _Tp, typename _Up>
                    using __assigns_from_optional =
                      __or_<is_assignable<_Tp&, const optional<_Up>&>,
                	    is_assignable<_Tp&, optional<_Up>&>,
                	    is_assignable<_Tp&, const optional<_Up>&&>,
                	    is_assignable<_Tp&, optional<_Up>&&>>;
                
                  /**
                    * @brief Class template for optional values.
                    */
                  template<typename _Tp>
                    class optional
                    : private _Optional_base<_Tp>,
                      private _Enable_copy_move<
                	// Copy constructor.
                	is_copy_constructible_v<_Tp>,
                	// Copy assignment.
                	__and_v<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>,
                	// Move constructor.
                	is_move_constructible_v<_Tp>,
                	// Move assignment.
                	__and_v<is_move_constructible<_Tp>, is_move_assignable<_Tp>>,
                	// Unique tag type.
                	optional<_Tp>>
                    {
                      static_assert(!is_same_v<remove_cv_t<_Tp>, nullopt_t>);
                      static_assert(!is_same_v<remove_cv_t<_Tp>, in_place_t>);
                      static_assert(!is_reference_v<_Tp>);
                
                    private:
                      using _Base = _Optional_base<_Tp>;
                
                      // SFINAE helpers
                      template<typename _Up>
                	using __not_self = __not_<is_same<optional, __remove_cvref_t<_Up>>>;
                      template<typename _Up>
                	using __not_tag = __not_<is_same<in_place_t, __remove_cvref_t<_Up>>>;
                      template<typename... _Cond>
                	using _Requires = enable_if_t<__and_v<_Cond...>, bool>;
                
                    public:
                      using value_type = _Tp;
                
        1110 ->       constexpr optional() noexcept { }
                
       ##### ->       constexpr optional(nullopt_t) noexcept { }
                
                      // Converting constructors for engaged optionals.
                      template<typename _Up = _Tp,
                	       _Requires<__not_self<_Up>, __not_tag<_Up>,
                			 is_constructible<_Tp, _Up>,
                			 is_convertible<_Up, _Tp>> = true>
                	constexpr
        1110 -> 	optional(_Up&& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, _Up>)
                	: _Base(std::in_place, std::forward<_Up>(__t)) { }
                
                      template<typename _Up = _Tp,
                	       _Requires<__not_self<_Up>, __not_tag<_Up>,
                			 is_constructible<_Tp, _Up>,
                			 __not_<is_convertible<_Up, _Tp>>> = false>
                	explicit constexpr
                	optional(_Up&& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, _Up>)
                	: _Base(std::in_place, std::forward<_Up>(__t)) { }
                
                      template<typename _Up,
                	       _Requires<__not_<is_same<_Tp, _Up>>,
                			 is_constructible<_Tp, const _Up&>,
                			 is_convertible<const _Up&, _Tp>,
                			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
                	constexpr
                	optional(const optional<_Up>& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, const _Up&>)
                	{
                	  if (__t)
                	    emplace(*__t);
                	}
                
                      template<typename _Up,
                	       _Requires<__not_<is_same<_Tp, _Up>>,
                			 is_constructible<_Tp, const _Up&>,
                			 __not_<is_convertible<const _Up&, _Tp>>,
                			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
                	explicit constexpr
                	optional(const optional<_Up>& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, const _Up&>)
                	{
                	  if (__t)
                	    emplace(*__t);
                	}
                
                      template<typename _Up,
                	       _Requires<__not_<is_same<_Tp, _Up>>,
                			 is_constructible<_Tp, _Up>,
                			 is_convertible<_Up, _Tp>,
                			 __not_<__converts_from_optional<_Tp, _Up>>> = true>
                	constexpr
                	optional(optional<_Up>&& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, _Up>)
                	{
                	  if (__t)
                	    emplace(std::move(*__t));
                	}
                
                      template<typename _Up,
                	       _Requires<__not_<is_same<_Tp, _Up>>,
                			 is_constructible<_Tp, _Up>,
                			 __not_<is_convertible<_Up, _Tp>>,
                			 __not_<__converts_from_optional<_Tp, _Up>>> = false>
                	explicit constexpr
                	optional(optional<_Up>&& __t)
                	noexcept(is_nothrow_constructible_v<_Tp, _Up>)
                	{
                	  if (__t)
                	    emplace(std::move(*__t));
                	}
                
                      template<typename... _Args,
                	       _Requires<is_constructible<_Tp, _Args...>> = false>
                	explicit constexpr
                	optional(in_place_t, _Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Tp, _Args...>)
                	: _Base(std::in_place, std::forward<_Args>(__args)...) { }
                
                      template<typename _Up, typename... _Args,
                	       _Requires<is_constructible<_Tp,
                					  initializer_list<_Up>&,
                					  _Args...>> = false>
                	explicit constexpr
                	optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Tp, initializer_list<_Up>&,
                					    _Args...>)
                	: _Base(std::in_place, __il, std::forward<_Args>(__args)...) { }
                
                
                      // Assignment operators.
                      _GLIBCXX20_CONSTEXPR optional&
                      operator=(nullopt_t) noexcept
                      {
                	this->_M_reset();
                	return *this;
                      }
                
                      template<typename _Up = _Tp>
                	_GLIBCXX20_CONSTEXPR
                	enable_if_t<__and_v<__not_self<_Up>,
                			    __not_<__and_<is_scalar<_Tp>,
                					  is_same<_Tp, decay_t<_Up>>>>,
                			    is_constructible<_Tp, _Up>,
                			    is_assignable<_Tp&, _Up>>,
                		    optional&>
                	operator=(_Up&& __u)
                	noexcept(__and_v<is_nothrow_constructible<_Tp, _Up>,
                			 is_nothrow_assignable<_Tp&, _Up>>)
                	{
                	  if (this->_M_is_engaged())
                	    this->_M_get() = std::forward<_Up>(__u);
                	  else
                	    this->_M_construct(std::forward<_Up>(__u));
                
                	  return *this;
                	}
                
                      template<typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
                			    is_constructible<_Tp, const _Up&>,
                			    is_assignable<_Tp&, const _Up&>,
                			    __not_<__converts_from_optional<_Tp, _Up>>,
                			    __not_<__assigns_from_optional<_Tp, _Up>>>,
                		    optional&>
                	operator=(const optional<_Up>& __u)
                	noexcept(__and_v<is_nothrow_constructible<_Tp, const _Up&>,
                			 is_nothrow_assignable<_Tp&, const _Up&>>)
                	{
                	  if (__u)
                	    {
                	      if (this->_M_is_engaged())
                		this->_M_get() = *__u;
                	      else
                		this->_M_construct(*__u);
                	    }
                	  else
                	    {
                	      this->_M_reset();
                	    }
                	  return *this;
                	}
                
                      template<typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	enable_if_t<__and_v<__not_<is_same<_Tp, _Up>>,
                			    is_constructible<_Tp, _Up>,
                			    is_assignable<_Tp&, _Up>,
                			    __not_<__converts_from_optional<_Tp, _Up>>,
                			    __not_<__assigns_from_optional<_Tp, _Up>>>,
                		    optional&>
                	operator=(optional<_Up>&& __u)
                	noexcept(__and_v<is_nothrow_constructible<_Tp, _Up>,
                			 is_nothrow_assignable<_Tp&, _Up>>)
                	{
                	  if (__u)
                	    {
                	      if (this->_M_is_engaged())
                		this->_M_get() = std::move(*__u);
                	      else
                		this->_M_construct(std::move(*__u));
                	    }
                	  else
                	    {
                	      this->_M_reset();
                	    }
                
                	  return *this;
                	}
                
                      template<typename... _Args>
                	_GLIBCXX20_CONSTEXPR
                	enable_if_t<is_constructible_v<_Tp, _Args...>, _Tp&>
                	emplace(_Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Tp, _Args...>)
                	{
                	  this->_M_reset();
                	  this->_M_construct(std::forward<_Args>(__args)...);
                	  return this->_M_get();
                	}
                
                      template<typename _Up, typename... _Args>
                	_GLIBCXX20_CONSTEXPR
                	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                		    _Tp&>
                	emplace(initializer_list<_Up> __il, _Args&&... __args)
                	noexcept(is_nothrow_constructible_v<_Tp, initializer_list<_Up>&,
                					    _Args...>)
                	{
                	  this->_M_reset();
                	  this->_M_construct(__il, std::forward<_Args>(__args)...);
                	  return this->_M_get();
                	}
                
                      // Destructor is implicit, implemented in _Optional_base.
                
                      // Swap.
                      _GLIBCXX20_CONSTEXPR void
                      swap(optional& __other)
                      noexcept(is_nothrow_move_constructible_v<_Tp>
                	       && is_nothrow_swappable_v<_Tp>)
                      {
                	using std::swap;
                
                	if (this->_M_is_engaged() && __other._M_is_engaged())
                	  swap(this->_M_get(), __other._M_get());
                	else if (this->_M_is_engaged())
                	  {
                	    __other._M_construct(std::move(this->_M_get()));
                	    this->_M_destruct();
                	  }
                	else if (__other._M_is_engaged())
                	  {
                	    this->_M_construct(std::move(__other._M_get()));
                	    __other._M_destruct();
                	  }
                      }
                
                      // Observers.
                      constexpr const _Tp*
                      operator->() const noexcept
                      { return std::__addressof(this->_M_get()); }
                
                      constexpr _Tp*
                      operator->() noexcept
                      { return std::__addressof(this->_M_get()); }
                
                      constexpr const _Tp&
                      operator*() const& noexcept
                      { return this->_M_get(); }
                
                      constexpr _Tp&
                      operator*()& noexcept
                      { return this->_M_get(); }
                
                      constexpr _Tp&&
                      operator*()&& noexcept
                      { return std::move(this->_M_get()); }
                
                      constexpr const _Tp&&
                      operator*() const&& noexcept
                      { return std::move(this->_M_get()); }
                
                      constexpr explicit operator bool() const noexcept
                      { return this->_M_is_engaged(); }
                
        1249 ->       constexpr bool has_value() const noexcept
                      { return this->_M_is_engaged(); }
                
                      constexpr const _Tp&
                      value() const&
                      {
                	if (this->_M_is_engaged())
                	  return this->_M_get();
                	__throw_bad_optional_access();
                      }
                
                      constexpr _Tp&
        1249 ->       value()&
                      {
                	if (this->_M_is_engaged())
                	  return this->_M_get();
                	__throw_bad_optional_access();
                      }
                
                      constexpr _Tp&&
                      value()&&
                      {
                	if (this->_M_is_engaged())
                	  return std::move(this->_M_get());
                	__throw_bad_optional_access();
                      }
                
                      constexpr const _Tp&&
                      value() const&&
                      {
                	if (this->_M_is_engaged())
                	  return std::move(this->_M_get());
                	__throw_bad_optional_access();
                      }
                
                      template<typename _Up>
                	constexpr _Tp
                	value_or(_Up&& __u) const&
                	{
                	  static_assert(is_copy_constructible_v<_Tp>);
                	  static_assert(is_convertible_v<_Up&&, _Tp>);
                
                	  if (this->_M_is_engaged())
                	    return this->_M_get();
                	  else
                	    return static_cast<_Tp>(std::forward<_Up>(__u));
                	}
                
                      template<typename _Up>
                	constexpr _Tp
                	value_or(_Up&& __u) &&
                	{
                	  static_assert(is_move_constructible_v<_Tp>);
                	  static_assert(is_convertible_v<_Up&&, _Tp>);
                
                	  if (this->_M_is_engaged())
                	    return std::move(this->_M_get());
                	  else
                	    return static_cast<_Tp>(std::forward<_Up>(__u));
                	}
                
                      _GLIBCXX20_CONSTEXPR void reset() noexcept { this->_M_reset(); }
                    };
                
                  template<typename _Tp>
                    using __optional_relop_t =
                      enable_if_t<is_convertible<_Tp, bool>::value, bool>;
                
                  template<typename _Tp, typename _Up>
                    using __optional_eq_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() == std::declval<const _Up&>())
                      >;
                
                  template<typename _Tp, typename _Up>
                    using __optional_ne_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() != std::declval<const _Up&>())
                      >;
                
                  template<typename _Tp, typename _Up>
                    using __optional_lt_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() < std::declval<const _Up&>())
                      >;
                
                  template<typename _Tp, typename _Up>
                    using __optional_gt_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() > std::declval<const _Up&>())
                      >;
                
                  template<typename _Tp, typename _Up>
                    using __optional_le_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() <= std::declval<const _Up&>())
                      >;
                
                  template<typename _Tp, typename _Up>
                    using __optional_ge_t = __optional_relop_t<
                      decltype(std::declval<const _Tp&>() >= std::declval<const _Up&>())
                      >;
                
                  // Comparisons between optional values.
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator==(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_eq_t<_Tp, _Up>
                    {
                      return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)
                	     && (!__lhs || *__lhs == *__rhs);
                    }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator!=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_ne_t<_Tp, _Up>
                    {
                      return static_cast<bool>(__lhs) != static_cast<bool>(__rhs)
                	|| (static_cast<bool>(__lhs) && *__lhs != *__rhs);
                    }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_lt_t<_Tp, _Up>
                    {
                      return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);
                    }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_gt_t<_Tp, _Up>
                    {
                      return static_cast<bool>(__lhs) && (!__rhs || *__lhs > *__rhs);
                    }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_le_t<_Tp, _Up>
                    {
                      return !__lhs || (static_cast<bool>(__rhs) && *__lhs <= *__rhs);
                    }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>=(const optional<_Tp>& __lhs, const optional<_Up>& __rhs)
                    -> __optional_ge_t<_Tp, _Up>
                    {
                      return !__rhs || (static_cast<bool>(__lhs) && *__lhs >= *__rhs);
                    }
                
                #ifdef __cpp_lib_three_way_comparison
                  template<typename _Tp, three_way_comparable_with<_Tp> _Up>
                    constexpr compare_three_way_result_t<_Tp, _Up>
                    operator<=>(const optional<_Tp>& __x, const optional<_Up>& __y)
                    {
                      return __x && __y ? *__x <=> *__y : bool(__x) <=> bool(__y);
                    }
                #endif
                
                  // Comparisons with nullopt.
                  template<typename _Tp>
                    constexpr bool
                    operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept
                    { return !__lhs; }
                
                #ifdef __cpp_lib_three_way_comparison
                  template<typename _Tp>
                    constexpr strong_ordering
                    operator<=>(const optional<_Tp>& __x, nullopt_t) noexcept
                    { return bool(__x) <=> false; }
                #else
                  template<typename _Tp>
                    constexpr bool
                    operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept
                    { return !__rhs; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept
                    { return static_cast<bool>(__lhs); }
                
                  template<typename _Tp>
                    constexpr bool
                    operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept
                    { return static_cast<bool>(__rhs); }
                
                  template<typename _Tp>
                    constexpr bool
                    operator<(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
                    { return false; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept
                    { return static_cast<bool>(__rhs); }
                
                  template<typename _Tp>
                    constexpr bool
                    operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept
                    { return static_cast<bool>(__lhs); }
                
                  template<typename _Tp>
                    constexpr bool
                    operator>(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
                    { return false; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept
                    { return !__lhs; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator<=(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept
                    { return true; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator>=(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept
                    { return true; }
                
                  template<typename _Tp>
                    constexpr bool
                    operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept
                    { return !__rhs; }
                #endif // three-way-comparison
                
                  // Comparisons with value type.
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator==(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_eq_t<_Tp, _Up>
                    { return __lhs && *__lhs == __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator==(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_eq_t<_Up, _Tp>
                    { return __rhs && __lhs == *__rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator!=(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_ne_t<_Tp, _Up>
                    { return !__lhs || *__lhs != __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator!=(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_ne_t<_Up, _Tp>
                    { return !__rhs || __lhs != *__rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_lt_t<_Tp, _Up>
                    { return !__lhs || *__lhs < __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_lt_t<_Up, _Tp>
                    { return __rhs && __lhs < *__rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_gt_t<_Tp, _Up>
                    { return __lhs && *__lhs > __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_gt_t<_Up, _Tp>
                    { return !__rhs || __lhs > *__rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<=(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_le_t<_Tp, _Up>
                    { return !__lhs || *__lhs <= __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator<=(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_le_t<_Up, _Tp>
                    { return __rhs && __lhs <= *__rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>=(const optional<_Tp>& __lhs, const _Up& __rhs)
                    -> __optional_ge_t<_Tp, _Up>
                    { return __lhs && *__lhs >= __rhs; }
                
                  template<typename _Tp, typename _Up>
                    constexpr auto
                    operator>=(const _Up& __lhs, const optional<_Tp>& __rhs)
                    -> __optional_ge_t<_Up, _Tp>
                    { return !__rhs || __lhs >= *__rhs; }
                
                #ifdef __cpp_lib_three_way_comparison
                  template<typename _Tp>
                    inline constexpr bool __is_optional_v = false;
                  template<typename _Tp>
                    inline constexpr bool __is_optional_v<optional<_Tp>> = true;
                
                  template<typename _Tp, typename _Up>
                    requires (!__is_optional_v<_Up>)
                      && three_way_comparable_with<_Tp, _Up>
                    constexpr compare_three_way_result_t<_Tp, _Up>
                    operator<=>(const optional<_Tp>& __x, const _Up& __v)
                    { return bool(__x) ? *__x <=> __v : strong_ordering::less; }
                #endif
                
                  // Swap and creation functions.
                
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // 2748. swappable traits for optionals
                  template<typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline enable_if_t<is_move_constructible_v<_Tp> && is_swappable_v<_Tp>>
                    swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)
                    noexcept(noexcept(__lhs.swap(__rhs)))
                    { __lhs.swap(__rhs); }
                
                  template<typename _Tp>
                    enable_if_t<!(is_move_constructible_v<_Tp> && is_swappable_v<_Tp>)>
                    swap(optional<_Tp>&, optional<_Tp>&) = delete;
                
                  template<typename _Tp>
                    constexpr
                    enable_if_t<is_constructible_v<decay_t<_Tp>, _Tp>,
                		optional<decay_t<_Tp>>>
                    make_optional(_Tp&& __t)
                    noexcept(is_nothrow_constructible_v<optional<decay_t<_Tp>>, _Tp>)
                    { return optional<decay_t<_Tp>>{ std::forward<_Tp>(__t) }; }
                
                  template<typename _Tp, typename... _Args>
                    constexpr
                    enable_if_t<is_constructible_v<_Tp, _Args...>,
                		optional<_Tp>>
                    make_optional(_Args&&... __args)
                    noexcept(is_nothrow_constructible_v<_Tp, _Args...>)
                    { return optional<_Tp>{ in_place, std::forward<_Args>(__args)... }; }
                
                  template<typename _Tp, typename _Up, typename... _Args>
                    constexpr
                    enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>,
                		optional<_Tp>>
                    make_optional(initializer_list<_Up> __il, _Args&&... __args)
                    noexcept(is_nothrow_constructible_v<_Tp, initializer_list<_Up>&, _Args...>)
                    { return optional<_Tp>{ in_place, __il, std::forward<_Args>(__args)... }; }
                
                  // Hash.
                
                  template<typename _Tp, typename _Up = remove_const_t<_Tp>,
                	   bool = __poison_hash<_Up>::__enable_hash_call>
                    struct __optional_hash_call_base
                    {
                      size_t
                      operator()(const optional<_Tp>& __t) const
                      noexcept(noexcept(hash<_Up>{}(*__t)))
                      {
                	// We pick an arbitrary hash for disengaged optionals which hopefully
                	// usual values of _Tp won't typically hash to.
                	constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);
                	return __t ? hash<_Up>{}(*__t) : __magic_disengaged_hash;
                      }
                    };
                
                  template<typename _Tp, typename _Up>
                    struct __optional_hash_call_base<_Tp, _Up, false> {};
                
                  template<typename _Tp>
                    struct hash<optional<_Tp>>
                    : private __poison_hash<remove_const_t<_Tp>>,
                      public __optional_hash_call_base<_Tp>
                    {
                      using result_type [[__deprecated__]] = size_t;
                      using argument_type [[__deprecated__]] = optional<_Tp>;
                    };
                
                  template<typename _Tp>
                    struct __is_fast_hash<hash<optional<_Tp>>> : __is_fast_hash<hash<_Tp>>
                    { };
                
                  /// @}
                
                #if __cpp_deduction_guides >= 201606
                  template <typename _Tp> optional(_Tp) -> optional<_Tp>;
                #endif
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                #endif // C++17
                
                #endif // _GLIBCXX_OPTIONAL


Top 10 Lines:

     Line      Count

      432       2498
      268       1249
      437       1249
      944       1249
      956       1249
      111       1110
      116       1110
      200       1110
      204       1110
      301       1110

Execution Summary:

       20   Executable lines in this file
       20   Lines executed
   100.00   Percent of the file executed

    18594   Total number of line executions
   929.70   Average executions per line


*** File /usr/include/c++/11/bits/stl_algobase.h:
                // Core algorithmic facilities -*- C++ -*-
                
                // Copyright (C) 2001-2021 Free Software Foundation, Inc.
                //
                // This file is part of the GNU ISO C++ Library.  This library is free
                // software; you can redistribute it and/or modify it under the
                // terms of the GNU General Public License as published by the
                // Free Software Foundation; either version 3, or (at your option)
                // any later version.
                
                // This library is distributed in the hope that it will be useful,
                // but WITHOUT ANY WARRANTY; without even the implied warranty of
                // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                // GNU General Public License for more details.
                
                // Under Section 7 of GPL version 3, you are granted additional
                // permissions described in the GCC Runtime Library Exception, version
                // 3.1, as published by the Free Software Foundation.
                
                // You should have received a copy of the GNU General Public License and
                // a copy of the GCC Runtime Library Exception along with this program;
                // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
                // <http://www.gnu.org/licenses/>.
                
                /*
                 *
                 * Copyright (c) 1994
                 * Hewlett-Packard Company
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Hewlett-Packard Company makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 *
                 *
                 * Copyright (c) 1996-1998
                 * Silicon Graphics Computer Systems, Inc.
                 *
                 * Permission to use, copy, modify, distribute and sell this software
                 * and its documentation for any purpose is hereby granted without fee,
                 * provided that the above copyright notice appear in all copies and
                 * that both that copyright notice and this permission notice appear
                 * in supporting documentation.  Silicon Graphics makes no
                 * representations about the suitability of this software for any
                 * purpose.  It is provided "as is" without express or implied warranty.
                 */
                
                /** @file bits/stl_algobase.h
                 *  This is an internal header file, included by other library headers.
                 *  Do not attempt to use it directly. @headername{algorithm}
                 */
                
                #ifndef _STL_ALGOBASE_H
                #define _STL_ALGOBASE_H 1
                
                #include <bits/c++config.h>
                #include <bits/functexcept.h>
                #include <bits/cpp_type_traits.h>
                #include <ext/type_traits.h>
                #include <ext/numeric_traits.h>
                #include <bits/stl_pair.h>
                #include <bits/stl_iterator_base_types.h>
                #include <bits/stl_iterator_base_funcs.h>
                #include <bits/stl_iterator.h>
                #include <bits/concept_check.h>
                #include <debug/debug.h>
                #include <bits/move.h> // For std::swap
                #include <bits/predefined_ops.h>
                #if __cplusplus >= 201103L
                # include <type_traits>
                #endif
                #if __cplusplus > 201703L
                # include <compare>
                #endif
                
                namespace std _GLIBCXX_VISIBILITY(default)
                {
                _GLIBCXX_BEGIN_NAMESPACE_VERSION
                
                  /*
                   * A constexpr wrapper for __builtin_memcmp.
                   * @param __num The number of elements of type _Tp (not bytes).
                   */
                  template<typename _Tp, typename _Up>
                    _GLIBCXX14_CONSTEXPR
                    inline int
                    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
                    {
                #if __cplusplus >= 201103L
                      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
                #endif
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	{
                	  for(; __num > 0; ++__first1, ++__first2, --__num)
                	    if (*__first1 != *__first2)
                	      return *__first1 < *__first2 ? -1 : 1;
                	  return 0;
                	}
                      else
                #endif
                	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
                    }
                
                #if __cplusplus < 201103L
                  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
                  // nutshell, we are partially implementing the resolution of DR 187,
                  // when it's safe, i.e., the value_types are equal.
                  template<bool _BoolType>
                    struct __iter_swap
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  typedef typename iterator_traits<_ForwardIterator1>::value_type
                	    _ValueType1;
                	  _ValueType1 __tmp = *__a;
                	  *__a = *__b;
                	  *__b = __tmp;
                	}
                    };
                
                  template<>
                    struct __iter_swap<true>
                    {
                      template<typename _ForwardIterator1, typename _ForwardIterator2>
                	static void
                	iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                	{
                	  swap(*__a, *__b);
                	}
                    };
                #endif // C++03
                
                  /**
                   *  @brief Swaps the contents of two iterators.
                   *  @ingroup mutating_algorithms
                   *  @param  __a  An iterator.
                   *  @param  __b  Another iterator.
                   *  @return   Nothing.
                   *
                   *  This function swaps the values pointed to by two iterators, not the
                   *  iterators themselves.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline void
       ##### ->     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                
                #if __cplusplus < 201103L
                      typedef typename iterator_traits<_ForwardIterator1>::value_type
                	_ValueType1;
                      typedef typename iterator_traits<_ForwardIterator2>::value_type
                	_ValueType2;
                
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,
                				  _ValueType2>)
                      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,
                				  _ValueType1>)
                
                      typedef typename iterator_traits<_ForwardIterator1>::reference
                	_ReferenceType1;
                      typedef typename iterator_traits<_ForwardIterator2>::reference
                	_ReferenceType2;
                      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
                	&& __are_same<_ValueType1&, _ReferenceType1>::__value
                	&& __are_same<_ValueType2&, _ReferenceType2>::__value>::
                	iter_swap(__a, __b);
                #else
                      // _GLIBCXX_RESOLVE_LIB_DEFECTS
                      // 187. iter_swap underspecified
                      swap(*__a, *__b);
                #endif
                    }
                
                  /**
                   *  @brief Swap the elements of two sequences.
                   *  @ingroup mutating_algorithms
                   *  @param  __first1  A forward iterator.
                   *  @param  __last1   A forward iterator.
                   *  @param  __first2  A forward iterator.
                   *  @return   An iterator equal to @p first2+(last1-first1).
                   *
                   *  Swaps each element in the range @p [first1,last1) with the
                   *  corresponding element in the range @p [first2,(last1-first1)).
                   *  The ranges must not overlap.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator2
                    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		_ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator1>)
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	std::iter_swap(__first1, __first2);
                      return __first2;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The lesser of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
      113879 ->     min(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return __b < __a ? __b : __a;
                      if (__b < __a)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @return   The greater of the parameters.
                   *
                   *  This is the simple classic generic implementation.  It will work on
                   *  temporary expressions, since they are only evaluated once, unlike a
                   *  preprocessor macro.
                  */
                  template<typename _Tp>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
       56939 ->     max(const _Tp& __a, const _Tp& __b)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
                      //return  __a < __b ? __b : __a;
                      if (__a < __b)
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The lesser of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__b, __a) ? __b : __a;
                      if (__comp(__b, __a))
                	return __b;
                      return __a;
                    }
                
                  /**
                   *  @brief This does what you think it does.
                   *  @ingroup sorting_algorithms
                   *  @param  __a  A thing of arbitrary type.
                   *  @param  __b  Another thing of arbitrary type.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The greater of the parameters.
                   *
                   *  This will work on temporary expressions, since they are only evaluated
                   *  once, unlike a preprocessor macro.
                  */
                  template<typename _Tp, typename _Compare>
                    _GLIBCXX14_CONSTEXPR
                    inline const _Tp&
                    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
                    {
                      //return __comp(__a, __b) ? __b : __a;
                      if (__comp(__a, __b))
                	return __b;
                      return __a;
                    }
                
                  // Fallback implementation of the function in bits/stl_iterator.h used to
                  // remove the __normal_iterator wrapper. See copy, fill, ...
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
      313728 ->     __niter_base(_Iterator __it)
                    _GLIBCXX_NOEXCEPT_IF(std::is_nothrow_copy_constructible<_Iterator>::value)
                    { return __it; }
                
                  template<typename _Ite, typename _Seq>
                    _Ite
                    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
                		 std::random_access_iterator_tag>&);
                
                  // Reverse the __niter_base transformation to get a
                  // __normal_iterator back again (this assumes that __normal_iterator
                  // is only used to wrap random access iterators, like pointers).
                  template<typename _From, typename _To>
                    _GLIBCXX20_CONSTEXPR
                    inline _From
         873 ->     __niter_wrap(_From __from, _To __res)
                    { return __from + (__res - std::__niter_base(__from)); }
                
                  // No need to wrap, iterator already has the right type.
                  template<typename _Iterator>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
       ##### ->     __niter_wrap(const _Iterator&, _Iterator __res)
                    { return __res; }
                
                  // All of these auxiliary structs serve two purposes.  (1) Replace
                  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
                  // because the input and output ranges are permitted to overlap.)
                  // (2) If we're using random access iterators, then write the loop as
                  // a for loop with an explicit count.
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = *__first;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move<true, false, _Category>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
                	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  for (; __first != __last; ++__result, (void)++__first)
                	    *__result = std::move(*__first);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move<false, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
           1 -> 	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = *__first;
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move<true, false, random_access_iterator_tag>
                    {
                      template<typename _II, typename _OI>
                	_GLIBCXX20_CONSTEXPR
                	static _OI
         872 -> 	__copy_m(_II __first, _II __last, _OI __result)
                	{
                	  typedef typename iterator_traits<_II>::difference_type _Distance;
                	  for(_Distance __n = __last - __first; __n > 0; --__n)
                	    {
                	      *__result = std::move(*__first);
                	      ++__first;
                	      ++__result;
                	    }
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static _Tp*
       ##### -> 	__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
                	  return __result + _Num;
                	}
                    };
                
                _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
                
                  template<typename _Tp, typename _Ref, typename _Ptr>
                    struct _Deque_iterator;
                
                  struct _Bit_iterator;
                
                _GLIBCXX_END_NAMESPACE_CONTAINER
                
                  // Helpers for streambuf iterators (either istream or ostream).
                  // NB: avoid including <iosfwd>, relatively large.
                  template<typename _CharT>
                    struct char_traits;
                
                  template<typename _CharT, typename _Traits>
                    class istreambuf_iterator;
                
                  template<typename _CharT, typename _Traits>
                    class ostreambuf_iterator;
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(_CharT*, _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                	     ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
                    __copy_move_a2(const _CharT*, const _CharT*,
                		   ostreambuf_iterator<_CharT, char_traits<_CharT> >);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                				    _CharT*>::__type
                    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
                
                  template<bool _IsMove, typename _CharT>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
                    __copy_move_a2(
                	istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	_GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
         873 ->     __copy_move_a2(_II __first, _II __last, _OI __result)
                    {
                      typedef typename iterator_traits<_II>::iterator_category _Category;
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return std::__copy_move<_IsMove, false, _Category>::
                	  __copy_m(__first, __last, __result);
                #endif
                      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
                			      _Category>::__copy_m(__first, __last, __result);
                    }
                
                  template<bool _IsMove,
                	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
                    _OI
                    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		   _OI);
                
                  template<bool _IsMove,
                	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
                    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
                    __copy_move_a1(_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                		   _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
                
                  template<bool _IsMove, typename _II, typename _Tp>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
                    __copy_move_a1(_II, _II, _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
         873 ->     __copy_move_a1(_II __first, _II __last, _OI __result)
                    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
         873 ->     __copy_move_a(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
                					     std::__niter_base(__last),
                					     std::__niter_base(__result)));
                    }
                
                  template<bool _IsMove,
                	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
                    _OI
                    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		  _OI);
                
                  template<bool _IsMove,
                	   typename _II, typename _Ite, typename _Seq, typename _Cat>
                    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __copy_move_a(_II, _II,
                		  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
                
                  template<bool _IsMove,
                	   typename _IIte, typename _ISeq, typename _ICat,
                	   typename _OIte, typename _OSeq, typename _OCat>
                    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
                    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
                
                  template<typename _InputIterator, typename _Size, typename _OutputIterator>
                    _GLIBCXX20_CONSTEXPR
                    _OutputIterator
                    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
                	       bool)
                    {
                      if (__n > 0)
                	{
                	  while (true)
                	    {
                	      *__result = *__first;
                	      ++__result;
                	      if (--__n > 0)
                		++__first;
                	      else
                		break;
                	    }
                	}
                      return __result;
                    }
                
                  template<typename _CharT, typename _Size>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value, _CharT*>::__type
                    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
                	       _Size, _CharT*, bool);
                
                  template<typename _CharT, typename _Size>
                    typename __gnu_cxx::__enable_if<
                      __is_char<_CharT>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
                    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
                	       _GLIBCXX_STD_C::_Deque_iterator<_CharT, _CharT&, _CharT*>,
                	       bool);
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the copy_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
           1 ->     copy(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a<__is_move_iterator<_II>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An input iterator.
                   *  @param  __last   An input iterator.
                   *  @param  __result An output iterator.
                   *  @return   result + (last - first)
                   *
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).  Result may not be contained within
                   *  [first,last); the move_backward function should be used instead.
                   *
                   *  Note that the end of the output range is permitted to be contained
                   *  within [first,last).
                  */
                  template<typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
         872 ->     move(_II __first, _II __last, _OI __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II>)
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI,
                	    typename iterator_traits<_II>::value_type>)
                      __glibcxx_requires_can_increment_range(__first, __last, __result);
                
                      return std::__copy_move_a<true>(std::__miter_base(__first),
                				      std::__miter_base(__last), __result);
                    }
                
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::copy(_Tp, _Up, _Vp)
                #endif
                
                  template<bool _IsMove, bool _IsSimple, typename _Category>
                    struct __copy_move_backward
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<typename _Category>
                    struct __copy_move_backward<true, false, _Category>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  while (__first != __last)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<>
                    struct __copy_move_backward<false, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type
                	    __n = __last - __first;
                	  for (; __n > 0; --__n)
                	    *--__result = *--__last;
                	  return __result;
                	}
                    };
                
                #if __cplusplus >= 201103L
                  template<>
                    struct __copy_move_backward<true, false, random_access_iterator_tag>
                    {
                      template<typename _BI1, typename _BI2>
                	_GLIBCXX20_CONSTEXPR
                	static _BI2
                	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
                	{
                	  typename iterator_traits<_BI1>::difference_type
                	    __n = __last - __first;
                	  for (; __n > 0; --__n)
                	    *--__result = std::move(*--__last);
                	  return __result;
                	}
                    };
                #endif
                
                  template<bool _IsMove>
                    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static _Tp*
       ##### -> 	__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
                	{
                #if __cplusplus >= 201103L
                	  using __assignable = conditional<_IsMove,
                					   is_move_assignable<_Tp>,
                					   is_copy_assignable<_Tp>>;
                	  // trivial types can have deleted assignment
                	  static_assert( __assignable::type::value, "type is not assignable" );
                #endif
                	  const ptrdiff_t _Num = __last - __first;
                	  if (_Num)
                	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
                	  return __result - _Num;
                	}
                    };
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
       ##### ->     __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      typedef typename iterator_traits<_BI1>::iterator_category _Category;
                #ifdef __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	return std::__copy_move_backward<_IsMove, false, _Category>::
                	  __copy_move_b(__first, __last, __result);
                #endif
                      return std::__copy_move_backward<_IsMove,
                				       __memcpyable<_BI2, _BI1>::__value,
                				       _Category>::__copy_move_b(__first,
                								 __last,
                								 __result);
                    }
                
                  template<bool _IsMove, typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
       ##### ->     __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
                    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }
                
                  template<bool _IsMove,
                	   typename _Tp, typename _Ref, typename _Ptr, typename _OI>
                    _OI
                    __copy_move_backward_a1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                			    _OI);
                
                  template<bool _IsMove,
                	   typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
                    _GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>
                    __copy_move_backward_a1(
                			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                			_GLIBCXX_STD_C::_Deque_iterator<_ITp, _IRef, _IPtr>,
                			_GLIBCXX_STD_C::_Deque_iterator<_OTp, _OTp&, _OTp*>);
                
                  template<bool _IsMove, typename _II, typename _Tp>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value,
                      _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
                    __copy_move_backward_a1(_II, _II,
                			    _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>);
                
                  template<bool _IsMove, typename _II, typename _OI>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
       ##### ->     __copy_move_backward_a(_II __first, _II __last, _OI __result)
                    {
                      return std::__niter_wrap(__result,
                		std::__copy_move_backward_a1<_IsMove>
                		  (std::__niter_base(__first), std::__niter_base(__last),
                		   std::__niter_base(__result)));
                    }
                
                  template<bool _IsMove,
                	   typename _Ite, typename _Seq, typename _Cat, typename _OI>
                    _OI
                    __copy_move_backward_a(
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                		_OI);
                
                  template<bool _IsMove,
                	   typename _II, typename _Ite, typename _Seq, typename _Cat>
                    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __copy_move_backward_a(_II, _II,
                		const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);
                
                  template<bool _IsMove,
                	   typename _IIte, typename _ISeq, typename _ICat,
                	   typename _OIte, typename _OSeq, typename _OCat>
                    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
                    __copy_move_backward_a(
                		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
                		const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
                
                  /**
                   *  @brief Copies the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as copy, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use copy instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
       ##### ->     copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
                	     (std::__miter_base(__first), std::__miter_base(__last), __result);
                    }
                
                #if __cplusplus >= 201103L
                  /**
                   *  @brief Moves the range [first,last) into result.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A bidirectional iterator.
                   *  @param  __last   A bidirectional iterator.
                   *  @param  __result A bidirectional iterator.
                   *  @return   result - (last - first)
                   *
                   *  The function has the same effect as move, but starts at the end of the
                   *  range and works its way to the start, returning the start of the result.
                   *  This inline function will boil down to a call to @c memmove whenever
                   *  possible.  Failing that, if random access iterators are passed, then the
                   *  loop count will be known (and therefore a candidate for compiler
                   *  optimizations such as unrolling).
                   *
                   *  Result may not be in the range (first,last].  Use move instead.  Note
                   *  that the start of the output range may overlap [first,last).
                  */
                  template<typename _BI1, typename _BI2>
                    _GLIBCXX20_CONSTEXPR
                    inline _BI2
                    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_BidirectionalIteratorConcept<_BI1>)
                      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>)
                      __glibcxx_function_requires(_ConvertibleConcept<
                	    typename iterator_traits<_BI1>::value_type,
                	    typename iterator_traits<_BI2>::value_type>)
                      __glibcxx_requires_can_decrement_range(__first, __last, __result);
                
                      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
                					       std::__miter_base(__last),
                					       __result);
                    }
                
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
                #else
                #define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::copy_backward(_Tp, _Up, _Vp)
                #endif
                
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
                    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                	      const _Tp& __value)
                    {
                      for (; __first != __last; ++__first)
                	*__first = __value;
                    }
                
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
                    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
                	      const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __first != __last; ++__first)
                	*__first = __tmp;
                    }
                
                  // Specialization: for char types we can use memset.
                  template<typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
                    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
                    {
                      const _Tp __tmp = __c;
                #if __cpp_lib_is_constant_evaluated
                      if (std::is_constant_evaluated())
                	{
                	  for (; __first != __last; ++__first)
                	    *__first = __tmp;
                	  return;
                	}
                #endif
                      if (const size_t __len = __last - __first)
                	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
                    }
                
                  template<typename _Ite, typename _Cont, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
                	      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
                	      const _Tp& __value)
                    { std::__fill_a1(__first.base(), __last.base(), __value); }
                
                  template<typename _Tp, typename _VTp>
                    void
                    __fill_a1(const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
                	      const _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
                	      const _VTp&);
                
                  void
                  __fill_a1(_GLIBCXX_STD_C::_Bit_iterator, _GLIBCXX_STD_C::_Bit_iterator,
                	    const bool&);
                
                  template<typename _FIte, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
                    { std::__fill_a1(__first, __last, __value); }
                
                  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
                    void
                    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                	     const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
                	     const _Tp&);
                
                  /**
                   *  @brief Fills the range [first,last) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  A forward iterator.
                   *  @param  __last   A forward iterator.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   Nothing.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline void
                    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
                				  _ForwardIterator>)
                      __glibcxx_requires_valid_range(__first, __last);
                
                      std::__fill_a(__first, __last, __value);
                    }
                
                  // Used by fill_n, generate_n, etc. to convert _Size to an integral type:
                  inline _GLIBCXX_CONSTEXPR int
                  __size_to_integer(int __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __size_to_integer(unsigned __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR long
                  __size_to_integer(long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __size_to_integer(unsigned long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(long long __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __size_to_integer(unsigned long long __n) { return __n; }
                
                #if defined(__GLIBCXX_TYPE_INT_N_0)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_0
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_0
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_0 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_1)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_1
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_1
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_1 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_2)
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_2
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_2
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_2 __n) { return __n; }
                #endif
                #if defined(__GLIBCXX_TYPE_INT_N_3)
                  inline _GLIBCXX_CONSTEXPR unsigned __GLIBCXX_TYPE_INT_N_3
                  __size_to_integer(__GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
                  inline _GLIBCXX_CONSTEXPR __GLIBCXX_TYPE_INT_N_3
                  __size_to_integer(unsigned __GLIBCXX_TYPE_INT_N_3 __n) { return __n; }
                #endif
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(float __n) { return (long long)__n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(double __n) { return (long long)__n; }
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(long double __n) { return (long long)__n; }
                #if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128) && !defined(__CUDACC__)
                  inline _GLIBCXX_CONSTEXPR long long
                  __size_to_integer(__float128 __n) { return (long long)__n; }
                #endif
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      for (; __n > 0; --__n, (void) ++__first)
                	*__first = __value;
                      return __first;
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline typename
                    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
                    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
                    {
                      const _Tp __tmp = __value;
                      for (; __n > 0; --__n, (void) ++__first)
                	*__first = __tmp;
                      return __first;
                    }
                
                  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
                	   typename _Tp>
                    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
                    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
                	       _Size __n, const _Tp& __value,
                	       std::input_iterator_tag);
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::output_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      return __fill_n_a1(__first, __n, __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::input_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      return __fill_n_a1(__first, __n, __value);
                    }
                
                  template<typename _OutputIterator, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OutputIterator
                    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
                	       std::random_access_iterator_tag)
                    {
                #if __cplusplus >= 201103L
                      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
                #endif
                      if (__n <= 0)
                	return __first;
                
                      __glibcxx_requires_can_increment(__first, __n);
                
                      std::__fill_a(__first, __first + __n, __value);
                      return __first + __n;
                    }
                
                  /**
                   *  @brief Fills the range [first,first+n) with copies of value.
                   *  @ingroup mutating_algorithms
                   *  @param  __first  An output iterator.
                   *  @param  __n      The count of copies to perform.
                   *  @param  __value  A reference-to-const of arbitrary type.
                   *  @return   The iterator at first+n.
                   *
                   *  This function fills a range with copies of the same value.  For char
                   *  types filling contiguous areas of memory, this becomes an inline call
                   *  to @c memset or @c wmemset.
                   *
                   *  If @p __n is negative, the function does nothing.
                  */
                  // _GLIBCXX_RESOLVE_LIB_DEFECTS
                  // DR 865. More algorithms that throw away information
                  // DR 426. search_n(), fill_n(), and generate_n() with negative n
                  template<typename _OI, typename _Size, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _OI
                    fill_n(_OI __first, _Size __n, const _Tp& __value)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_OutputIteratorConcept<_OI, _Tp>)
                
                      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
                			       std::__iterator_category(__first));
                    }
                
                  template<bool _BoolType>
                    struct __equal
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	equal(_II1 __first1, _II1 __last1, _II2 __first2)
                	{
                	  for (; __first1 != __last1; ++__first1, (void) ++__first2)
                	    if (!(*__first1 == *__first2))
                	      return false;
                	  return true;
                	}
                    };
                
                  template<>
                    struct __equal<true>
                    {
                      template<typename _Tp>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
                	{
                	  if (const size_t __len = (__last1 - __first1))
                	    return !std::__memcmp(__first1, __first2, __len);
                	  return true;
                	}
                    };
                
                  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value, bool>::__type
                    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>,
                		 _II);
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __equal_aux1(_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                		 _GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
                    typename __gnu_cxx::__enable_if<
                      __is_random_access_iter<_II>::__value, bool>::__type
                    __equal_aux1(_II, _II,
                		_GLIBCXX_STD_C::_Deque_iterator<_Tp, _Ref, _Ptr>);
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      const bool __simple = ((__is_integer<_ValueType1>::__value
                			      || __is_pointer<_ValueType1>::__value)
                			     && __memcmpable<_II1, _II2>::__value);
                      return std::__equal<__simple>::equal(__first1, __last1, __first2);
                    }
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      return std::__equal_aux1(std::__niter_base(__first1),
                			       std::__niter_base(__last1),
                			       std::__niter_base(__first2));
                    }
                
                  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
                    bool
                    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		_II2);
                
                  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
                    bool
                    __equal_aux(_II1, _II1,
                		const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);
                
                  template<typename _II1, typename _Seq1, typename _Cat1,
                	   typename _II2, typename _Seq2, typename _Cat2>
                    bool
                    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);
                
                  template<typename, typename>
                    struct __lc_rai
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static _II1
                	__newlast1(_II1, _II1 __last1, _II2, _II2)
                	{ return __last1; }
                
                      template<typename _II>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__cnd2(_II __first, _II __last)
                	{ return __first != __last; }
                    };
                
                  template<>
                    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
                    {
                      template<typename _RAI1, typename _RAI2>
                	_GLIBCXX20_CONSTEXPR
                	static _RAI1
                	__newlast1(_RAI1 __first1, _RAI1 __last1,
                		   _RAI2 __first2, _RAI2 __last2)
                	{
                	  const typename iterator_traits<_RAI1>::difference_type
                	    __diff1 = __last1 - __first1;
                	  const typename iterator_traits<_RAI2>::difference_type
                	    __diff2 = __last2 - __first2;
                	  return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
                	}
                
                      template<typename _RAI>
                	static _GLIBCXX20_CONSTEXPR bool
                	__cnd2(_RAI, _RAI)
                	{ return true; }
                    };
                
                  template<typename _II1, typename _II2, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2,
                				   _Compare __comp)
                    {
                      typedef typename iterator_traits<_II1>::iterator_category _Category1;
                      typedef typename iterator_traits<_II2>::iterator_category _Category2;
                      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
                
                      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
                      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
                	   ++__first1, (void)++__first2)
                	{
                	  if (__comp(__first1, __first2))
                	    return true;
                	  if (__comp(__first2, __first1))
                	    return false;
                	}
                      return __first1 == __last1 && __first2 != __last2;
                    }
                
                  template<bool _BoolType>
                    struct __lexicographical_compare
                    {
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                	{
                	  using __gnu_cxx::__ops::__iter_less_iter;
                	  return std::__lexicographical_compare_impl(__first1, __last1,
                						     __first2, __last2,
                						     __iter_less_iter());
                	}
                
                      template<typename _II1, typename _II2>
                	_GLIBCXX20_CONSTEXPR
                	static int
                	__3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                	{
                	  while (__first1 != __last1)
                	    {
                	      if (__first2 == __last2)
                		return +1;
                	      if (*__first1 < *__first2)
                		return -1;
                	      if (*__first2 < *__first1)
                		return +1;
                	      ++__first1;
                	      ++__first2;
                	    }
                	  return int(__first2 == __last2) - 1;
                	}
                    };
                
                  template<>
                    struct __lexicographical_compare<true>
                    {
                      template<typename _Tp, typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	static bool
                	__lc(const _Tp* __first1, const _Tp* __last1,
                	     const _Up* __first2, const _Up* __last2)
                	{ return __3way(__first1, __last1, __first2, __last2) < 0; }
                
                      template<typename _Tp, typename _Up>
                	_GLIBCXX20_CONSTEXPR
                	static ptrdiff_t
                	__3way(const _Tp* __first1, const _Tp* __last1,
                	       const _Up* __first2, const _Up* __last2)
                	{
                	  const size_t __len1 = __last1 - __first1;
                	  const size_t __len2 = __last2 - __first2;
                	  if (const size_t __len = std::min(__len1, __len2))
                	    if (int __result = std::__memcmp(__first1, __first2, __len))
                	      return __result;
                	  return ptrdiff_t(__len1 - __len2);
                	}
                    };
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
                				   _II2 __first2, _II2 __last2)
                    {
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                      const bool __simple =
                	(__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
                	 && __is_pointer<_II1>::__value
                	 && __is_pointer<_II2>::__value
                #if __cplusplus > 201703L && __cpp_lib_concepts
                	 // For C++20 iterator_traits<volatile T*>::value_type is non-volatile
                	 // so __is_byte<T> could be true, but we can't use memcmp with
                	 // volatile data.
                	 && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
                	 && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>
                #endif
                	 );
                
                      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
                							    __first2, __last2);
                    }
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2>
                    bool
                    __lexicographical_compare_aux1(
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_Tp2*, _Tp2*);
                
                  template<typename _Tp1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _Tp1, typename _Ref1, typename _Ptr1,
                	   typename _Tp2, typename _Ref2, typename _Ptr2>
                    bool
                    __lexicographical_compare_aux1(
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
                	_GLIBCXX_STD_C::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);
                
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
                				  _II2 __first2, _II2 __last2)
                    {
                      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
                						 std::__niter_base(__last1),
                						 std::__niter_base(__first2),
                						 std::__niter_base(__last2));
                    }
                
                  template<typename _Iter1, typename _Seq1, typename _Cat1,
                	   typename _II2>
                    bool
                    __lexicographical_compare_aux(
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		_II2, _II2);
                
                  template<typename _II1,
                	   typename _Iter2, typename _Seq2, typename _Cat2>
                    bool
                    __lexicographical_compare_aux(
                		_II1, _II1,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);
                
                  template<typename _Iter1, typename _Seq1, typename _Cat1,
                	   typename _Iter2, typename _Seq2, typename _Cat2>
                    bool
                    __lexicographical_compare_aux(
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
                		const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);
                
                  template<typename _ForwardIterator, typename _Tp, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    _ForwardIterator
                    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		  const _Tp& __val, _Compare __comp)
                    {
                      typedef typename iterator_traits<_ForwardIterator>::difference_type
                	_DistanceType;
                
                      _DistanceType __len = std::distance(__first, __last);
                
                      while (__len > 0)
                	{
                	  _DistanceType __half = __len >> 1;
                	  _ForwardIterator __middle = __first;
                	  std::advance(__middle, __half);
                	  if (__comp(__middle, __val))
                	    {
                	      __first = __middle;
                	      ++__first;
                	      __len = __len - __half - 1;
                	    }
                	  else
                	    __len = __half;
                	}
                      return __first;
                    }
                
                  /**
                   *  @brief Finds the first position in which @a val could be inserted
                   *         without changing the ordering.
                   *  @param  __first   An iterator.
                   *  @param  __last    Another iterator.
                   *  @param  __val     The search term.
                   *  @return         An iterator pointing to the first element <em>not less
                   *                  than</em> @a val, or end() if every element is less than
                   *                  @a val.
                   *  @ingroup binary_search_algorithms
                  */
                  template<typename _ForwardIterator, typename _Tp>
                    _GLIBCXX20_CONSTEXPR
                    inline _ForwardIterator
                    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
                		const _Tp& __val)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
                      __glibcxx_function_requires(_LessThanOpConcept<
                	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
                      __glibcxx_requires_partitioned_lower(__first, __last, __val);
                
                      return std::__lower_bound(__first, __last, __val,
                				__gnu_cxx::__ops::__iter_less_val());
                    }
                
                  /// This is a helper function for the sort routines and for random.tcc.
                  //  Precondition: __n > 0.
                  inline _GLIBCXX_CONSTEXPR int
                  __lg(int __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned
                  __lg(unsigned __n)
                  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long
                  __lg(long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long
                  __lg(unsigned long __n)
                  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
                
                  inline _GLIBCXX_CONSTEXPR long long
                  __lg(long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                  inline _GLIBCXX_CONSTEXPR unsigned long long
                  __lg(unsigned long long __n)
                  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
                
                _GLIBCXX_BEGIN_NAMESPACE_ALGO
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_can_increment_range(__first1, __last1, __first2);
                
                      return std::__equal_aux(__first1, __last1, __first2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return true;
                    }
                
                #if __cplusplus >= 201103L
                  // 4-iterator version of std::equal<It1, It2> for use in C++11.
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!(*__first1 == *__first2))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                
                  // 4-iterator version of std::equal<It1, It2, BinaryPred> for use in C++11.
                  template<typename _II1, typename _II2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      using _RATag = random_access_iterator_tag;
                      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
                      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
                      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
                      if (_RAIters())
                	{
                	  auto __d1 = std::distance(__first1, __last1);
                	  auto __d2 = std::distance(__first2, __last2);
                	  if (__d1 != __d2)
                	    return false;
                	  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,
                				       __binary_pred);
                	}
                
                      for (; __first1 != __last1 && __first2 != __last2;
                	  ++__first1, (void)++__first2)
                	if (!bool(__binary_pred(*__first1, *__first2)))
                	  return false;
                      return __first1 == __last1 && __first2 == __last2;
                    }
                #endif // C++11
                
                #if __cplusplus > 201103L
                
                #define __cpp_lib_robust_nonmodifying_seq_ops 201304
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  This compares the elements of two ranges using @c == and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_II1>::value_type,
                	    typename iterator_traits<_II2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2);
                    }
                
                  /**
                   *  @brief Tests a range for element-wise equality.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *                  functor@endlink.
                   *  @return         A boolean true or false.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns true or
                   *  false depending on whether all of the corresponding elements of the
                   *  ranges are equal.
                  */
                  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    equal(_IIter1 __first1, _IIter1 __last1,
                	  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__equal4(__first1, __last1, __first2, __last2,
                				      __binary_pred);
                    }
                #endif // C++14
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A boolean true or false.
                   *
                   *  <em>Returns true if the sequence of elements defined by the range
                   *  [first1,last1) is lexicographically less than the sequence of elements
                   *  defined by the range [first2,last2).  Returns false otherwise.</em>
                   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
                   *  then this is an inline call to @c memcmp.
                  */
                  template<typename _II1, typename _II2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2)
                    {
                #ifdef _GLIBCXX_CONCEPT_CHECKS
                      // concept requirements
                      typedef typename iterator_traits<_II1>::value_type _ValueType1;
                      typedef typename iterator_traits<_II2>::value_type _ValueType2;
                #endif
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType1, _ValueType2>)
                      __glibcxx_function_requires(_LessThanOpConcept<_ValueType2, _ValueType1>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_aux(__first1, __last1,
                						__first2, __last2);
                    }
                
                  /**
                   *  @brief Performs @b dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   A boolean true or false.
                   *
                   *  The same as the four-parameter @c lexicographical_compare, but uses the
                   *  comp parameter instead of @c <.
                  */
                  template<typename _II1, typename _II2, typename _Compare>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    lexicographical_compare(_II1 __first1, _II1 __last1,
                			    _II2 __first2, _II2 __last2, _Compare __comp)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_II1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_II2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return std::__lexicographical_compare_impl
                	(__first1, __last1, __first2, __last2,
                	 __gnu_cxx::__ops::__iter_comp_iter(__comp));
                    }
                
                #if __cpp_lib_three_way_comparison
                  // Iter points to a contiguous range of unsigned narrow character type
                  // or std::byte, suitable for comparison by memcmp.
                  template<typename _Iter>
                    concept __is_byte_iter = contiguous_iterator<_Iter>
                      && __is_memcmp_ordered<iter_value_t<_Iter>>::__value;
                
                  // Return a struct with two members, initialized to the smaller of x and y
                  // (or x if they compare equal) and the result of the comparison x <=> y.
                  template<typename _Tp>
                    constexpr auto
                    __min_cmp(_Tp __x, _Tp __y)
                    {
                      struct _Res {
                	_Tp _M_min;
                	decltype(__x <=> __y) _M_cmp;
                      };
                      auto __c = __x <=> __y;
                      if (__c > 0)
                	return _Res{__y, __c};
                      return _Res{__x, __c};
                    }
                
                  /**
                   *  @brief Performs dictionary comparison on ranges.
                   *  @ingroup sorting_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
                   *  @return   The comparison category that `__comp(*__first1, *__first2)`
                   *		returns.
                  */
                  template<typename _InputIter1, typename _InputIter2, typename _Comp>
                    constexpr auto
                    lexicographical_compare_three_way(_InputIter1 __first1,
                				      _InputIter1 __last1,
                				      _InputIter2 __first2,
                				      _InputIter2 __last2,
                				      _Comp __comp)
                    -> decltype(__comp(*__first1, *__first2))
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIter1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIter2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                #if __cpp_lib_is_constant_evaluated
                      using _Cat = decltype(__comp(*__first1, *__first2));
                      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);
                
                      if (!std::is_constant_evaluated())
                	if constexpr (same_as<_Comp, __detail::_Synth3way>
                		      || same_as<_Comp, compare_three_way>)
                	  if constexpr (__is_byte_iter<_InputIter1>)
                	    if constexpr (__is_byte_iter<_InputIter2>)
                	      {
                		const auto [__len, __lencmp] = _GLIBCXX_STD_A::
                		  __min_cmp(__last1 - __first1, __last2 - __first2);
                		if (__len)
                		  {
                		    const auto __c
                		      = __builtin_memcmp(&*__first1, &*__first2, __len) <=> 0;
                		    if (__c != 0)
                		      return __c;
                		  }
                		return __lencmp;
                	      }
                #endif // is_constant_evaluated
                      while (__first1 != __last1)
                	{
                	  if (__first2 == __last2)
                	    return strong_ordering::greater;
                	  if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
                	    return __cmp;
                	  ++__first1;
                	  ++__first2;
                	}
                      return (__first2 == __last2) <=> true; // See PR 94006
                    }
                
                  template<typename _InputIter1, typename _InputIter2>
                    constexpr auto
                    lexicographical_compare_three_way(_InputIter1 __first1,
                				      _InputIter1 __last1,
                				      _InputIter2 __first2,
                				      _InputIter2 __last2)
                    {
                      return _GLIBCXX_STD_A::
                	lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
                					  compare_three_way{});
                    }
                #endif // three_way_comparison
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,
                	__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                
                #if __cplusplus > 201103L
                
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    pair<_InputIterator1, _InputIterator2>
                    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	       _InputIterator2 __first2, _InputIterator2 __last2,
                	       _BinaryPredicate __binary_pred)
                    {
                      while (__first1 != __last1 && __first2 != __last2
                	     && __binary_pred(__first1, __first2))
                	{
                	  ++__first1;
                	  ++__first2;
                	}
                      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using @c == and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                	    typename iterator_traits<_InputIterator1>::value_type,
                	    typename iterator_traits<_InputIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                
                  /**
                   *  @brief Finds the places in ranges which don't match.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  An input iterator.
                   *  @param  __last1   An input iterator.
                   *  @param  __first2  An input iterator.
                   *  @param  __last2   An input iterator.
                   *  @param __binary_pred A binary predicate @link functors
                   *         functor@endlink.
                   *  @return   A pair of iterators pointing to the first mismatch.
                   *
                   *  This compares the elements of two ranges using the binary_pred
                   *  parameter, and returns a pair
                   *  of iterators.  The first iterator points into the first range, the
                   *  second iterator points into the second range, and the elements pointed
                   *  to by the iterators are not equal.
                  */
                  template<typename _InputIterator1, typename _InputIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    inline pair<_InputIterator1, _InputIterator2>
                    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
                	     _InputIterator2 __first2, _InputIterator2 __last2,
                	     _BinaryPredicate __binary_pred)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
                      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                      __glibcxx_requires_valid_range(__first2, __last2);
                
                      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,
                			     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
                    }
                #endif
                
                _GLIBCXX_END_NAMESPACE_ALGO
                
                  /// This is an overload used by find algos for the Input Iterator case.
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _InputIterator
                    __find_if(_InputIterator __first, _InputIterator __last,
                	      _Predicate __pred, input_iterator_tag)
                    {
                      while (__first != __last && !__pred(__first))
                	++__first;
                      return __first;
                    }
                
                  /// This is an overload used by find algos for the RAI case.
                  template<typename _RandomAccessIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    _RandomAccessIterator
         750 ->     __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
                	      _Predicate __pred, random_access_iterator_tag)
                    {
                      typename iterator_traits<_RandomAccessIterator>::difference_type
                	__trip_count = (__last - __first) >> 2;
                
                      for (; __trip_count > 0; --__trip_count)
                	{
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	}
                
                      switch (__last - __first)
                	{
                	case 3:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 2:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 1:
                	  if (__pred(__first))
                	    return __first;
                	  ++__first;
                	  // FALLTHRU
                	case 0:
                	default:
                	  return __last;
                	}
                    }
                
                  template<typename _Iterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    inline _Iterator
         750 ->     __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
                    {
                      return __find_if(__first, __last, __pred,
                		       std::__iterator_category(__first));
                    }
                
                  template<typename _InputIterator, typename _Predicate>
                    _GLIBCXX20_CONSTEXPR
                    typename iterator_traits<_InputIterator>::difference_type
                    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
                    {
                      typename iterator_traits<_InputIterator>::difference_type __n = 0;
                      for (; __first != __last; ++__first)
                	if (__pred(__first))
                	  ++__n;
                      return __n;
                    }
                
                #if __cplusplus >= 201103L
                  template<typename _ForwardIterator1, typename _ForwardIterator2,
                	   typename _BinaryPredicate>
                    _GLIBCXX20_CONSTEXPR
                    bool
                    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		     _ForwardIterator2 __first2, _BinaryPredicate __pred)
                    {
                      // Efficiently compare identical prefixes:  O(N) if sequences
                      // have the same elements in the same order.
                      for (; __first1 != __last1; ++__first1, (void)++__first2)
                	if (!__pred(__first1, __first2))
                	  break;
                
                      if (__first1 == __last1)
                	return true;
                
                      // Establish __last2 assuming equal ranges by iterating over the
                      // rest of the list.
                      _ForwardIterator2 __last2 = __first2;
                      std::advance(__last2, std::distance(__first1, __last1));
                      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
                	{
                	  if (__scan != std::__find_if(__first1, __scan,
                			  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
                	    continue; // We've seen this one before.
                
                	  auto __matches
                	    = std::__count_if(__first2, __last2,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
                	  if (0 == __matches ||
                	      std::__count_if(__scan, __last1,
                			__gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
                	      != __matches)
                	    return false;
                	}
                      return true;
                    }
                
                  /**
                   *  @brief  Checks whether a permutation of the second sequence is equal
                   *          to the first sequence.
                   *  @ingroup non_mutating_algorithms
                   *  @param  __first1  Start of first range.
                   *  @param  __last1   End of first range.
                   *  @param  __first2  Start of second range.
                   *  @return true if there exists a permutation of the elements in the range
                   *          [__first2, __first2 + (__last1 - __first1)), beginning with
                   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
                   *          returns true; otherwise, returns false.
                  */
                  template<typename _ForwardIterator1, typename _ForwardIterator2>
                    _GLIBCXX20_CONSTEXPR
                    inline bool
                    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                		   _ForwardIterator2 __first2)
                    {
                      // concept requirements
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
                      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
                      __glibcxx_function_requires(_EqualOpConcept<
                		typename iterator_traits<_ForwardIterator1>::value_type,
                		typename iterator_traits<_ForwardIterator2>::value_type>)
                      __glibcxx_requires_valid_range(__first1, __last1);
                
                      return std::__is_permutation(__first1, __last1, __first2,
                				   __gnu_cxx::__ops::__iter_equal_to_iter());
                    }
                #endif // C++11
                
                _GLIBCXX_END_NAMESPACE_VERSION
                } // namespace std
                
                // NB: This file is included within many other C++ includes, as a way
                // of getting the base algorithms. So, make sure that parallel bits
                // come in too if requested.
                #ifdef _GLIBCXX_PARALLEL
                # include <parallel/algobase.h>
                #endif
                
                #endif


Top 10 Lines:

     Line      Count

      313     313728
      230     113879
      254      56939
      328        873
      486        873
      521        873
      527        873
      400        872
      644        872
     2061        750

Execution Summary:

       21   Executable lines in this file
       21   Lines executed
   100.00   Percent of the file executed

   491284   Total number of line executions
 23394.48   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Player.cpp:
                #include <SFML/Graphics.hpp>
                #include "Player.h"
                #include "Game.h"
                //#include "PathFinding.h"
                #include "GameState.h"
                #include "Node.h"
                #include "MCTS.h"
                
           2 -> Player::Player(int id, int x, int y, int speed, std::string texturePath, PlayerType type, int zoom) {
                    this->id = id;
                    this->x = x;
                    this->y = y;
                    this->speed = speed;
                    this->type = type;
                    alive = true;
                    strength = DEFAULT_PLAYER_STRENGTH;
                    numBombs = DEFAULT_PLAYER_BOMBS;
                
                    if (!texture.loadFromFile(texturePath)) {
                        // handle error
                    }
                    sprite.setTexture(texture);
                    sprite.setScale(1.0/zoom, 1.0/zoom);
                }
                
         398 -> void Player::draw(sf::RenderWindow &window, int zoom) {
                    sprite.setTexture(texture);
                    sprite.setPosition(
                        (x * TILE_SIZE)/zoom,
                        (y * TILE_SIZE)/zoom
                    );
                    window.draw(sprite);
                }
                
        3111 -> void Player::move(int dx, int dy) {
                    x += dx * speed;
                    y += dy * speed;
                }
                
        7224 -> void Player::play(Action action, GameState &state) {
                        switch (action) {
                        case MOVE_UP:
                            if(isLegalMove(x, y-1, state)) {
                                move(0, -1);
                            }
                            break;
                        case MOVE_DOWN:
                            if(isLegalMove(x, y+1, state)) {
                                move(0, 1);
                            }
                            break;
                        case MOVE_LEFT:
                            if(isLegalMove(x-1, y, state)) {
                                move(-1, 0);
                            }
                            break;
                        case MOVE_RIGHT:
                            if(isLegalMove(x+1, y, state)) {
                                move(1, 0);
                            }
                            break;
                        case PLACE_BOMB:
                            if (dropBomb()) {
                                state.bombs.push_back(
                                    Bomb(
                                        x,
                                        y,
                                        DEFAULT_BOMB_TIMER,
                                        strength,
                                        id
                                    )
                                );
                            }
                            break;
                        default:
                            break;
                    }
                
                }
                
           2 -> void Player::update(GameState &gamestate) {
                    if (type == AI) {
                        /*if(!PathFinding::isSafe(x, y, game, *this)) {
                            std::vector<std::pair<int, int>> path = PathFinding::findNearestSafePath(x, y, game, *this);
                            
                            if (path.size() > 0) {
                                std::pair<int, int> nextMove = path[0];
                                
                                // move uses the difference between the current position and the next position
                                move(nextMove.first-x, nextMove.second-y);
                            }
                        }*/
                        MCTS mtcs = MCTS();
                        std::cout << "Finding best action..." << std::endl;
                        Action action = mtcs.findBestAction(gamestate);
                        std::cout << "Action: " << action << std::endl;
                        play(action, gamestate);
                        exit(0);
                    }
                }
                
        1110 -> bool Player::dropBomb() {
                    if (numBombs > 0) {
                        numBombs--;
                        return true;
                    }
                    return false;
                }
                
         894 -> void Player::die() {
                    // handle player death
                    //std::cout << "Player died!" << std::endl;
                    alive = false;
                }
                
           6 -> void Player::addBonus(int type) {
                    if (type == STRENGTH) {
                        strength++;
                    } else if (type == NUMBOMB) {
                        numBombs++;
                    }
                }
                
        3111 -> bool Player::isLegalMove(int x, int y, GameState &state) {
                    if(state.level.isEmpty(x, y)) {
                        // Check if there is a bomb at the position
                        for (long unsigned i = 0; i < state.bombs.size(); ++i) {
                            if (state.bombs[i].getX() == x && state.bombs[i].getY() == y) {
                                return false;
                            }
                        }
                        // Check if there is a player at the position
                        for (int i = 0; i < 2; ++i) {
                            if(this->x == x && this->y == y) {
                                return false;
                            }
                            if (state.players[i].getX() == x && state.players[i].getY() == y) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
           1 -> }

Top 10 Lines:

     Line      Count

       40       7224
       35       3111
      124       3111
      102       1110
      110        894
       26        398
      116          6
        9          2
       81          2
      144          1

Execution Summary:

       10   Executable lines in this file
       10   Lines executed
   100.00   Percent of the file executed

    15859   Total number of line executions
  1585.90   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/PathFinding.cpp:
                #include "PathFinding.h"
                #include <optional>
                #include <iostream>
                
       ##### -> std::vector<Action> PathFinding::getLegalMoves(int x, int y, GameState &state, Player player) {
                    std::vector<Action> legalMoves;
                    // Check the 4 possible moves
                    if (player.isLegalMove(x + 1, y, state)) {
                        legalMoves.push_back(MOVE_RIGHT);
                    }
                    if (player.isLegalMove(x - 1, y, state)) {
                        legalMoves.push_back(MOVE_LEFT);
                    }
                    if (player.isLegalMove(x, y + 1, state)) {
                        legalMoves.push_back(MOVE_DOWN);
                    }
                    if (player.isLegalMove(x, y - 1, state)) {
                        legalMoves.push_back(MOVE_UP);
                    }
                    return legalMoves;
                }
                
       ##### -> bool PathFinding::isSafe(int x, int y, GameState &state, Player player) {
                    // if is a legal move
                    if(!player.isLegalMove(x, y, state)) {
                        return false;
                    }
                    for (Bomb &bomb : state.bombs) {
                        // Check the bomb explosion area
                        for (int i = 0; i < 4; ++i) {
                            for (int j = 1; j <= bomb.getStrength(); ++j) {
                                int dx = 0;
                                int dy = 0;
                                if (i == 0) {
                                    dx = j;
                                } else if (i == 1) {
                                    dx = -j;
                                } else if (i == 2) {
                                    dy = j;
                                } else if (i == 3) {
                                    dy = -j;
                                }
                
                                int new_x = x + dx;
                                int new_y = y + dy;
                
                                if (state.level.isDestroyable(new_x, new_y)) {
                                    break;
                                } else if (state.level.isundestroyWall(new_x, new_y)) {
                                    break;
                                } else if (new_x == bomb.getX() && new_y == bomb.getY()) {
                                    return false;
                                }
                            }
                        }
                    }
                    return true;
                }
                
       ##### -> std::vector<Action> PathFinding::findNearestSafePath(int x, int y, GameState &state, Player player) {
                    std::vector<Action> path;
                    std::queue<PathFindingNode*> queue;
                    queue.push(
                        new PathFindingNode{
                            x,
                            y,
                            0,
                            NO_ACTION,
                            nullptr
                        }
                    );
                    std::vector<std::vector<bool>> visited(state.level.getWidth(), std::vector<bool>(state.level.getHeight(), false));
                    visited[x][y] = true;
                
                    while (!queue.empty()) {
                        PathFindingNode* current = queue.front();
                        queue.pop();
                
                        if (isSafe(current->x, current->y, state, player)) {
                            while (current->parent != nullptr) {
                                path.push_back(current->action);
                                current = current->parent;
                            }
                            std::reverse(path.begin(), path.end());
                            return path;
                        }
                
                        std::vector<Action> legalMoves = getLegalMoves(current->x, current->y, state, player);
                        for (Action action : legalMoves) {
                            int dx = 0;
                            int dy = 0;
                            if (action == MOVE_UP) {
                                dy = -1;
                            } else if (action == MOVE_DOWN) {
                                dy = 1;
                            } else if (action == MOVE_LEFT) {
                                dx = -1;
                            } else if (action == MOVE_RIGHT) {
                                dx = 1;
                            }
                
                            int new_x = current->x + dx;
                            int new_y = current->y + dy;
                
                            if (!visited[new_x][new_y]) {
                                visited[new_x][new_y] = true;
                                queue.push(
                                    new PathFindingNode{
                                        new_x,
                                        new_y,
                                        current->distance + 1,
                                        action,
                                        current
                                    }
                                );
                            }
                        }
                    }
                    path.push_back(NO_ACTION);
                    return path;
           1 -> }

Top 10 Lines:

     Line      Count

      121          1

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.25   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/MCTS.cpp:
                #include "GameState.h"
                #include "Node.h"
                #include "MCTS.h"
                #include "Bomb.h"
                #include "fast_log.hpp"
                #include "PathFinding.h"
                
                #include <cmath>
                #include <iostream>
                #include <utility>
                #include <thread>
                #include <mutex>
                
                fast_log fast_lg;
                
        8449 -> Node* bestChild(Node* node) {
                    // If node->state.AIturn, return a random child node
                    if (!node->state.AIturn) {
                        std::cout << "Returning the lowest winrate child" << std::endl;
                        double wr = 1000000000;
                        Node* bestChild = nullptr;
                        for (Node* child : node->children) {
                            double child_wr = (double)child->wins / child->visits;
                            if (child_wr < wr) {
                                wr = child_wr;
                                bestChild = child;
                            }
                        }
                        return bestChild;
                    }
                
                    // Return the child node with the highest or lowest value based on node->AIturn
                    double bestValue = node->state.AIturn ? -1000000000 : 1000000000;
                    Node* bestChild = nullptr;
                
                    std::cout << "AIturn: " << node->state.AIturn << std::endl;
                
                    for (Node* child : node->children) {
                        const float log_of_N = fast_lg.log(node->visits);
                        double value = (double)child->wins / child->visits + sqrt(2 * log_of_N / child->visits);
                
                        //std::cout << "Child: " << child->actionTaken << " Wins: " << child->wins << " Visits: " << child->visits << " Value: " << value << std::endl;
                
                        if (node->state.AIturn) {
                            // If AIturn is true, find the child with the highest value
                            if (value > bestValue) {
                                bestValue = value;
                                bestChild = child;
                            }
                        } else {
                            // If AIturn is false, find the child with the lowest value
                            if (value < bestValue) {
                                bestValue = value;
                                bestChild = child;
                            }
                        }
                    }
                
                    if (bestChild == nullptr) {
                        std::cout << "No best child, This might be an error" << std::endl;
                    } else {
                        //std::cout << "Best child: " << bestChild->actionTaken << " Wins: " << bestChild->wins << " Visits: " << bestChild->visits << std::endl;
                    }
                
                    return bestChild;
                }
                
                
        1000 -> void backpropagate(Node* node, int result) {
                    // Update the node's statistics based on the result of the game
                
                    node->visits++;
                    node->wins += result;
                
                    if (node->parent != nullptr) {
                        backpropagate(node->parent, result);
                    }
                
                }
                
       16837 -> bool isTerminal(const GameState& state, int depth = 0) {
                    // Check if the game is over
                    if(state.winner != NO_WINNER) {
                        return true;
                    }
                    // Check if the game is more than a certain number of turns
                    if(state.turns - depth >= MAX_TURNS) {
                        return true;
                    }
                    return false;
                }
                
       16503 -> std::vector<Action> getPossibleActions(GameState& state) {
                    std::vector<Action> possibleActions;
                
                    int playerId = 0;
                
                    if (state.AIturn)
                        playerId = 1;
                
                    int bombSize = state.bombs.size();
                    // Check if the player can move up
                    if (state.level.isEmpty(state.players[playerId].getX(), state.players[playerId].getY() - 1)) {
                        bool canPlay = true;
                
                        // check if there is a bomb at the position
                        for (long unsigned i = 0; i < bombSize; ++i) {
                            if (state.bombs[i].getX() == state.players[playerId].getX() && state.bombs[i].getY() == state.players[playerId].getY() - 1) {
                                canPlay = false;
                                break;
                            }
                        }
                        // check if there is a player at the position
                        for (const auto & player : state.players) {
                            if (player.getX() == state.players[playerId].getX() && player.getY() == state.players[playerId].getY() - 1) {
                                canPlay = false;
                                break;
                            }
                        }
                        if (canPlay) {
                            possibleActions.push_back(MOVE_UP);
                        }
                    }
                    // Check if the player can move down
                    if (state.level.isEmpty(state.players[playerId].getX(), state.players[playerId].getY() + 1)) {
                        bool canPlay = true;
                        
                        // check if there is a bomb at the position
                        for (long unsigned i = 0; i < bombSize; ++i) {
                            if (state.bombs[i].getX() == state.players[playerId].getX() && state.bombs[i].getY() == state.players[playerId].getY() + 1) {
                                canPlay = false;
                                break;
                            }
                        }
                        // check if there is a player at the position
                        for (const auto & player : state.players) {
                            if (player.getX() == state.players[playerId].getX() && player.getY() == state.players[playerId].getY() + 1) {
                                canPlay = false;
                                break;
                            }
                        }
                        if (canPlay) {
                            possibleActions.push_back(MOVE_DOWN);
                        }
                    }
                    // Check if the player can move left
                    if (state.level.isEmpty(state.players[playerId].getX() - 1, state.players[playerId].getY())) {
                        bool canPlay = true;
                        
                        // check if there is a bomb at the position
                        for (long unsigned i = 0; i < bombSize; ++i) {
                            if (state.bombs[i].getX() == state.players[playerId].getX() - 1 && state.bombs[i].getY() == state.players[playerId].getY()) {
                                canPlay = false;
                                break;
                            }
                        }
                        // check if there is a player at the position
                        for (const auto & player : state.players) {
                            if (player.getX() == state.players[playerId].getX() - 1 && player.getY() == state.players[playerId].getY()) {
                                canPlay = false;
                                break;
                            }
                        }
                        if (canPlay) {
                            possibleActions.push_back(MOVE_LEFT);
                        }
                    }
                    // Check if the player can move right
                    if (state.level.isEmpty(state.players[playerId].getX() + 1, state.players[playerId].getY())) {
                        bool canPlay = true;
                        
                        // check if there is a bomb at the position
                        for (long unsigned i = 0; i < bombSize; ++i) {
                            if (state.bombs[i].getX() == state.players[playerId].getX() + 1 && state.bombs[i].getY() == state.players[playerId].getY()) {
                                canPlay = false;
                                break;
                            }
                        }
                        // check if there is a player at the position
                        for (const auto & player : state.players) {
                            if (player.getX() == state.players[playerId].getX() + 1 && player.getY() == state.players[playerId].getY()) {
                                canPlay = false;
                                break;
                            }
                        }
                        if (canPlay) {
                            possibleActions.push_back(MOVE_RIGHT);
                        }
                    }
                
                    // Add other possible actions here
                    if (state.players[playerId].getNumBombs() > 0)
                        possibleActions.push_back(PLACE_BOMB);
                    possibleActions.push_back(NO_ACTION);
                
                    return possibleActions;
                }
                
        9281 -> bool isFullyExpanded(Node* node) {
                    // Check if all possible actions have been tried
                    return node->children.size() == getPossibleActions(node->state).size();
                }
                
        7222 -> GameState getNewState(const GameState& state, Action action, bool AIturn) {
                    // Get the new game state resulting from taking the action
                    GameState newState = state;
                
                    if (AIturn) {
                        newState.players[1].play(action, newState);
                    } else {
                        newState.players[0].play(action, newState);
                        newState.AIturn = true;
                    }
                
                    return newState;
                }
                
        1000 -> int defaultPolicy(GameState state, int depth = 0) {
                    // Simulate a random game and return the result
                    std::vector<std::pair<int, Action>> actions;
                    while (!isTerminal(state, depth)) {
                        if(state.AIturn) {
                            std::vector<Action> possibleActionsAI = getPossibleActions(state);
                
                            Action actionTakenAI;
                            /*if(PathFinding::isSafe(state.players[1].getX(), state.players[1].getY(), state, state.players[1])) {
                                // for each possible action, check if it is safe
                                std::vector<Action> safepossibleActionsAI;
                                for (Action action : possibleActionsAI) {
                                    GameState newState = getNewState(state, action, state.AIturn);
                                    switch(action) {
                                        case MOVE_UP:
                                            if(PathFinding::isSafe(state.players[1].getX(), state.players[1].getY() - 1, newState, state.players[1])) {
                                                safepossibleActionsAI.push_back(action);
                                            }
                                            break;
                                        case MOVE_DOWN:
                                            if(PathFinding::isSafe(state.players[1].getX(), state.players[1].getY() + 1, newState, state.players[1])) {
                                                safepossibleActionsAI.push_back(action);
                                            }
                                            break;
                                        case MOVE_LEFT:
                                            if(PathFinding::isSafe(state.players[1].getX() - 1, state.players[1].getY(), newState, state.players[1])) {
                                                safepossibleActionsAI.push_back(action);
                                            }
                                            break;
                                        case MOVE_RIGHT:
                                            if(PathFinding::isSafe(state.players[1].getX() + 1, state.players[1].getY(), newState, state.players[1])) {
                                                safepossibleActionsAI.push_back(action);
                                            }
                                            break;
                                        default:
                                            safepossibleActionsAI.push_back(action);
                                            break;
                                    }
                                }
                
                                // If the AI is in a safe position, choose a random action
                                Action actionTakenAI = safepossibleActionsAI[rand() % safepossibleActionsAI.size()];                
                            } else {
                                std::vector<Action> path = PathFinding::findNearestSafePath(state.players[1].getX(), state.players[1].getY(), state, state.players[1]);
                                if(path.size() == 0) {
                                    actionTakenAI = NO_ACTION;
                                } else {
                                    actionTakenAI = path[0];
                                }
                            }*/
                            actionTakenAI = possibleActionsAI[rand() % possibleActionsAI.size()];
                
                            actions.push_back(std::make_pair(state.AIturn, actionTakenAI));
                            state = getNewState(state, actionTakenAI, state.AIturn);
                            state.update();
                        } else {
                            std::vector<Action> possibleActionsPlayer = getPossibleActions(state);
                
                            Action actionPlayer;
                            /*if (PathFinding::isSafe(state.players[0].getX(), state.players[0].getY(), state, state.players[0])) {
                                // for each possible action, check if it is safe
                                std::vector<Action> safepossibleActionsPlayer;
                                for (Action action : possibleActionsPlayer) {
                                    GameState newState = getNewState(state, action, state.AIturn);
                                    switch(action) {
                                        case MOVE_UP:
                                            if(PathFinding::isSafe(state.players[0].getX(), state.players[0].getY() - 1, newState, state.players[0])) {
                                                safepossibleActionsPlayer.push_back(action);
                                            }
                                            break;
                                        case MOVE_DOWN:
                                            if(PathFinding::isSafe(state.players[0].getX(), state.players[0].getY() + 1, newState, state.players[0])) {
                                                safepossibleActionsPlayer.push_back(action);
                                            }
                                            break;
                                        case MOVE_LEFT:
                                            if(PathFinding::isSafe(state.players[0].getX() - 1, state.players[0].getY(), newState, state.players[0])) {
                                                safepossibleActionsPlayer.push_back(action);
                                            }
                                            break;
                                        case MOVE_RIGHT:
                                            if(PathFinding::isSafe(state.players[0].getX() + 1, state.players[0].getY(), newState, state.players[0])) {
                                                safepossibleActionsPlayer.push_back(action);
                                            }
                                            break;
                                        default:
                                            safepossibleActionsPlayer.push_back(action);
                                            break;
                                    }
                                }
                
                                // If the player is in a safe position, choose a random action
                                actionPlayer = safepossibleActionsPlayer[rand() % safepossibleActionsPlayer.size()];
                            } else {
                                std::vector<Action> path = PathFinding::findNearestSafePath(state.players[0].getX(), state.players[0].getY(), state, state.players[0]);
                                if(path.size() == 0) {
                                    actionPlayer = NO_ACTION;
                                } else {
                                    actionPlayer = path[0];
                                }
                            }*/
                            actionPlayer = possibleActionsPlayer[rand() % possibleActionsPlayer.size()];
                            
                            actions.push_back(std::make_pair(state.AIturn, actionPlayer));
                            state = getNewState(state, actionPlayer, state.AIturn);
                        }
                    }
                
                    if (state.winner == NO_WINNER) {
                        return 0;
                    } else if (state.winner == PLAYER2) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                
         833 -> Node* expand(Node* node) {
                
                    // Get a list of possible actions from the current state
                    std::vector<Action> possibleActions = getPossibleActions(node->state);
                
                    // Remove actions that have already a node in the tree
                    for (Node* child : node->children) {
                        possibleActions.erase(
                            std::remove(
                                possibleActions.begin(),
                                possibleActions.end(),
                                child->actionTaken
                            ),
                            possibleActions.end()
                        );
                    }
                
                    // Choose a random action from the remaining actions
                    Action action = possibleActions[rand() % possibleActions.size()];
                
                    GameState newState = getNewState(node->state, action, node->state.AIturn);
                    // If the AI is playing, update the board
                    if(node->state.AIturn) {
                        newState.update();
                    }
                    Node* newNode = new Node(newState, action, node, true);    
                
                    // Add the new node to the children of the current node
                    node->children.push_back(newNode);
                
                    return newNode;
                }
                
        1000 -> Node* treePolicy(Node* node) {
                    while (!isTerminal(node->state, node->state.turns)) {
                        if (!isFullyExpanded(node)) {
                            return expand(node);
                        } else {
                            node = bestChild(node);
                        }
                    }
                    return node;
                }
                
           1 -> void log_tree(Node* node, int depth = 0) {
                    for (int i = 0; i < depth; ++i) {
                        std::cout << "  ";
                    }
                    std::cout << "Action: " << node->actionTaken << " By " << !node->state.AIturn << " Wins: " << node->wins << " Visits: " << node->visits << std::endl;
                    for (Node* child : node->children) {
                        log_tree(child, depth + 1);
                    }
                }
                
           1 -> double calculateWinPercentage(Node* node) {
                    if (node->visits == 0) {
                        return 0.0;  // to avoid division by zero
                    }
                    return static_cast<double>(node->wins + node->visits) / static_cast<double>(2*node->visits);
                }
                
           1 -> Action MCTS::findBestAction(GameState& currentState) {
                    Node* root = new Node(currentState, NO_ACTION, nullptr, true);
                
                    for (int i = 0; i < NUM_SIMULATIONS; ++i) {
                        Node* node = treePolicy(root);
                        int result = defaultPolicy(node->state, node->state.turns);
                        backpropagate(node, result);
                    }
                
                    if(root->children.size() == 0) {
                        std::cout << "No children" << std::endl;
                        return NO_ACTION;
                    }
                
                    log_tree(root);
                    
                    Node* bestChildNode = bestChild(root);
                    // Write what the AI thinks is the it's winning percentage
                    std::cout << "Winning percentage: " << calculateWinPercentage(bestChildNode)*100 << std::endl;
                
                    return bestChildNode->actionTaken;
           1 -> }

Top 10 Lines:

     Line      Count

       81      16837
       93      16503
      199       9281
       16       8449
      204       7222
       69       1000
      218       1000
      368       1000
      335        833
      379          1

Execution Summary:

       13   Executable lines in this file
       13   Lines executed
   100.00   Percent of the file executed

    62129   Total number of line executions
  4779.15   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/main.cpp:
                // Pseudocode
                #include <SFML/Graphics.hpp>
                #include <iostream>
                #include "Game.h"
                
                int main(int argc, char** argv)
       ##### -> {
                    srand(time(NULL));
                    // Print a message to the console
                    std::cout << "Game starting" << std::endl;
                    Game game;
                    // Level number is the first argument
                    int level_nb = 1;
                    if (argc > 1)
                        level_nb = atoi(argv[1]);
                    game.load(level_nb);
                    std::cout << "Game loaded" << std::endl;
                    game.run();
                    std::cout << "Game finished" << std::endl;
                    exit(0);
           1 -> }
                


Top 10 Lines:

     Line      Count

       21          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.50   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Level.cpp:
                #include <string>
                #include <fstream>
                #include "Level.h"
                #include "Game.h"
                #include <iostream>
                #include <SFML/Graphics.hpp>
                
           1 -> std::vector<Bomb> Level::load(unsigned int levelNumber) {
                
                    std::string filePath = "assets/levels/" + std::to_string(levelNumber) + ".txt";
                    std::ifstream file(filePath);
                
                    if (file.is_open()) {
                        std::string line;
                        int row = 0;
                        width = 0;
                        height = 0;
                
                        while (std::getline(file, line)) {
                            if (line.size() > width) {
                                width = line.size();
                            }
                            levelData.push_back(line);
                            row++;
                        }
                        height = row;
                
                        file.close();
                    }
                
                    // If this is a bomb tile "B", add a bomb to the game and replace the tile with a space
                    std::vector<Bomb> bombs;
                    for (size_t i = 0; i < height; ++i) {
                        for (size_t j = 0; j < width; ++j) {
                            if (levelData[i][j] == 'B') {
                                bombs.push_back(
                                    Bomb(
                                        j,
                                        i,
                                        DEFAULT_BOMB_TIMER,
                                        1,
                                        std::nullopt
                                    )
                                );
                                levelData[i][j] = ' ';
                            }
                        }
                    }
                
                    // Find a random "S" tile to spawn the player
                    for (size_t i = 0; i < height; ++i) {
                        for (size_t j = 0; j < width; ++j) {
                            if (levelData[i][j] == 'S') {
                                spawnPositions.push_back(std::make_pair(j, i));
                            }
                        }
                    }
                
                    return bombs;
                }
                
         199 -> void Level::draw(sf::RenderWindow &window, int zoom) {
                    sf::Texture wall1texture;
                    if (!wall1texture.loadFromFile("assets/img/wall1.png")) {
                        // handle error
                    }
                    sf::Sprite wall1sprite;
                    wall1sprite.scale(1.0/zoom, 1.0/zoom);
                    wall1sprite.setTexture(wall1texture);
                
                    sf::Texture wall2texture;
                    if (!wall2texture.loadFromFile("assets/img/wall2.png")) {
                        // handle error
                    }
                    sf::Sprite wall2sprite;
                    wall2sprite.scale(1.0/zoom, 1.0/zoom);
                    wall2sprite.setTexture(wall2texture);
                
                    sf::Texture Voidtexture;
                    if (!Voidtexture.loadFromFile("assets/img/void.png")) {
                        // handle error
                    }
                    sf::Sprite voidsprite;
                    voidsprite.scale(1.0/zoom, 1.0/zoom);
                    voidsprite.setTexture(Voidtexture);
                
                    for (long unsigned i = 0; i < levelData.size(); ++i) {
                        for (long unsigned j = 0; j < levelData[i].size(); ++j) {
                            if (levelData[i][j] == 'X') {
                                wall1sprite.setPosition(
                                    j * wall1texture.getSize().x/zoom,
                                    i * wall1texture.getSize().y/zoom
                                );
                                window.draw(wall1sprite);
                            } else if (levelData[i][j] == '.') {
                                wall2sprite.setPosition(
                                    j * wall2texture.getSize().x/zoom,
                                    i * wall2texture.getSize().y/zoom
                                );
                                window.draw(wall2sprite);
                            } else {
                                voidsprite.setPosition(
                                    j * Voidtexture.getSize().x/zoom,
                                    i * Voidtexture.getSize().y/zoom
                                );
                                window.draw(voidsprite);
                            }
                        }
                    }
                }
                
       69123 -> bool Level::isEmpty(int x, int y) {
                    // out of bounds
                    if (x < 0 || y < 0 || x >= (int) width || y >= (int) height) {
                        return false;
                    }
                    // Umbreakable wall
                    if(levelData[y][x] == 'X') {
                        return false;
                    }
                    // Breakable wall
                    if(levelData[y][x] == '.') {
                        return false;
                    }
                    return true;
                }
                
        4997 -> bool Level::isDestroyable(int x, int y) {
                    // out of bounds
                    if (x < 0 || y < 0 || x >= (int) width || y >= (int) height) {
                        return false;
                    }
                    // Breakable wall
                    if(levelData[y][x] == '.') {
                        return true;
                    }
                    return false;
                }
                
        4030 -> bool Level::isundestroyWall(int x, int y) {
                    return levelData[y][x] == 'X';
                }
                
         967 -> void Level::destroyWall(int x, int y) {
                    levelData[y][x] = ' ';
           1 -> }

Top 10 Lines:

     Line      Count

      112      69123
      128       4997
      140       4030
      144        967
       62        199
        8          1
      146          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

    79318   Total number of line executions
 11331.14   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/HUD.cpp:
                #include "HUD.h"
                #include "Game.h"
                
         199 -> void HUD::draw(sf::RenderWindow &window, Game &game) {
                    // Draw a white rectangle at the bottom of the screen
                    sf::RectangleShape rectangle(sf::Vector2f(window.getSize().x, HUD_HEIGHT));
                    rectangle.setFillColor(sf::Color(0, 0, 0));
                    rectangle.setPosition(0, window.getSize().y - HUD_HEIGHT);
                    window.draw(rectangle);
                
                    // Load the font
                    sf::Font font;
                    if (!font.loadFromFile("assets/fonts/arial.ttf")) {
                        // handle error
                    }
                
                    // Draw the number of bombs the player has
                    sf::Text text;
                    text.setFont(font);
                    text.setCharacterSize(24);
                    text.setFillColor(sf::Color::White);
                    text.setPosition(10, window.getSize().y - HUD_HEIGHT);
                    text.setString("Bombs: " + std::to_string(game.getPlayers()[0].getNumBombs()));
                    window.draw(text);
                
                    // Draw the strength of the player
                    sf::Text text2;
                    text2.setFont(font);
                    text2.setCharacterSize(24);
                    text2.setFillColor(sf::Color::White);
                    text2.setPosition(10, window.getSize().y - HUD_HEIGHT + 25);
                    text2.setString("Strenght: " + std::to_string(game.getPlayers()[0].getStrength()));
                    window.draw(text2);
                
                    // Draw the number of bombs the AI has
                    sf::Text text3;
                    text3.setFont(font);
                    text3.setCharacterSize(24);
                    text3.setFillColor(sf::Color::White);
                    text3.setPosition(200, window.getSize().y - HUD_HEIGHT);
                    text3.setString("Bombs: " + std::to_string(game.getPlayers()[1].getNumBombs()));
                    window.draw(text3);
                
                    // Draw the strength of the AI
                    sf::Text text4;
                    text4.setFont(font);
                    text4.setCharacterSize(24);
                    text4.setFillColor(sf::Color::White);
                    text4.setPosition(200, window.getSize().y - HUD_HEIGHT + 25);
                    text4.setString("Strenght: " + std::to_string(game.getPlayers()[1].getStrength()));
                    window.draw(text4);
           1 -> }

Top 10 Lines:

     Line      Count

        4        199
       52          1

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

      200   Total number of line executions
   100.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/GameState.cpp:
                #include "GameState.h"
                #include <iostream>
                
        7610 -> void GameState::PlayerCheckBonus(Player &player) {
                    int bonusSize = bonuses.size();
                    for (long unsigned i = 0; i < bonusSize; ++i) {
                        if (player.getX() == bonuses[i].getX() && player.getY() == bonuses[i].getY()) {
                            player.addBonus(bonuses[i].getType());
                            bonuses.erase(bonuses.begin() + i);
                        }
                    }
                }
                
                void GameState::update()
        3805 -> {
                    //std::cout << "Turn " << turns << std::endl;
                
                    // Update the players
                    int playerSize = players.size();
                    for (int i = 0; i < playerSize; ++i) {
                        PlayerCheckBonus(players[i]);
                    }
                    
                    // Update the bombs
                    int bombSize = bombs.size();
                    for (int i = bombSize - 1; i >= 0; --i) {
                        //std::cout << "bomb " << i << " time left: " << bombs[i].getTimeLeft() << std::endl;
                        if(bombs[i].getTimeLeft() > 0) {
                            bombs[i].update();
                            bombs[i].changeTexture();
                        } else {
                            // Explode the bomb
                            std::vector<std::pair<int, int>> flamePositions = bombs[i].explode(*this);
                
                            // Add the flames to the list of flames
                            int flamePosistionSize = flamePositions.size();
                            for (long unsigned j = 0; j < flamePosistionSize; ++j) {
                                flames.push_back(
                                    Flame(flamePositions[j].first, flamePositions[j].second)
                                );
                            }
                            // add a bomb to the player
                            std::optional<int> owner = bombs[i].getOwner();
                            if (owner.has_value()) {
                                players[owner.value()].addBomb();
                            }
                            // Remove the bomb
                            bombs.erase(bombs.begin() + i);
                        }
                    }
                    
                    // Recursively explode the bombs
                    bool explosion = true;
                    while (explosion) {
                        explosion = false;
                        int bombSize = bombs.size();
                        for (int i = bombSize - 1; i >= 0; --i) {
                            // if the bomb is on a flame, explode it
                            int flameSize = flames.size();
                            for (long unsigned j = 0; j < flameSize; ++j) {
                                if (bombs[i].getX() == flames[j].getX() && bombs[i].getY() == flames[j].getY()) {
                                    std::vector<std::pair<int, int>> flamePositions = bombs[i].explode(*this);
                                    for (long unsigned j = 0; j < flamePositions.size(); ++j) {
                                        flames.push_back(
                                            Flame(flamePositions[j].first, flamePositions[j].second)
                                        );
                                        flameSize++;
                                    }
                                    std::optional<int> owner = bombs[i].getOwner();
                                    if (owner.has_value()) {
                                        players[owner.value()].addBomb();
                                    }
                                    bombs.erase(bombs.begin() + i);
                                    explosion = true;
                                    break;
                                }
                            }
                        }
                    }
                
                    // Update the flames
                    int flameSize = flames.size();
                    for (int i = flameSize -1; i >= 0; --i) {
                        if (flames[i].getTimeLeft() > 0) {
                            flames[i].update();
                        } else {
                            flames.erase(flames.begin() + i);
                        }
                    }
                
                    int numAlive = 0;
                    for (int i = 0; i < playerSize; ++i) {
                        if (players[i].isAlive()) {
                            numAlive++;
                        }
                    }
                    if (numAlive == 0) {
                        winner = DRAW;
                    } else if (numAlive == 1) {
                        if (players[0].isAlive()) {
                            winner = PLAYER1;
                        } else {
                            winner = PLAYER2;
                        }
                    }
                
                    turns++;
                    AIturn = false;
           1 -> }

Top 10 Lines:

     Line      Count

        4       7610
       15       3805
      109          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    11416   Total number of line executions
  3805.33   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Game.cpp:
                #include <SFML/Graphics.hpp>
                #include <iostream>
                #include "Level.h"
                #include "Game.h"
                #include "Player.h"
                #include "Bomb.h"
                #include "Bonus.h"
                #include "HUD.h"
                #include "GameState.h"
                #include <optional>
                #include <algorithm>
                
           1 -> void Game::load(unsigned int level_nb) {
                    // Create a new level
                    std::vector<Bomb> bombs = gameState.level.load(level_nb);
                
                    zoom = 1.0;
                
                    int X_size = gameState.level.getWidth() * TILE_SIZE;
                    int Y_size = gameState.level.getHeight() * TILE_SIZE;
                    while (X_size > MAX_WINDOW_X * TILE_SIZE || Y_size > MAX_WINDOW_Y * TILE_SIZE) {
                        X_size /= 2;
                        Y_size /= 2;
                        zoom=zoom*2.0;
                    }
                
                    // Create a window of the right size
                    window.create(
                        sf::VideoMode(
                            X_size,
                            Y_size + HUD_HEIGHT
                        ),
                        "Bomberman",
                        sf::Style::Titlebar | sf::Style::Close
                    );
                    //window.setFramerateLimit(60); // Limit the frame rate to 60 frames per second
                
                    // Randomly choose a spawn position for the player
                    std::vector<std::pair<int, int>> spawnPositions = gameState.level.getSpawnPositions();
                    int SpawnPositionsSize = spawnPositions.size();
                    int randomIndex = rand() % SpawnPositionsSize;
                
                    // Create the players and set their positions
                    gameState.players.push_back(Player(
                        0,
                        spawnPositions[randomIndex].first,
                        spawnPositions[randomIndex].second,
                        DEFAULT_PLAYER_SPEED,
                        "assets/img/player.png",
                        PLAYER,
                        zoom
                    ));
                    gameState.players.push_back(Player(
                        1,
                        spawnPositions[(randomIndex + 1) % SpawnPositionsSize].first,
                        spawnPositions[(randomIndex + 1) % SpawnPositionsSize].second,
                        DEFAULT_PLAYER_SPEED,
                        "assets/img/ai.png",
                        AI,
                        zoom
                    ));
                    gameState.bombs = bombs;
                }
                
                void Game::run()
           1 -> {
                    while (window.isOpen())
                    {
                        if (gameState.winner == NO_WINNER) {
                            gameState.AIturn = false;
                            processEvents();
                
                            window.clear(sf::Color::Black); // Clear the window with black color
                
                            render();
                            if (gameState.AIturn) {
                                update();
                            }
                
                            window.display(); // End the current frame and display everything
                        } else {
                            std::cout << "The winner is: ";
                            if (gameState.winner == PLAYER1) {
                                std::cout << "Player 1" << std::endl;
                            } else if (gameState.winner == PLAYER2) {
                                std::cout << "Player 2" << std::endl;
                            } else {
                                std::cout << "Nobody" << std::endl;
                            }
                            window.close();
                        }
                            window.display(); // End the current frame and display everything
                    }
                }
                
                void Game::processEvents()
         199 -> {
                    sf::Event event;
                    while (window.pollEvent(event))
                    {
                        if (event.type == sf::Event::Closed)
                            window.close();
                        else if (event.type == sf::Event::KeyPressed) {
                            // print player strength and number of bombs
                            if (event.key.code == sf::Keyboard::Up) {
                                gameState.players[0].play(MOVE_UP, gameState);
                                gameState.AIturn = true;
                            } else if (event.key.code == sf::Keyboard::Down) {
                                gameState.players[0].play(MOVE_DOWN, gameState);
                                gameState.AIturn = true;
                            } else if (event.key.code == sf::Keyboard::Left) {
                                gameState.players[0].play(MOVE_LEFT, gameState);
                                gameState.AIturn = true;
                            } else if (event.key.code == sf::Keyboard::Right) {
                                gameState.players[0].play(MOVE_RIGHT, gameState);
                                gameState.AIturn = true;
                            } else if (event.key.code == sf::Keyboard::Space) {
                                gameState.players[0].play(PLACE_BOMB, gameState);
                                gameState.AIturn = true;
                            }
                        }
                    }
                }
                
                void Game::update()
           1 -> {
                    // Update the players
                    int playerSize = gameState.players.size();
                    for (int i = 0; i < playerSize; ++i) {
                        gameState.players[i].update(gameState);
                    }
                
                    // Update the game state
                    gameState.update();
                }
                
                void Game::render()
         199 -> {
                    // Draw the current game state
                    gameState.level.draw(window, zoom);
                    
                    // Draw the players
                    int playerSize = gameState.players.size();
                    for (int i = 0; i < playerSize; ++i) {
                        gameState.players[i].draw(window, zoom);
                    }
                
                    // Draw the bonuses
                    int bonusSize = gameState.bonuses.size();
                    for (long unsigned i = 0; i < bonusSize; ++i) {
                        gameState.bonuses[i].draw(window, zoom);
                    }
                
                    // Draw the bombs
                    int bombSize = gameState.bombs.size();
                    for (long unsigned i = 0; i < bombSize; ++i) {
                        gameState.bombs[i].draw(window, zoom);
                    }
                
                    // Draw the flames
                    int flameSize = gameState.flames.size();
                    for (long unsigned i = 0; i < flameSize; ++i) {
                        gameState.flames[i].draw(window, zoom);
                    }
                
                    // Draw the HUD
                    HUD::draw(window, *this);
           1 -> }

Top 10 Lines:

     Line      Count

       97        199
      138        199
       13          1
       66          1
      126          1
      168          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      402   Total number of line executions
    67.00   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Flame.cpp:
                #include "Flame.h"
                #include "Game.h"
                
        3762 -> Flame::Flame(int x, int y) {
                    this->x = x;
                    this->y = y;
                    time_left = DEFAULT_FLAME_TIMER;
                
                    if (!texture.loadFromFile("assets/img/flame.png")) {
                        // handle error
                    }
                    sprite.setTexture(texture);
                }
                
       ##### -> void Flame::draw(sf::RenderWindow &window, int zoom) {
                    sprite.setScale(1.0/zoom, 1.0/zoom);
                    sprite.setTexture(texture);
                    sprite.setPosition(
                        (x * TILE_SIZE)/zoom,
                        (y * TILE_SIZE)/zoom
                    );
                    window.draw(sprite);
                }
                
        3762 -> void Flame::update() {
                    time_left--;
           1 -> }


Top 10 Lines:

     Line      Count

        4       3762
       25       3762
       27          1

Execution Summary:

        4   Executable lines in this file
        4   Lines executed
   100.00   Percent of the file executed

     7525   Total number of line executions
  1881.25   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/fast_log.cpp:
                #include "fast_log.hpp"
                #include <cassert>
                #include <limits>
                
           1 -> fast_log::fast_log(int mantissa_nb_bits)
                  : mantissa_shift(MAX_MANTISSA_NB_BITS - mantissa_nb_bits)
                {
                  assert(sizeof(int) == 4);
                  assert(std::numeric_limits<float>::is_iec559);
                  lookup_table = new float[1 << mantissa_nb_bits];
                  int_float x;
                  x._int = 0x3F800000;
                  int incr = (1 << mantissa_shift);
                  int p = (1 << mantissa_nb_bits);
                  float inv_log_two = 1.0f / log(2.0f);
                  for (int i = 0; i < p; ++i)
                    {
                      lookup_table[i] = log(x._float) * inv_log_two;
                      x._int += incr;
                    }
                }
                
       ##### -> fast_log::~fast_log()
                {
                  delete[] lookup_table;
       ##### -> }


Top 10 Lines:

     Line      Count

        5          1

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

        1   Total number of line executions
     0.33   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Bonus.cpp:
                #include "Bonus.h"
                #include "Game.h"
                
       ##### -> Bonus::Bonus() {
                    x = 0;
                    y = 0;
                    type = STRENGTH;
                }
                
         159 -> Bonus::Bonus(int x, int y, BonusType type) {
                    this->x = x;
                    this->y = y;
                    this->type = type;
                
                    if (!texture.loadFromFile("assets/img/bonus/" + std::to_string(type) + ".png")) {
                        // handle error
                    }
                    sprite.setTexture(texture);
                }
                
       ##### -> void Bonus::draw(sf::RenderWindow &window, int zoom) {
                    sprite.setScale(1.0/zoom, 1.0/zoom);
                    sprite.setTexture(texture);
                    sprite.setPosition(
                        (x * TILE_SIZE)/zoom,
                        (y * TILE_SIZE)/zoom
                    );
                    window.draw(sprite);
                }
                
       ##### -> void Bonus::update() {
                    // Do nothing
                }
                
         159 -> BonusType Bonus::getRandomType() {
                    return static_cast<BonusType>(rand() % 2);
           1 -> }

Top 10 Lines:

     Line      Count

       10        159
       35        159
       37          1

Execution Summary:

        6   Executable lines in this file
        6   Lines executed
   100.00   Percent of the file executed

      319   Total number of line executions
    53.17   Average executions per line


*** File /home/gabriel/Documents/INSA/S6/IA-games/project/Bomberman/src/Bomb.cpp:
                #include "Bomb.h"
                #include "Game.h"
                #include "Bonus.h"
                
                std::vector<std::string> *Bomb::bombTextures = new std::vector<std::string> {
                    "assets/img/bomb1.png",
                    "assets/img/bomb2.png",
                    "assets/img/bomb3.png",
                };
                
       ##### -> Bomb::Bomb() {
                    x = 0;
                    y = 0;
                    time_left = DEFAULT_BOMB_TIMER;
                    strength = 1;
                }
                
        1110 -> Bomb::Bomb(int x, int y, int timer, int strength, std::optional<int> owner) {
                    this->x = x;
                    this->y = y;
                    time_left = timer;
                    this->strength = strength;
                    this->owner = owner;
                
                    //std::cout << "Time left : " << time_left << std::endl;
                    //std::cout << "Size : " << bombTextures->size() << std::endl;
                    int textureIndex = time_left;
                    if (textureIndex > (int) bombTextures->size() - 1) {
                        textureIndex = bombTextures->size() - 1;
                    }
                    std::string texturePath = bombTextures->at(textureIndex);
                
                    if (!texture.loadFromFile(texturePath)) {
                        // handle error
                    }
                    sprite.setTexture(texture);
                }
                
       ##### -> void Bomb::draw(sf::RenderWindow &window, int zoom) {
                    sprite.setScale(1.0/zoom, 1.0/zoom);
                    sprite.setTexture(texture);
                    sprite.setPosition(
                        (x * TILE_SIZE)/zoom,
                        (y * TILE_SIZE)/zoom
                    );
                    window.draw(sprite);
                }
                
        3766 -> void Bomb::update() {
                    time_left--;
                }
                
        1249 -> std::vector<std::pair<int, int>> Bomb::explode(GameState &state) {
                    std::vector<std::pair<int, int>> flamePositions;
                
                    // Add flame position for the bomb itself
                    flamePositions.emplace_back(x, y);
                
                    // Check if the bomb is in the same position as a player
                    int playerSize = state.players.size();
                    for (int i = 0; i < playerSize; ++i) {
                        if (state.players[i].getX() == x && state.players[i].getY() == y) {
                            state.players[i].die();
                        }
                    }
                
                    // explode in all 4 directions
                    for (int i = 0; i < 4; ++i) {
                        for (int j = 1; j <= strength; ++j) {
                            int dx = 0;
                            int dy = 0;
                            if (i == 0) {
                                dx = j;
                            } else if (i == 1) {
                                dx = -j;
                            } else if (i == 2) {
                                dy = j;
                            } else if (i == 3) {
                                dy = -j;
                            }
                
                            int new_x = x + dx;
                            int new_y = y + dy;
                
                            if (state.level.isDestroyable(new_x, new_y)) {
                                state.level.destroyWall(new_x, new_y);
                                if (rand() % 100 < BONUS_SPAWN_CHANCE) {
                                    //std::cout << "Bonus " << new_x << " " << new_y << std::endl;
                                    state.bonuses.push_back(
                                        Bonus(new_x, new_y, Bonus::getRandomType())
                                    );
                                    //std::cout << "Bonus : " << bonuses.size() << std::endl;
                                }
                                flamePositions.emplace_back(new_x, new_y);
                                break;
                            } else {
                                for (int k = 0; k < playerSize; ++k) {
                                    if (state.players[k].getX() == new_x && state.players[k].getY() == new_y) {
                                        state.players[k].die();
                                    }
                                }
                                if (state.level.isundestroyWall(new_x, new_y)) {
                                    break;
                                }
                                flamePositions.emplace_back(new_x, new_y);
                            }
                        }
                    }
                    return flamePositions;
                }
                
        3766 -> void Bomb::changeTexture() {
                    if (time_left > (int) bombTextures->size() - 1) {
                        if (!texture.loadFromFile(bombTextures->at(bombTextures->size() - 1))) {
                            // handle error
                        }
                    } else {
                        if (!texture.loadFromFile(bombTextures->at(time_left))) {
                            // handle error
                        }        
                    }
           1 -> }

Top 10 Lines:

     Line      Count

       49       3766
      112       3766
       53       1249
       18       1110
      122          1

Execution Summary:

        7   Executable lines in this file
        7   Lines executed
   100.00   Percent of the file executed

     9892   Total number of line executions
  1413.14   Average executions per line
